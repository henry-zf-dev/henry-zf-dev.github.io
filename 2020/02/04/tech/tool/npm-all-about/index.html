<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Henry&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      NPM 相关知识点 | HenryV2进阶中…
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>HenryV2进阶中…</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>NPM 相关知识点</h2>
  <p class="post-date">2020-02-04</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>原文链接：<a href="https://juejin.im/post/5ab3f77df265da2392364341" target="_blank" rel="noopener">you don’t know npm</a></p>
<p>nodejs 社区乃至 Web 前端工程化领域发展到今天，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但是现实状况是，我们很多人对这个 nodejs 基础设施的使用和了解还停留在：会用 <code>npm install</code> 这里（一言不合就删除整个 node_modules 目录然后重新 install）</p>
<p>当然 npm 能成为现在世界上最大规模的<strong>包管理系统</strong>，很大程度上确实归功于它足够<strong>用户友好</strong>，你即使只会执行 install 也不必担心出大问题。但是 npm 的功能远不止于 install 这么简单。一下对 npm 的原理、特性、技巧以及最佳实践做一些归纳总结。</p>
<h3 id="1-npm-init"><a href="#1-npm-init" class="headerlink" title="1. npm init"></a>1. npm init</h3><p>我们都知道 package.json 文件是用来定义一个 package 的面熟文件，也知道 <code>npm init</code> 命令用来初始化一个简单的 package.json 文件，执行该命令后中断一次询问 name、version、description 等字段。</p>
<h4 id="1-1-npm-init-执行默认行为"><a href="#1-1-npm-init-执行默认行为" class="headerlink" title="1.1 npm init 执行默认行为"></a>1.1 npm init 执行默认行为</h4><p>而如果想要免去一直按 enter，只需要在命令后追加 –yes 参数即可执行默认行为。</p>
<p><code>npm init --yes</code></p>
<h4 id="1-2-自定义-npm-init-行为"><a href="#1-2-自定义-npm-init-行为" class="headerlink" title="1.2 自定义 npm init 行为"></a>1.2 自定义 npm init 行为</h4><p>npm init 命令的原理并不复杂，调用脚本，输出一个初始化的 package.json 文件。所有相应的，定制 npm init 命令的实现方式也不浮躁，在 Home 目录下创建一个 <code>.npm-init.js</code> 即可，该文件的 module.exports 即为 package.json 的配置内容，需要获取用户输入时，使用 <code>prompt()</code> 方法即可。</p>
<p>例如编写如下 ~/.npm-init.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = prompt(<span class="string">'description?'</span>, <span class="string">'A new package...'</span>);</span><br><span class="line"><span class="keyword">const</span> bar = prompt(<span class="string">'bar?'</span>, <span class="string">''</span>);</span><br><span class="line"><span class="keyword">const</span> count = prompt(<span class="string">'count?'</span>, <span class="string">'100'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  key: <span class="string">'value'</span>,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: bar,</span><br><span class="line">    count: count</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// process.cwd() 获取当前被执行的 js 文件的工作目录</span></span><br><span class="line">  name: prompt(<span class="string">'name?'</span>, process.cwd().split(<span class="string">'/'</span>).pop()),</span><br><span class="line">  version: prompt(<span class="string">'version?'</span>, <span class="string">'0.1.0'</span>),</span><br><span class="line">  description: desc,</span><br><span class="line">  main: <span class="string">'index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时在 ~/npm-all-about 目录下执行 <code>npm init</code> 将会生成这样的 package.json:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"foo"</span>: &#123;</span><br><span class="line">    <span class="attr">"bar"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="string">"100"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm-all-about"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A new package..."</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 .npm-init.js 是一个常规的模块，所以意味着，除了生成 package.json，我们可以执行任何 node 脚本来完成一些任务。例如通过 fs 创建 README、.eslintrc 等项目必需文件，实现项目脚手架的作用。</p>
<h3 id="2-依赖包安装"><a href="#2-依赖包安装" class="headerlink" title="2. 依赖包安装"></a>2. 依赖包安装</h3><p>依赖管理是 npm 的核心功能，原理是执行 <code>npm install</code> 从 package.json 中的 dependencies、devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。</p>
<h4 id="2-1-package-定义"><a href="#2-1-package-定义" class="headerlink" title="2.1 package 定义"></a>2.1 package 定义</h4><p>我们知道，要手动安装一个依赖包时，执行 <code>npm install &lt;package&gt;</code> 命令即可。这里的第三个参数 package 通常就是所需要安装的包名，默认配置下 npm 会从默认的源（Registry）中查找该包名对应的报地址，并下载安装。但除了可以简单地指定包名以外，package 还可以是一个执行有效包名的 http url/git url/ 文件夹路径。</p>
<p>阅读 <a href="https://docs.npmjs.com/getting-started/packages#what-is-a-package-" target="_blank" rel="noopener">npm 文档</a>，我们会发现 package 的准确订阅，只要符合以下a)到g)其中之一条件，就是一个 package:</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="left">说明</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a)</td>
<td align="left">一个包含了程序和描述该程序的 package.json 文件的 <strong>文件夹</strong></td>
<td align="left">./local-module/</td>
</tr>
<tr>
<td align="center">b)</td>
<td align="left">一个包含了(a)的 <strong>gzip 压缩文件</strong></td>
<td align="left">./module.tar.gz</td>
</tr>
<tr>
<td align="center">c)</td>
<td align="left">一个可以下载的(b)资源的 <strong>url</strong>(通常是 http(s) url)</td>
<td align="left"><a href="https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz" target="_blank" rel="noopener">https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz</a></td>
</tr>
<tr>
<td align="center">d)</td>
<td align="left">一个格式为 <code>&lt;name&gt;@&lt;version&gt;</code> 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件(c)</td>
<td align="left"><a href="mailto:webpack@4.1.0">webpack@4.1.0</a></td>
</tr>
<tr>
<td align="center">e)</td>
<td align="left">一个格式为 <code>&lt;name&gt;@&lt;tag&gt;</code> 的字符串，在 npm 源上该 <code>&lt;tag&gt;</code> 指向某个 <code>&lt;version&gt;</code> 得到 <code>&lt;name&gt;@&lt;version&gt;</code>，后者满足条件(d)</td>
<td align="left">webpack@latest</td>
</tr>
<tr>
<td align="center">f)</td>
<td align="left">一个格式为 <code>&lt;name&gt;</code> 的字符串，默认添加 <code>latest</code> 标签所得到的 <code>&lt;name&gt;@latest</code> 满足条件(e)</td>
<td align="left">webpack</td>
</tr>
<tr>
<td align="center">g)</td>
<td align="left">一个 <strong>git url</strong>，该 url 所指向的代码库满足条件(a)</td>
<td align="left"><a href="mailto:git@github.com">git@github.com</a>:webpack/webpack.git</td>
</tr>
</tbody></table>
<h4 id="2-2-安装本地包-远程-git-仓库包"><a href="#2-2-安装本地包-远程-git-仓库包" class="headerlink" title="2.2 安装本地包/远程 git 仓库包"></a>2.2 安装本地包/远程 git 仓库包</h4><p>上面表格的订阅意味着，我们在共享依赖包时，并不是非要将包发表到 npm 源上才可以提供给用着来安装。这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源进行改造，但依然需要把包共享出去的场景来说是非常实用的。</p>
<p><strong>场景1: 本地模块引用</strong></p>
<p>nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能遇到这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../../../../config.js'</span>);</span><br></pre></td></tr></table></figure>

<p>除了看上去不直观以外，这样的路径引用也不利于代码的重构。这样的重复代码多了也就意味着是时候把这个模块分离除了供应用中其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块使用。</p>
<p>无需手动开吧文件或者创建软连接到 node_modules 目录，npm 有更优雅的解决方案。</p>
<p><strong>方案：</strong></p>
<ol>
<li><p>创建 config 包：新增 config 文件夹；重命名 config.js 为 config/index.js 文件；创建 package.json 定义 config 包。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"config"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用层 package.json 文件中新增依赖项，然后执行 <code>npm install</code>；或直接执行第3步。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"config"</span>: <span class="string">"file:./config"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(等价于第2步) 直接在应用目录执行 <code>npm install file:./config</code>。</p>
</li>
</ol>
<p>此时，查看 <code>node_modules</code> 目录我们会发现多了一个名为 <code>config</code> 的依赖包，指向上层 <code>config/</code> 文件夹的软连接。这是因为 npm 识别 <code>file:</code> 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软连接到 node_modules 中，完成 “安装”过程。</p>
<p>相比手动软连接，我们既不需要关系 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 <code>npm install</code> 后直接使用。</p>
<p><strong>场景2: 私有 git 共享 package</strong></p>
<p>有些时候，我们一个团队内会有一些代码/公用库需要在团队内<strong>不同项目</strong>间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源上。</p>
<p>这种情况，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将 git url 保存到 dependencies 中。npm 会直接调用系统的 git 命令，从 git 仓库拉取包的内容到 node_modules 中。</p>
<p><a href="https://docs.npmjs.com/files/package.json#git-urls-as-dependencies" target="_blank" rel="noopener">npm 支持的 git url 格式:</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;:&#x2F;&#x2F;[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][&#x2F;]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure>

<p>git 路径后可以使用 # 指定特定的 git branch/commit/tag，也可以 #semver: 指定特定的 semver range。</p>
<blockquote>
<p>semver（语义化版本）约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号.</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm.git#v1.0.27</span><br><span class="line">git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm#semver:^5.0</span><br><span class="line">git+https:&#x2F;&#x2F;isaacs@github.com&#x2F;npm&#x2F;npm.git</span><br><span class="line">git:&#x2F;&#x2F;github.com&#x2F;npm&#x2F;npm.git#v1.0.27</span><br></pre></td></tr></table></figure>

<p><strong>场景3: 开源 package 问题修复</strong></p>
<p>使用某个 npm 包时发现他有某个严重的 bug，但或许最初坐着已不再维护代码了，又或许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。</p>
<p>此时我们可以手动进入 node_modules 目录下修改相应的内容，也许修改了一行代码就修复了问题。但是这种做法非常不明智！</p>
<p>首先 node_modules 本身不应该放进版本控制系统，对 node_modules 文件夹中内容的修改不会被记录进 git 提交记录了；其次，就算我们非要反模式，把 node_modules 放进版本控制中，你的修改内容也很容易在下次 team 中某个成员执行 <code>npm install</code> 或 <code>npm update</code> 时被覆盖，而这样的一次提交很可能包含了几十几百个包的更新，你自己所做的修改很容易就被淹没在庞大的 diff 文件列表中了，让版本控制变得非常不合理。</p>
<p><strong>方案：</strong></p>
<p>最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖更改为自己修复后版本的 git url 即可解决问题。（fork 代码库后，也便于向原作者体检 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。）</p>
<h3 id="3-npm-install-如何工作-–-node-modules-目录结构"><a href="#3-npm-install-如何工作-–-node-modules-目录结构" class="headerlink" title="3. npm install 如何工作 – node_modules 目录结构"></a>3. npm install 如何工作 – node_modules 目录结构</h3><p>npm install 执行完毕后，我们可以在 node_modules 中看到所有的依赖包。虽然使用者无需关注这个目录里的文件结构细节，只管在业务代码中引用依赖包即可，但了解 node_modules 的内容可以帮我们更好地理解 npm 如何工作，了解 npm2 到 npm5 有哪些变化和该井。</p>
<p>为简单起见，假设应用目录为 app，用两个流行的包 <code>webpack</code>、<code>nconf</code> 作为依赖包做实例说明。并且为了正常安装，使用了 npm2 时期的版本 <code>webpack@1.15.0</code>、<code>nconf@0.8.5</code>。</p>
<h4 id="3-1-npm2"><a href="#3-1-npm2" class="headerlink" title="3.1 npm2"></a>3.1 npm2</h4><p>npm2 在安装依赖包时，采用简单的递归安装方法。执行 <code>npm install</code> 后，npm2 依次递归安装 <code>webpack</code>、<code>nconf</code> 两个包到 node_modules 中。执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_modules&#x2F;</span><br><span class="line">├── nconf&#x2F;</span><br><span class="line">└── webpack&#x2F;</span><br></pre></td></tr></table></figure>

<p>进入更深一层 nconf 或者 webpack 目录，将看到这两个包各自的 node_modules 中，已经由 npm 递归安装好了自身的依赖包。包括 <code>./node_modules/webpack/node_modules/webpack-core</code>，<code>./node_modules/conf/node_modules/async</code> 等等。而每一个包都有自己的依赖包，每个包自己的依赖都安装在了自己的 node_modules 中。依赖关系层层递进，构成一整个依赖树，这个依赖树与文件系统中的问价结构树刚好层层对应。</p>
<p>最方便的查看依赖树的方式是直接在 app 目录下执行 <code>npm ls</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app@0.1.0</span><br><span class="line">├─┬ nconf@0.8.5</span><br><span class="line">│ ├── async@1.5.2</span><br><span class="line">│ ├── ini@1.3.5</span><br><span class="line">│ ├── secure-keys@1.0.0</span><br><span class="line">│ └── yargs@3.32.0</span><br><span class="line">└─┬ webpack@1.15.0</span><br><span class="line">  ├── acorn@3.3.0</span><br><span class="line">  ├── async@1.5.2</span><br><span class="line">  ├── clone@1.0.3</span><br><span class="line">  ├── ...</span><br><span class="line">  ├── optimist@0.6.1</span><br><span class="line">  ├── supports-color@3.2.3</span><br><span class="line">  ├── tapable@0.1.10</span><br><span class="line">  ├── uglify-js@2.7.5</span><br><span class="line">  ├── watchpack@0.2.9</span><br><span class="line">  └─┬ webpack-core@0.6.9</span><br><span class="line">    ├── source-list-map@0.1.8</span><br><span class="line">    └── source-map@0.4.4</span><br></pre></td></tr></table></figure>

<p>这样的目录结构优点在于层级结构明显，便于进行傻瓜式的管理：</p>
<ol>
<li>例如新增一个依赖包，可以立即在第一层 node_modules 中看到子目录。</li>
<li>在已知所需要包名和版本号时，甚至可以从别的文件夹手动拷贝需要的包到 node_modules 文件夹中，再手动修改 package.json 中的依赖配置。</li>
<li>要删除这个包，也可以简单地手动删除这个包的子目录，斌删除 package.json 文件中相对应的一行即可。</li>
</ol>
<p>实际上，很多人在 npm2 时代也的确这样实践过，的确也都可以安装和删除成功，并不会导致什么差错。</p>
<p>但这样的文件结构也有很明显的问题：</p>
<ol>
<li>对复杂的工程，node_module 内目录结构可能会太深，导致深层的文件路径过长而触发 windows 文件系统中，文件路径不能超过<strong>260</strong>个字符长度的限制。</li>
<li>部分被多个包所依赖的包，很可能在应用 node_modules 目录中的很多地方被重复安装。随着工程规模越来越多，依赖树越来越复杂，这样的包情况会越来越多，造成大量冗余。</li>
</ol>
<p>————在这个示例中,<code>webpack</code> 和 <code>nconf</code> 都依赖 <code>async</code> 这个包，所以在文件系统中，webpack 和 nconf 的 node_modules 子目录中都安装了相同的 async 包，并且是相同的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|                   app&#x2F;                    |</span><br><span class="line">+----------+------------------------+-------+</span><br><span class="line">           |                        |</span><br><span class="line">           |                        |</span><br><span class="line">+----------v------+       +---------v-------+</span><br><span class="line">|                 |       |                 |</span><br><span class="line">|  webpack@1.15.0 |       |  nconf@0.8.5    |</span><br><span class="line">|                 |       |                 |</span><br><span class="line">+--------+--------+       +--------+--------+</span><br><span class="line">         |                         |</span><br><span class="line">   +-----v-----+             +-----v-----+</span><br><span class="line">   |async@1.5.2|             |async@1.5.2|</span><br><span class="line">   +-----------+             +-----------+</span><br></pre></td></tr></table></figure>

<h4 id="3-2-npm3-扁平结构"><a href="#3-2-npm3-扁平结构" class="headerlink" title="3.2 npm3-扁平结构"></a>3.2 npm3-扁平结构</h4><p>主要为了解决以上问题，npm3 的 node_modules 目录改成； 更加扁平的层级结构。文件系统中 <code>webpack</code>、<code>nconf</code>、<code>async</code> 的层级关系变成了平级关系，处于同一级目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------+</span><br><span class="line">         |                   app&#x2F;                    |</span><br><span class="line">         +-+---------------------------------------+-+</span><br><span class="line">           |                                       |</span><br><span class="line">           |                                       |</span><br><span class="line">+----------v------+    +-------------+   +---------v-------+</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">|  webpack@1.15.0 |    | async@1.5.2 |   |  nconf@0.8.5    |</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">+-----------------+    +-------------+   +-----------------+</span><br></pre></td></tr></table></figure>

<p>虽然这样一来 webpack/node_modules 和 nconf/node_modules 中都不再有 async 文件夹，但得益于 node 的模块加载机制，他们都可以在上一级 node_modules 目录中找到 async 库。所以 webpack 和 nconf 的代码库中 <code>require(&#39;async&#39;)</code> 语句的执行都不会有任何问题。</p>
<p>这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况，npm3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。</p>
<p>npm 文档提供了更直接的例子解释这种情况：</p>
<blockquote>
<p>加入 <code>package{dep}</code> 写法代表包和包的依赖，那么 <code>A{B, C}</code>，<code>B{C}</code>，<code>C{D}</code> 的依赖结构在安装之后的 node_modules 是这样的结构：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">+-- D</span><br></pre></td></tr></table></figure>

<p>这里之所以 D 也安装到了与 B C 同一级目录，是因为 npm 默认会在无冲突的前提下，尽可能地将包安装到较高的层级。</p>
<blockquote>
<p>如果是 <code>A{B, C}</code>，<code>B{C, D@1}</code>，<code>C{D@2}</code> 的依赖关系，得到的安装后结构是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">   +-- D@2</span><br><span class="line">+-- D@1</span><br></pre></td></tr></table></figure>

<p>这里是因为，对与 npm 来说，同名但不同版本的包是两个独立的包，而同层不能有两个同名子目录，所以其中的 D@2 放到了 C 的子目录而另一个 D@1 被放到了再上一层的目录。</p>
<p>很明显在 npm3 之后 npm 的依赖树结构不再与文件夹层级一一对应了。想要查看 app 的直接依赖项，需要通过 <code>npm ls</code> 命令指定 <code>--depth</code> 参数来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls --depth 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：与本地依赖包把不同，如果我们通过 <code>npm install --global</code> 全局安装依赖包到全局目录时，得到的目录依然是”传统的”目录结构。而如果使用 npm3 想得到”传统”形式的本地 node_modules 目录，使用 <code>npm install --global-style</code> 即可。</p>
</blockquote>
<h4 id="3-3-npm5-package-lock-文件"><a href="#3-3-npm5-package-lock-文件" class="headerlink" title="3.3 npm5-package-lock 文件"></a>3.3 npm5-package-lock 文件</h4><p>npm5 发布与 2017 年，也是目前最新的 npm 版本，这一版本依然沿用 npm3 之后扁平化的依赖包安装方式，此外最大的变化时增加了 <code>package-lock.json</code> 文件。</p>
<p>package-lock.json 的作用是<strong>锁定</strong>依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件结构是一一对应的。</p>
<p>以依赖关系为：<code>app{webpack}</code> 的 ‘app’ 项目为例，其 package-lock 文件包含这样的片段：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:  <span class="string">"app"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:  <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="attr">"lockfileVersion"</span>:  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"requires"</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"1.8.11"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz"</span>,</span><br><span class="line">            <span class="attr">"integrity"</span>: <span class="string">"sha1-Yu0hnstBy/qcKuanu6laSYtgkcI="</span>,</span><br><span class="line">            <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                <span class="attr">"async"</span>: <span class="string">"0.9.2"</span>,</span><br><span class="line">                <span class="attr">"clone"</span>: <span class="string">"0.1.19"</span>,</span><br><span class="line">                <span class="attr">"enhanced-resolve"</span>: <span class="string">"0.8.6"</span>,</span><br><span class="line">                <span class="attr">"esprima"</span>: <span class="string">"1.2.5"</span>,</span><br><span class="line">                <span class="attr">"interpret"</span>: <span class="string">"0.5.2"</span>,</span><br><span class="line">                <span class="attr">"memory-fs"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">                <span class="attr">"mkdirp"</span>: <span class="string">"0.5.1"</span>,</span><br><span class="line">                <span class="attr">"node-libs-browser"</span>: <span class="string">"0.4.3"</span>,</span><br><span class="line">                <span class="attr">"optimist"</span>: <span class="string">"0.6.1"</span>,</span><br><span class="line">                <span class="attr">"supports-color"</span>: <span class="string">"1.3.1"</span>,</span><br><span class="line">                <span class="attr">"tapable"</span>: <span class="string">"0.1.10"</span>,</span><br><span class="line">                <span class="attr">"uglify-js"</span>: <span class="string">"2.4.24"</span>,</span><br><span class="line">                <span class="attr">"watchpack"</span>: <span class="string">"0.2.9"</span>,</span><br><span class="line">                <span class="attr">"webpack-core"</span>: <span class="string">"0.6.9"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"webpack-core"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"0.6.9"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz"</span>,</span><br><span class="line">            <span class="attr">"integrity"</span>: <span class="string">"sha1-/FcViMhVjad76e+23r3Fo7FyvcI="</span>,</span><br><span class="line">            <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                <span class="attr">"source-list-map"</span>: <span class="string">"0.1.8"</span>,</span><br><span class="line">                <span class="attr">"source-map"</span>: <span class="string">"0.4.4"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">                <span class="attr">"source-map"</span>: &#123;</span><br><span class="line">                    <span class="attr">"version"</span>: <span class="string">"0.4.4"</span>,</span><br><span class="line">                    <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz"</span>,</span><br><span class="line">                    <span class="attr">"integrity"</span>: <span class="string">"sha1-66T12pwNyZneaAMti092FzZSA2s="</span>,</span><br><span class="line">                    <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                        <span class="attr">"amdefine"</span>: <span class="string">"1.0.1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看懂 package-lock 文件并不难，其结构是同样类型的几个字段嵌套起来的，只要是 <code>version</code>，<code>resolved</code>，<code>integrity</code>，<code>requires</code>，<code>dependencies</code> 这几个字段。</p>
<ul>
<li><code>version</code>，<code>resolved</code>，<code>integrity</code> 用来记录包的准确版本号、安装源、内容 hash，决定了要安装的包的准确”身份<br>信息。</li>
<li>假设不看其他字段，只关注 <code>dependencies: {}</code>，可以发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次机构是完全对照的。</li>
<li>假设只关注 <code>requires: {}</code>，可以发现，除去最外层的 <code>requires</code> 属性为 true 以外，其它层的 requires 属性都对应着这个包的 package.json 里记录自己的所有依赖项。</li>
</ul>
<p>因为这个文件记录了 node_modules 里所有包的结构、层级和版本号，甚至安装源，它也就事实上提供了”保存” node_modules 状态的能力。只要有这样一个 lock 文件，那不管在哪一台机器上执行 <code>npm install</code> 都会得到完全相同的 node_modules 结果。</p>
<p>这就是 package-lock 文件致力于优化的场景：在从前仅仅用 package.json 记录依赖，由于 semver range 机制，一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 <code>npm install</code>，所得到的的 node_modules 结果很可能和一个月前 A 得到的结果存在许多差异，虽然 semver 有机制的限制，同一份 package.json 不会生成大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。</p>
<p>其实，相同作用的文件在 npm5 之前就有，成为 <code>npm shrinkwrap</code> 文件，二者作用完全相同，不同的是后者需要手动生成，而 npm5 默认会在执行 <code>npm install</code> 后就生成 package-lock 文件，并建议提交到 gi/svn 代码库中。</p>
<p>package-lock.json 文件在最初 npm5.0 默认引入时引起了相当大的<a href="https://github.com/npm/npm/issues/16866" target="_blank" rel="noopener">争议</a>。在 npm5.0 中，如果已有 package-lock 文件存在，若手动在 package.json 文件中新增一条依赖，再执行 <code>npm install</code>，新增的依赖并不会被安装到 node_modules 中，package-lock 也不会做相应的更新。这样的表现与使用者的自然期望表现不符。在 npm5.1 的首个 <a href="https://github.com/npm/npm/issues/16866" target="_blank" rel="noopener">Release</a> 版本中这个问题得以修复。所以这个事情告诉我吗，要升级，不要使用 npm5.0 版本。</p>
<p>————但依然有反对的声音认为 package-lock 太复杂，对此 npm 也提供了禁用配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set package-lock false</span><br></pre></td></tr></table></figure>


<h3 id="4-依赖包版本管理"><a href="#4-依赖包版本管理" class="headerlink" title="4. 依赖包版本管理"></a>4. 依赖包版本管理</h3><p>依赖包安装完并不意味着就万事大吉了，版本的维护和更新也很重要。这一章介绍依赖包升级管理相关知识。</p>
<h4 id="4-1-semver"><a href="#4-1-semver" class="headerlink" title="4.1 semver"></a>4.1 semver</h4><p>npm 依赖管理的一个重要特性是采用了<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本规范(semver)</a>，作为依赖<strong>版本</strong>管理方案。</p>
<p>semver 约定一个包的版本号必须包含 <strong>3</strong> 个数字，格式必须为 <code>MAJOR.MINOR.PATCH</code>，意为 <code>主版本号.小版本号.修订版本号</code>。</p>
<ul>
<li>MAJOR 对应大的版本号迭代，做了不兼容旧版本的修改时要更新 MAJOR 版本号</li>
<li>MINOR 对应小版本迭代，发生兼容旧版本 API 的修改或者更能更新时，更新 MINOR 版本号</li>
<li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号</li>
</ul>
<p>对应包作者（发布者），npm 要求在 publish 之前，必须更新版本号。npm 提供了 <code>npm version</code> 工具，执行 <code>npm version major|minor|patch</code> 可以简单地将版本号中响应的数字 <code>+1</code>。</p>
<blockquote>
<p>如果包是一个 git 仓库，<code>npm version</code> 还会自动创建一条注释为更新后版本号的 git commit 和名为该版本号的 tag。</p>
</blockquote>
<p>对于包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 <a href="https://semver.npmjs.com" target="_blank" rel="noopener">https://semver.npmjs.com</a> 可方便地计算所输入的表达式的匹配范围。常规的规则示例如下表：</p>
<table>
<thead>
<tr>
<th align="left">range</th>
<th align="left">含义</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>^2.2.1</code></td>
<td align="left">指定的 MAJOR 版本号下，所有更新的版本</td>
<td align="left">匹配 <code>2.2.3</code>，<code>2.3.0</code>；不匹配 <code>1.0.3</code>，<code>3.0.1</code></td>
</tr>
<tr>
<td align="left"><code>~2.2.1</code></td>
<td align="left">指定 MAJOR.MINOR 版本号下，所有更新的版本</td>
<td align="left">匹配 <code>2.2.3</code>，<code>2.2.9</code>；不匹配 <code>2.3.0</code>，<code>2.3.5</code></td>
</tr>
<tr>
<td align="left"><code>&gt;=2.1</code></td>
<td align="left">版本号大于或等于 <code>2.1.0</code></td>
<td align="left">匹配 <code>2.1.2</code>，<code>3.1</code>；</td>
</tr>
<tr>
<td align="left"><code>&lt;=2.2</code></td>
<td align="left">版本号小于或等于 <code>2.2</code></td>
<td align="left">匹配 <code>1.0.0</code>，<code>2.2.1</code>，<code>2.2.11</code></td>
</tr>
<tr>
<td align="left"><code>1.0.0 - 2.0.0</code></td>
<td align="left">版本号从 <code>1.0.0(包含)</code> 到 <code>2.0.0(包含)</code></td>
<td align="left">匹配 <code>1.0.0</code>，<code>1.3.4</code>，<code>2.0.0</code></td>
</tr>
</tbody></table>
<p>任意两条规则，通过空格连接起来，表示”与”逻辑，即两条规则的交集：</p>
<p>如 <code>&gt;=2.3.1 &lt;=2.8.0</code> 可以解读为：<code>&gt;=2.3.1</code> 且 <code>&lt;=2.8.0</code>。</p>
<ul>
<li>匹配 <code>2.3.1</code>，<code>2.4.5</code>，<code>2.8.0</code></li>
<li>不匹配 <code>1.0.0</code>，<code>2.3.0</code>，<code>2.8.1</code>，<code>3.0.0</code></li>
</ul>
<p>任意两条规则，通过 <code>||</code> 连接起来，表示”或”逻辑，即两条规则的并集：</p>
<p>如 <code>^2 &gt;=2.3.1 || ^3 &gt;3.2</code></p>
<ul>
<li>匹配 <code>2.3.1</code>，<code>2.8.1</code>，<code>3.3.1</code></li>
<li>不匹配 <code>1.0.0</code>，<code>2.2.0</code>，<code>3.1.0</code>，<code>4.0.0</code></li>
</ul>
<p>PS：处理这几种，还有如下更直观的表示版本号范围的写法：</p>
<ul>
<li><code>*</code> 或 <code>x</code> 匹配徐偶有主版本</li>
<li><code>1</code> 或 <code>1.x</code> 匹配主版本为 <strong>1</strong> 的所有版本</li>
<li><code>1.2</code> 或 <code>1.2.x</code> 匹配版本号为 <strong>1.2</strong> 开头的所有版本</li>
</ul>
<p>PPS：在常规仅包含数字的版本号之外，semver 还允许在 <code>MAJOR.MONOR.PATCH</code> 后追加 <code>-</code> 后跟点号分隔的标签，作为预发布版本标签 - <a href="https://github.com/npm/node-semver#prerelease-tags" target="_blank" rel="noopener">Prerelese Tags</a>，通常被视为不稳定、不建议生产环境使用的版本。例如：</p>
<ul>
<li><code>1.0.0-alpha</code></li>
<li><code>1.0.0-beta.1</code></li>
<li><code>1.0.0-rc.3</code></li>
</ul>
<p>上表中我们最常见的是 <code>^1.8.11</code> 这种格式的 range，因为我们使用 <code>npm install &lt;package&gt;</code> 安装依赖包时，npm 默认安装当前最新版本，例如 <code>1.8.11</code>，然后在所安装的版本号前加 <code>^</code> 号，将 <code>^1.8.11</code> 写入 package.json 依赖配置，意味着可以匹配 <code>1.8.11</code> 以上，<code>2.0.0</code> 以下所有的版本。</p>
<h4 id="4-2-依赖版本升级"><a href="#4-2-依赖版本升级" class="headerlink" title="4.2 依赖版本升级"></a>4.2 依赖版本升级</h4><p>在安装完一个依赖包之后又新版本发布了，如何使用 npm 进行版本升级呢？答案很简单：<code>npm install</code> 或 <code>npm update</code> 即可。但在不同 npm 版本，不同的 package.json，package-lock.json 文件，安装升级的表现也不同。</p>
<p>还是以 <code>webpack</code> 为例，做如下<strong>前提假设:</strong></p>
<ul>
<li>工程项目 <code>app</code> 依赖 <code>webpack</code></li>
<li>项目最初始化时，安装了当时最新的包 <code>webpack@1.8.0</code>，并且 package.json 中依赖配置为：<code>&quot;webpack&quot;: &quot;^1.8.0&quot;</code></li>
<li>当前（2018年3月）<code>webpack</code> 最新版本为 <code>4.2.0</code>，<code>webpack 1.x</code> 的最新子版本为 <code>1.15.0</code></li>
</ul>
<p>如果我们使用的是 npm3，并且项目不包含 package-lock.json，那么根据 node_modules 是否为空，执行 install/update 结果如下（<strong>node 6.13.1, npm 3.10.10</strong> 环境下测试）：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">package.json(BEFORE)</th>
<th align="left">node_modules(BEFORE)</th>
<th align="left">command(npm 3)</th>
<th align="left">package.json(AFTER)</th>
<th align="left">node_modules(AFTER)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
<td align="left"><code>install</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
</tr>
<tr>
<td align="left">b)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>空</code></td>
<td align="left"><code>install</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
<tr>
<td align="left">c)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
<tr>
<td align="left">d)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>空</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
</tbody></table>
<p>根据上表可以对 npm3 做出以下结论：</p>
<ul>
<li>如果本地 node_modules 已安装，再次执行 install 不会更新包版本，执行 update 才会更新；而如果本地 node_modules 为空时，执行 install/update 都会直接安装更新包；</li>
<li>npm update 总会把包更新到符合 package.json 中指定的 semver 的最新版本——本例中符合 <code>^1.8.0</code> 的最新版本为 <code>1.15.9</code>0</li>
<li>一旦给定 package.json，无论后面执行 npm install 还是 update，package.json 中的 webpack 版本一直保持开始的 <code>^1.8.0</code> 不变</li>
</ul>
<p>这里不合理的地方在于，如果最开始团队中第一个人安装了 <code>webpack@1.8.0</code>，而新加入项目的成员，checkout 工程代码后，执行 <code>npm install</code> 会安装得到不太一样的 <code>1.15.0</code> 版本。虽然 semver 约定了小版本号应当向下兼容（相同大版本号下的小版本号兼容），但万一有不熟悉不遵守此约定的包发布者，发布了不兼容的包，此时就可能出现因依赖环境不同导致的 bug。</p>
<p>如果我们使用的是 npm5，并且项目包含 package-lock.json 文件，那么根据 node_modules 是否为空，执行 install/update 结果如下（<strong>node 9.8.0, npm 5.7.1</strong> 环境下测试）：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">package.json(BEFORE)</th>
<th align="left">node_modules(BEFORE)</th>
<th align="left">package-lock(BEFORE)</th>
<th align="left">command(npm 3)</th>
<th align="left">package.json(AFTER)</th>
<th align="left">node_modules(AFTER)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
<td align="left"><code>@1.8.0</code></td>
<td align="left"><code>install</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
</tr>
<tr>
<td align="left">b)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>空</code></td>
<td align="left"><code>@1.8.0</code></td>
<td align="left"><code>install</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
</tr>
<tr>
<td align="left">c)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.8.0</code></td>
<td align="left"><code>@1.8.0</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.15.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
<tr>
<td align="left">d)</td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>空</code></td>
<td align="left"><code>@1.8.0</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.8.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
<tr>
<td align="left">e)</td>
<td align="left"><code>webpack: ^1.15.0</code></td>
<td align="left"><code>webpack@1.8.0(旧)</code></td>
<td align="left"><code>@1.15.0</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.15.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
<tr>
<td align="left">f)</td>
<td align="left"><code>webpack: ^1.15.0</code></td>
<td align="left"><code>webpack@1.8.0(旧)</code></td>
<td align="left"><code>@1.15.0</code></td>
<td align="left"><code>update</code></td>
<td align="left"><code>webpack: ^1.15.0</code></td>
<td align="left"><code>webpack@1.15.0</code></td>
</tr>
</tbody></table>
<p>与 npm3 相比，在安装和更新依赖版本上主要的区别为：</p>
<ul>
<li>无论何时执行 install，npm 都会优先按照 package-lock 中指定的版本来安装 webpack，避免了 npm3 表中情况(b)的出现</li>
<li>无论何时执行 install/update，package-lock 文件总会跟着 node_modules 更新（因此可以视 package-lock 文件为 node_modules 的 JSON 表述）</li>
<li>已安装 node_modules 后若执行 npm update，package.json 中版本号也会随之更改为 <code>^1.15.0</code></li>
</ul>
<p>由此可见，npm5.1 使得 package.json 和 package-lock.json 中所保存的版本号更加统一，解决了 npm 之前的各种问题。只要准寻好的实践习惯，团队成员可以很方便地维护一套应用代码和 node_modules 依赖都一致的环境。</p>
<h4 id="4-3-最佳实践"><a href="#4-3-最佳实践" class="headerlink" title="4.3 最佳实践"></a>4.3 最佳实践</h4><ul>
<li><p>使用 npm: <code>&gt;=5.1</code> 版本，保持 package-lock.json 文件默认开启配置</p>
</li>
<li><p>初始化：第一作者初始化项目时使用 <code>npm install &lt;package&gt;</code> 安装依赖包，默认保存 <code>^X.Y.Z</code> 依赖 range 到 package.json 中；提交 <code>package.json</code>，<code>pacakge-lock.json</code>，不提交 <code>node_modules</code> 目录。</p>
</li>
<li><p>初始化：项目成员首次 checkout/clone 项目代码后，执行一次 <code>npm install</code> 安装依赖包</p>
</li>
<li><p>不要手动修改 package-lock.json 文件</p>
</li>
<li><p>升级依赖包：</p>
<ul>
<li>升级小版本：本地执行 <code>npm update</code> 升级到新的小版本</li>
<li>升级大版本：本地执行 <code>npm install &lt;package-name&gt;@&lt;version&gt;</code> 升级到新的大版本</li>
<li>也可以手动修改 package.json 中版本号为要升级的版本（大于现有版本号）并指定所需的 semver，然后执行 <code>npm install</code></li>
<li>本地验证升级后新版本无问题后，提交新的 package.json，package-lock.json 文件</li>
</ul>
</li>
<li><p>降级依赖包：</p>
<ul>
<li>正确：<code>npm install &lt;package-name&gt;@&lt;version&gt;</code> 验证无问题后，提交新的 package.json，package-lock.json文件</li>
<li>错误：手动修改 package.json 中的版本号为更低的版本 semver，这样修改并不会生效，因为再次执行 <code>npm install</code> 依然会安装 package-lock.json 中锁定的版本</li>
</ul>
</li>
<li><p>删除依赖包：</p>
<ul>
<li>方案1：<code>npm uninstall &lt;package&gt;</code> 并提交 package.json，package-lock.json 文件</li>
<li>方案2： 把要卸载的包从 package.json 中 dependencies 字段删除，然后执行 <code>npm intall</code> 并提交 package.json，package-lock.json 文件</li>
</ul>
</li>
<li><p>任何时候有人提交了 package.json，package-lock.json 更新后，团队其他成员应该在拉取最新代码后执行 <code>npm install</code> 安装更新后的依赖包</p>
</li>
</ul>
<h3 id="5-npm-scripts"><a href="#5-npm-scripts" class="headerlink" title="5. npm scripts"></a>5. npm scripts</h3><h4 id="5-1-基本使用"><a href="#5-1-基本使用" class="headerlink" title="5.1 基本使用"></a>5.1 基本使用</h4><p>npm scripts 是 npm 另一个很重要的特性。通过 package.json 中 scripts 字段定义一个搅拌，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"echo"</span>: <span class="string">"echo hello world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以通过 <code>npm run echo</code> 命令来执行这段脚本，像在 shell 中执行命令 <code>echo hello world</code> 一样，看到终端输出 <code>hello world</code></p>
<p>npm scripts 提供了一个简单的接口来调用工程相关的脚本。关于更详细的信息，可以参考阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts 使用指南</a></p>
<p>总结阮一峰老师文章内容：</p>
<ol>
<li><code>npm run</code> 命令执行时，会把 <code>./node_modules/.bin/</code> 目录添加到执行环境的 <code>PATH</code> 变量中，因此如果某个<strong>命令行包</strong>没有全局安装，而只安装在了当前项目的 node_modules 中，通过 <code>npm run</code> 一样可以调用该命令</li>
<li>执行 npm 脚本时要传入参数，需要在命令后加 <code>--</code> 标明，如 <code>npm run test -- --grep=&quot;pattern&quot;</code> 可以将 <code>--grep=&quot;pattern&quot;</code> 参数传递给 <code>test</code> 命令</li>
<li>npm 提供了 <code>pre</code> 和 <code>post</code> 两个钩子机制，可以定义某个脚本执行前后的所要执行的脚本</li>
<li>运行时变量：在 <code>npm run</code> 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 <code>process.env</code> 对象访问获得：<ul>
<li><code>npm_lifecycle_event</code> ——正在运行的脚本名称</li>
<li><code>npm_package_&lt;key&gt;</code> ——获取当前包 package.json 中某个字段的配置值：如 <code>npm_package_name</code> 获取报名</li>
<li><code>npm_package_&lt;key&gt;_&lt;sub-key&gt;</code> —— package.json 中嵌套字段属性：如 <code>npm_package_dependencies_webpack</code> 可以获取到 package.json 中的 <code>dependencies.webpack</code> 字段的值，及 webpack 的版本号</li>
</ul>
</li>
</ol>
<h4 id="5-2-node-modules-bin-目录"><a href="#5-2-node-modules-bin-目录" class="headerlink" title="5.2 node_modules/.bin 目录"></a>5.2 node_modules/.bin 目录</h4><p>上面所说的 <code>node_module/.bin</code> 目录，保存了依赖目录中所安装的可供调用的<strong>命令行包</strong></p>
<p>何谓命令行包？例如 <code>webpack</code> 就属于一个命令行包。如果我们在安装 webpack 时添加 <code>--global</code> 参数，就可以在终端直接输入 <code>webpack</code> 进行调用。但如果不加 <code>--global</code> 参数，我们会在 <code>node_moldues/.bin</code> 目录里看到名为 webpack 的文件，如果在终端直接输入 <code>./node_modules/.bin/webpack</code> 命令，一样可以执行。</p>
<p>这是因为 <code>webpack</code> 在 <code>package.json</code> 文件中定义了 <code>bin</code> 字段为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bin 字段的配置格式为：<code>&lt;command&gt;: &lt;file&gt;</code>，即<code>命令名: 可执行文件</code>。npm 执行 install 时，会分析每个依赖包的 package.json 中 <code>bin</code> 字段，并将其包含的条目安装到 <code>./node_modules/.bin</code> 目录中，文件名为 <code>&lt;command&gt;</code>。而如果是全局模式安装，则会在 npm 全局安装路径的 bin 目录下创建指向 <code>&lt;file&gt;</code> 名为 <code>&lt;command&gt;</code> 的软连接。因此，<code>,.node_modules/.bin/webpack</code> 文件在通过命令行调用时，实际上就是执行 <code>node ./node_modules/.bin/webppack.js</code> 命令</p>
<p>正如上一节所说，<code>npm run</code> 命令在执行时会把 <code>./node_modules/.bin</code> 加入到 <code>PATH</code> 中，使得我们可以直接调用所有提供了命令行调用接口的依赖包。所以最佳的实践是：</p>
<blockquote>
<p>将项目依赖的命令行工具安装到项目依赖文件夹中，然后通过 npm scripts 调用，而非全局安装</p>
</blockquote>
<p>举例而言，<code>webpack</code> 作为前端最常用的构建工具，虽然我们都习惯了全局安装并直接使用命令行调用，但不同的项目依赖的 webpack 版本可能不同，响应的 <code>webpack.config.js</code> 配置文件也可能只兼容了特定版本的 webpack，如果我们仅仅全局安装了罪行的 webpack4.x，并使用 webpack 命令调用，在一个依赖 webpack3.x 的工程中就会无法成功执行构建</p>
<p>但如果这类工具总是本地安装，我们要调用一个命令，要手动添加 <code>./node_modules/.bin</code> 这个很长的前缀，未免就太麻烦了，于是 npm 从 <strong>5.2</strong> 版本开始自带了一个新的工具：<code>npx</code></p>
<h4 id="5-3-npx"><a href="#5-3-npx" class="headerlink" title="5.3 npx"></a>5.3 npx</h4><p>npx 的使用很简单，执行 <code>npx &lt;command&gt;</code> 即可，这里的 <code>&lt;command&gt;</code> 默认就是 <code>./node_modules</code> 目录中安装的可执行脚本名。例如上面本地安装后的 webpack 包，我们可以直接使用 <code>npx webpack</code> 执行即可</p>
<p>处理这种最简单的场景，npm cli 团队开发者 Kat Marchan 还在这篇文章中介绍了其他几种 npx 的用法：<a href="https://bit.ly/2uzuIHv" target="_blank" rel="noopener">Introducing npx: an npm package runner</a>，国内也有位开发者 robin.law 将原文翻译为中文：<a href="https://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/" target="_blank" rel="noopener">npx是什么，为什么需要npx?</a></p>
<p>总结：</p>
<p><strong>场景A：一键执行远程 npm 源的二进制包</strong></p>
<p>除了在 package 中执行 <code>./node_modules/.bin</code> 中已经安装的命令，还可以直接指定未安装的二进制包名执行。例如我们在一个没有 package.json 也没有 node_modules 的目录下，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx cowsay hello</span><br></pre></td></tr></table></figure>

<p>npx 将会从 npm 源下载 <code>cowsay</code> 这个包（但不安装）并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> _______ </span><br><span class="line">&lt; hello &gt;</span><br><span class="line"> ------- </span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\&#x2F;\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure>

<p>这种用途非常适合的场景：</p>
<ul>
<li>在本地简单测试或调试 npm 源上这些二进制包的功能</li>
<li>调用 create-react-app 或 yeoman 这类往往每个项目只需要使用一次的脚手架工具</li>
</ul>
<p><strong>场景B：一建执行 GitHub Gist</strong></p>
<p>在 [2.1 package 定义] 这一节中，<code>npm install &lt;package&gt;</code> 可以使包含了有效 package.json 的 git url</p>
<p>而 GitHub Gist 也是 git 仓库的一种，集合 npx 就可以方便地将简单的脚本共享给其他人，用于该链接的人无需将脚本安装到本地工作目录也可以执行。将 package.json 和需要执行的二进制脚本上传至 Gist，再运行 <code>npx &lt;gist url&gt;</code> 就可以方便地执行该 Gist 定义的命令</p>
<p>原文作者 Kat Marchan 提供了 <a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="noopener">示例</a>，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx https:&#x2F;&#x2F;gist.github.com&#x2F;zkat&#x2F;4bc19503fe9e9309e2bfaa2c58074d32</span><br></pre></td></tr></table></figure>

<p>可以得到一个来自 GitHub Gist 的 hello world 问候</p>
<p><strong>场景C：使用不同版本的 node 执行命令</strong></p>
<p>将 npx 与 Aria Stewart 创建的 <code>node</code> 包(<a href="https://www.npmjs.com/package/node" target="_blank" rel="noopener">https://www.npmjs.com/package/node</a>) 结合，可以实现在一行命令中使用指定版本的 node 执行命令</p>
<p>例如先后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx node@4 -e &quot;console.log(process.version)&quot;</span><br><span class="line">npx node@6 -e &quot;console.log(process.version)&quot;</span><br></pre></td></tr></table></figure>

<p>将分别输出 <code>v4.8.7</code> 和 <code>v6.13.0</code></p>
<p>往常这种工作是由 <code>nvm</code> 这类 node 版本管理工具来做的，但 <code>npx node@4</code> 这种方式免去了 nvm 手动切换配置的步骤，更加简洁简单</p>
<h3 id="6-npm-配置"><a href="#6-npm-配置" class="headerlink" title="6. npm 配置"></a>6. npm 配置</h3><h4 id="6-1-npm-config"><a href="#6-1-npm-config" class="headerlink" title="6.1 npm config"></a>6.1 npm config</h4><p>npm cli 提供了 <code>npm config</code> 命令进行 npm 相关配置，通过 <code>npm config ls -l</code> 可查看 npm 的所有配置，包括默认配置。npm 文档页为每个配置项提供了详细的说明 <a href="https://docs.npmjs.com/misc/config" target="_blank" rel="noopener">https://docs.npmjs.com/misc/config</a></p>
<p>修改配置的命令为：<code>npm config set &lt;ket&gt; &lt;value&gt;</code>，我们使用相关的常见重要配置：</p>
<ul>
<li><code>proxy</code>，<code>https-procy</code> ——指定 npm 使用的代理</li>
<li><code>registry</code> ——指定 npm 下载安装时的源，默认为 <a href="https://registry.npmjs.org/，可以指定私有的" target="_blank" rel="noopener">https://registry.npmjs.org/，可以指定私有的</a> Registry 源</li>
<li><code>package-lock</code> ——指定是否默认生成 package-lock 文件，建议保持默认 true</li>
<li><code>save</code> —— true/false 指定是否在 npm install 后保存依赖包为 dependencies，npm5 起默认为 true</li>
</ul>
<p>删除指定的配置项命令为：<code>npm config delete &lt;key&gt;</code></p>
<h4 id="6-2-npmrc-文件"><a href="#6-2-npmrc-文件" class="headerlink" title="6.2 npmrc 文件"></a>6.2 npmrc 文件</h4><p>除了使用 CLI 提供的 <code>npm config</code> 命令显示更改 npm 配置，还可以通过 <code>npmrc</code> 文件直接修改配置</p>
<p>这样的 npmrc 文件优先级由高到低包括：</p>
<ul>
<li>工程内配置文件：<code>/path/to/my/project/.npmrc</code></li>
<li>用户级配置文件：<code>!/.npmrc</code></li>
<li>全局配置文件：<code>$PREFIX/etc/npmrc</code>（即 <code>npm config get globalconfig 输出的路径</code>）</li>
<li>npm 内置配置文件：<code>path/to/npm/npmrc</code></li>
</ul>
<p>通过这个机制，我们可以方便地在工程根目录创建一个 <code>.pnmrc</code> 文件来共享需要在团队间共享的 npm 运行相关配置。比如如果我们在公司内网环境下需要通过代理才可以访问 registry.npmjs.org 源，或需要访问内网的 registry，就可以在工作项目下新增 .npmrc 文件并提交代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;</span><br><span class="line">https-proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;</span><br><span class="line">registry &#x3D; http:&#x2F;&#x2F;registry.example.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>因为项目级 .pnmrc 文件的作用域只作用在本项目下，所以在非本目录下，这些配置并不生效。对于使用笔记本工作的开发者，可以很好地隔离公司的工作项目、在家学习研究项目两种不同的环境</p>
<p>将这个功能已 <code>~/.npm-init.js</code> 配置相结合，可以将特定配置的 .npmrc 跟 .gitignore，README 之类的文件一起做到 npm init 脚手架中，进一步减少手动配置。</p>
<h4 id="6-3-node-版本约束"><a href="#6-3-node-版本约束" class="headerlink" title="6.3 node 版本约束"></a>6.3 node 版本约束</h4><p>虽然一个项目的团队都共享了相同的diamante，但每个人的开发及其可能安装了不同的 node 版本，此外服务器端的版本也可能和本地开发机器不一致</p>
<p>这又是一个可能带来不一致性的隐私——但也可以通过<strong>声明式约束+脚本限制</strong>来解决</p>
<p><strong>声明</strong>：通过 <code>package.json</code> 的 <code>engines</code> 属性声明应用运行所需的版本运行时要求。例如项目中使用了 <code>async</code>，<code>awit</code> 特性，<a href="https://node.green/" target="_blank" rel="noopener">查阅兼容性表格</a>得知最低支持版本为 7.6.0，因此指定 engines 配置为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=7.6.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>强约束(可选)</strong>：在 npm 中以上字段内容仅作为建议字段使用，若要在私有项目中添加强约束，需要自己写脚本钩子，读取并解析 engines 字段的 semver rang ，然后与运行时环境做对比校验，做适当提醒</p>
<h3 id="7-小结-npm-最佳实践"><a href="#7-小结-npm-最佳实践" class="headerlink" title="7. 小结 npm 最佳实践"></a>7. 小结 npm 最佳实践</h3><ul>
<li>使用 npm-init 初始化新项目</li>
<li>统一项目配置：需要团队共享的 npm config 配置项，固化到 .npmrc 文件中</li>
<li>统一运行环境，统一 package.json，package-lock.json 文件</li>
<li>合理使多样化的源安装依赖包：<code>npm install &lt;git url&gt;|&lt;local file&gt;</code></li>
<li>使用 npm: &gt;=5.2 版本</li>
<li>使用 npm scripts 与 npx(npm: &gt;=5.2) 脚本管理应用相关脚本</li>
</ul>
<h3 id="8-更多资料"><a href="#8-更多资料" class="headerlink" title="8. 更多资料"></a>8. 更多资料</h3><p>参考</p>
<ul>
<li>npm team 成员 Ashley Williams 在 2016 年 Node.js Live 的 talk：You Don’t Know npm，当时还没有 npm5<ul>
<li>YouTube 视频连接：<a href="https://www.youtube.com/watch?v=hopWbVKmiVQ&t=537s" target="_blank" rel="noopener">Node.js Live (Paris) - Ashley Williams, You Don’t Know npm</a></li>
<li>演讲用的 sliders：<a href="http://ashleygwilliams.github.io/you-dont-know-npm" target="_blank" rel="noopener">the ag_deck</a></li>
</ul>
</li>
<li>这篇 2015 年的文章介绍了如何使用本地模块打包 node_modules 依赖：<a href="https://bit.ly/2DLnaCd" target="_blank" rel="noopener">Build modular application with npm local modules</a></li>
<li>一篇很好的介绍 package-lock.json 的文章：<a href="https://bit.ly/2Fiok9Z" target="_blank" rel="noopener">Everything you wanted to know about package-lock.json</a></li>
<li>阮一峰 <a href="http://ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts 使用指南</a></li>
<li>Kat Marchan 介绍 npx:<ul>
<li>原文：<a href="http://t.cn/RKIYHBA" target="_blank" rel="noopener">Introducing npx: an npm package runner</a></li>
<li>中文：<a href="https://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/" target="_blank" rel="noopener">npx是什么，为什么需要npx?</a></li>
</ul>
</li>
</ul>
<p>文档</p>
<ul>
<li>npm 官方文档，无中文翻译<ul>
<li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">package.json 文件</a></li>
<li><a href="https://docs.npmjs.com/misc/config" target="_blank" rel="noopener">npm config 配置</a></li>
<li><a href="https://semver.npmjs.com/" target="_blank" rel="noopener">npm semver 计算器</a></li>
<li><a href="https://docs.npmjs.com/cli/install" target="_blank" rel="noopener">node_modules 目录扁平化</a></li>
</ul>
</li>
<li>yarn 中文文档，虽然是 npm 竞争者但兼容 package.json 和 node_modules 目录，因此这两部分可以作参考<ul>
<li><a href="https://yarnpkg.com/zh-Hans/docs/package-json" target="_blank" rel="noopener">package.json - 中文</a></li>
<li><a href="https://yarnpkg.com/zh-Hans/docs/dependencies" target="_blank" rel="noopener">依赖与版本 - 中文</a></li>
</ul>
</li>
</ul>
<p>延伸阅读</p>
<ul>
<li>sam boyer 《所以你想开发一个包管理系统》，从五官特定语言的角度，介绍一个包管理系统的方方面面：<a href="https://bit.ly/2G36U1e" target="_blank" rel="noopener">So you want to write a package manager</a></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Tool" >
    <span class="tag-code">Tool</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/02/02/tech/tool/frequently-git-command/">
        <span class="nav-arrow">← </span>
        
          常用 Git 命令
        
      </a>
    
    
      <a class="nav-right" href="/2020/02/05/tech/typeScript/ts-init/">
        
          初识 TypeScript
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-npm-init"><span class="toc-nav-text">1. npm init</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-npm-init-执行默认行为"><span class="toc-nav-text">1.1 npm init 执行默认行为</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-自定义-npm-init-行为"><span class="toc-nav-text">1.2 自定义 npm init 行为</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-依赖包安装"><span class="toc-nav-text">2. 依赖包安装</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-package-定义"><span class="toc-nav-text">2.1 package 定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-安装本地包-远程-git-仓库包"><span class="toc-nav-text">2.2 安装本地包&#x2F;远程 git 仓库包</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-npm-install-如何工作-–-node-modules-目录结构"><span class="toc-nav-text">3. npm install 如何工作 – node_modules 目录结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-npm2"><span class="toc-nav-text">3.1 npm2</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-npm3-扁平结构"><span class="toc-nav-text">3.2 npm3-扁平结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-npm5-package-lock-文件"><span class="toc-nav-text">3.3 npm5-package-lock 文件</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-依赖包版本管理"><span class="toc-nav-text">4. 依赖包版本管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-semver"><span class="toc-nav-text">4.1 semver</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-依赖版本升级"><span class="toc-nav-text">4.2 依赖版本升级</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-最佳实践"><span class="toc-nav-text">4.3 最佳实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-npm-scripts"><span class="toc-nav-text">5. npm scripts</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-基本使用"><span class="toc-nav-text">5.1 基本使用</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-node-modules-bin-目录"><span class="toc-nav-text">5.2 node_modules&#x2F;.bin 目录</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-3-npx"><span class="toc-nav-text">5.3 npx</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-npm-配置"><span class="toc-nav-text">6. npm 配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-npm-config"><span class="toc-nav-text">6.1 npm config</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-npmrc-文件"><span class="toc-nav-text">6.2 npmrc 文件</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-3-node-版本约束"><span class="toc-nav-text">6.3 node 版本约束</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-小结-npm-最佳实践"><span class="toc-nav-text">7. 小结 npm 最佳实践</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-更多资料"><span class="toc-nav-text">8. 更多资料</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2020/02/04/tech/tool/npm-all-about/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>