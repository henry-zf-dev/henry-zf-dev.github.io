<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ElementUI 树形组件懒加载</title>
      <link href="/2020/05/16/tech/vue/vue-element-tree-lazy-load/"/>
      <url>/2020/05/16/tech/vue/vue-element-tree-lazy-load/</url>
      
        <content type="html"><![CDATA[<p>总结一下在使用ElementUI <el-tree> 组件实现节点懒加载时遇到的问题和解决方法</el-tree></p><p>最终大致效果截图：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E6%95%B4%E4%BD%93%E6%95%88%E6%9E%9C%E9%A1%B5%E9%9D%A2.png" alt="整体效果页面"></p><p>页面涉及到的页面展示和用户操作有：树形组件的节点<code>懒加载渲染</code>，在某个节点下<code>新增子层</code>、<code>新增房间</code>、<code>设置管理员</code>、<code>重命名</code>、<code>删除节点</code>，解析 URL 中的当前选中的节点 id，使<code>&lt;el-tree/&gt;</code>组件自动展开到该节点。</p><h5 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h5><p>之前由于总总原因，区域树实现的程度是：后台返回所有区域的平层数据结构，数组元素间通过<code>pid</code>进行关联，前台拿到所有区域数据后，根据<code>pid</code>组装成<code>&lt;el-tree/&gt;</code>组件需要的节点递归结构，所以前台组好数据后以<code>:data=&quot;srcData&quot;</code>传入即可。当用户对节点进行增删改操作后，前台会重新请求新的数据，再将以上处理重新进行一遍，从而刷新整个区域树。</p><h5 id="现有需求"><a href="#现有需求" class="headerlink" title="现有需求"></a>现有需求</h5><p>后台不再将所有的区域一次性返回给前台，而是用户在展开节点后，再以点击的节点的 <code>id</code> 作为父节点 <code>pid</code>，请求其子层中第一层的区域数据，然后前台将请求到的数据载入到该节点。并且对区域的增删改操作成功后，不再是重新请求所有的数据，而是根据 <code>id</code> 更新指定的某个节点。</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li>懒加载</li></ul><p><code>&lt;el-tree&gt;</code> 组件其实本身就支持懒加载，用法也很简单：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/el-tree%E6%87%92%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%B3%951.png" alt="el-tree懒加载用法1"></p><p>初始化组件时，设置<code>:lazy=&quot;true&quot;</code>，并自定义<code>load</code>方法即可<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/el-tree%E6%87%92%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%B3%952.png" alt="el-tree懒加载用法2"></p><hr><ul><li><p>对节点的增删改</p><ul><li><p>节点新增：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E1.png" alt="节点新增1"><br>在新增子层接返回成功后，将返回的 <code>resp.data</code> 通过<code>&lt;el-tree/&gt;</code>组件自带的<code>append</code>方法，将新数据追加在当前节点中<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E2.png" alt="节点新增2"></p></li><li><p>与新增同理，节点删除：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A41.png" alt="节点删除1"><br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A42.png" alt="节点删除2"></p></li><li><p>节点更改：<br>在<code>&lt;el-tree/&gt;</code>组件的<code>node-click</code>事件回调中，前两个参数会返回该节点的数据源以及该节点对象本身：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E6%9B%B4%E6%94%B91.png" alt="节点更改1"><br>其中对该节点的<code>Node()</code>对象的<code>data</code>进行操作，则页面会根据最新的数据源进行重新渲染（<strong>注：直接对 <code>nodeData</code>进行更改，不会触发页面的重新渲染</strong>）<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E6%9B%B4%E6%94%B92.png" alt="节点更改2"><br>所以当节点更改接口返回成功后，用返回的新数据更新<code>node.data</code>即可实现页面的动态刷新<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E8%8A%82%E7%82%B9%E6%9B%B4%E6%94%B93.png" alt="节点更改3"></p></li></ul></li></ul><hr><ul><li>自动展开到指定的节点</li></ul><p>首先从 URL 中取当前需要展开节点的全路径信息，用它更新<code>&lt;el-tree/&gt;</code>组件的<code>default-expanded-keys</code>属性，这样区域树就会展开至指定的节点<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E5%B1%95%E5%BC%80%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B91.png" alt="展开指定节点1"><br><strong>此处需要设置全路径的原因是：在懒加载模式下<code>&lt;el-tree/&gt;</code>组件的<code>auto-expand-parent</code>是无效的</strong></p><p>还存在一个问题是，我们不仅要展开需要默认展开的节点，还要给当前正在操作的节点赋值，即全路径中最后一个<code>id</code>所对应的节点。<code>&lt;el-tree/&gt;</code>组件提供了<code>setCurrentKey</code>方法，即根据传入的<code>key</code>,将该<code>key</code>所对应的节点设置为选中状态，我们刚好可以利用这个方法。但由于每一节点的数据是异步请求而来的，所以如果将该方法的调用放在上图的方法中，可能会造成节点数据还没加载好，就给组件设置了当前选中的节点，导致设置不成功<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E5%B1%95%E5%BC%80%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B92.png" alt="展开指定节点2"></p><p>解决这个问题的办法是，将<code>setCurrentKey</code>的调用放在自定义<code>load</code>方法的成功回调中：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/%E5%B1%95%E5%BC%80%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B93.png" alt="展开指定节点3"><br>这样就可以保证节点数据已经加载完成了，再去设置当前选中的节点</p><hr><ul><li>补充：<code>&lt;el-tree/&gt;</code>组件的全选/半选问题</li></ul><p>在角色管理中，给某个角色设置其拥有的权限项，使用到了<code>&lt;el-tree/&gt;</code>组件的选择功能：<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/el-tree%E5%85%A8%E9%80%89%E5%8D%8A%E9%80%891.png" alt="el-tree全选办选1"><br>但是遇到一个问题：当前台把已选的权限项提交给后台保存成功后，需要在查询该角色的权限项时，将权限项设置给<code>&lt;el-tree/&gt;</code>组件进行显示，但是前台是需要将所有选择的节点(不管是全选还是办选)的 id 都提交到后台，所以前台拿到的新数据也是全量的，而且无法区分是全选还是半选。这样会造成，只要提交时父节点被选择（不论全选/半选），在给组件设置选中值时，它的子节点会全被选中</p><p>解决办法是：</p><p>在组件<code>mounted</code>后，手动设置<code>&lt;el-tree/&gt;</code>组件的选中值，首先遍历<code>selectData</code>，通过<code>getNode</code>方法拿到所有需要选中的节点对象，然后判断其是否为叶子节点，如果是，则使用<code>setChecked</code>方法将其状态设置为选中；而非叶子节点会自动根据其所有叶子节点的选中状态，决定其本身的全选或半选状态<br><img src="/2020/05/16/tech/vue/vue-element-tree-lazy-load/el-tree%E5%85%A8%E9%80%89%E5%8D%8A%E9%80%892.png" alt="el-tree全选办选2"></p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以上就是区域树组件改造过程中遇到的问题，以及一些解决思路。ElementUI作为最受欢迎的Vue组件库，它在提供丰富的既有功能的同时，也提供了很多可以灵活运用的API。本身自己能力有限，不能说别人造的轮子无法很好的满足自己的需求，就去想着改别人的源码，我们在自定义组件时，可以多进行尝试，在现有的基础上寻找最佳的方案来满足需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网本质的一点讨论</title>
      <link href="/2020/03/06/thinking/20200306/"/>
      <url>/2020/03/06/thinking/20200306/</url>
      
        <content type="html"><![CDATA[<p>今天 Jerry 请我吃麦当劳，顺便陪他去充电桩充电，路上一起讨论了互联网本质的一些东西，感觉 Jerry 总结的很有道理，我准备记录一下，希望以后自己也能对一些事物做出自己的判断</p><p><strong>互联网本质讨论的三个结论</strong></p><ul><li><p>客户：相对不是很富裕的人群</p></li><li><p>服务：让相对高质量的服务廉价化</p></li><li><p>成本：用空间成本换时间成本</p></li></ul><p><strong>例子：互联网健身房和传统健身房的区别</strong></p><p>传统健身房盈利主要靠的是前期会员加入的会员卡费，以及会员购买私教授课的费用，其中会员卡费一般是一次性付完，私教课则按照课时收费。而且相对私教课程，会员费要低很多，市面上普通健身房一年的会员卡费大概在1500-3000之间，而一节私教费就在300~700之间（和城市/地段有关）。而为什么私教课很贵，先不看私教老师本身的专业性、口碑等价值，有一个本质原因是：私教授课过程中，他的时间只能被一个或者少量的人所占用，其时间成本是很高的。而同时教授的人越多，每个人所分担的费用也会相对更少。</p><p>另一方面，传统健身房的私教的主要收入也依赖于他所在健身房的客源，所以其价值在一定程度上是被限制的。而诸如超级猩猩这类互联网健身房，由互联网提供的平台，让更多的人不需要办健身房的会员卡，就能有机会接触到更多的优秀私教。相对的，私教也不会受限于他所在健身房的固定圈子，能有更多的机会授课。同时报名私教课的人所要分担的费用也会被平均下来，变得更低，而且也不用办长周期的会员卡绑定消费，所有他们要承担的风险变小，使得更多的人接受这种模式。</p><p>互联网让原本相对高质量的私教健身服务，变得廉价，让原本没有太好经济基础的人也能享受到，即使这种模式下的健身私教服务相对于传统的一对一服务，会打折扣，但对于很多人来讲，这已经满足他们的需求了。而对于经济基础很好的人，比如一些明星，肯定就不会接受这种模式，他们追求的就是更专业，更高质量，长期且稳定的服务，对成本的顾虑不在他们考量的第一位。</p><p><strong>最后希望自己慢慢变成一个有思想的人，哈哈</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春节随想</title>
      <link href="/2020/03/06/thinking/20200125/"/>
      <url>/2020/03/06/thinking/20200125/</url>
      
        <content type="html"><![CDATA[<p>今年因为武汉肺炎的原因，没有回家过年，又一次错失了和家人吃团圆饭的机会，但是有失也有得，我把春节期间自己的所见所想记录在这里，这些都是自己的收获。</p><h3 id="峰哥家的团圆饭"><a href="#峰哥家的团圆饭" class="headerlink" title="峰哥家的团圆饭"></a>峰哥家的团圆饭</h3><p>算来这是第二次在峰哥家吃年饭，因为都是湖北人，饭菜都很合胃口。饭桌上峰哥和我讲了很多比较抽象的东西，还是向来的风格，哈哈。<br>一些道理我可以理解，但一些更深的东西，现阶段的我还无法真正有所体会，阅历不够，思想高度也达不到，也许可以通过多看书来慢慢补上吧。<br>总之，希望自己在技-&gt;术-&gt;通-&gt;道的路上越走越好吧。</p><h3 id="和Jerry在公园漫步"><a href="#和Jerry在公园漫步" class="headerlink" title="和Jerry在公园漫步"></a>和Jerry在公园漫步</h3><p>今天看望了Kim姐和’小朱朱’，小宝贝睡相很可爱，哈哈。吃完午饭就和Jerry还有Jerry老爸老妈在附近的公园转了好大一圈。一路上主要和Jerry聊了不少，以下是对聊天内容的记录和总结。</p><ul><li><p><strong>城市规划和软件产品开发的联系</strong><br>不管是哪个城市，在建设发展中，不可避免地会经历规划、建设、改造、重建等过程，深圳这座发达又年轻的城市也不例外。就拿离我很近的大沙河水质治理为例，深圳到处都能看到对老旧楼宇、基础公共设施的翻新或者重建，城市管理者对城市规划的理解会随着时代变迁而变化，也许这个变迁只需要短短几年。而软件产品的开发也是一样，在最开始，没有人能够完全规划好所有的东西，只能在当前有限的时间、成本、开发人员能力的前提下，做到最好。而随着迭代的进行，客户需求的累计或变更，一定会暴露越来越多的问题，代码的维护性、扩展性、复用性、性能、安全等等，就像房子翻新和重建，我们也需要对代码做优化甚至重构。而这也一样需要考虑当前情况下的时间、成本以及开发人员能力，产品迭代本身就是个动态的过程，把握住一种动态平衡可能就是管理的一部分吧。</p></li><li><p><strong>对产品开发和客户需求悖论的思考</strong><br>首先闭门造车地开发产品肯定是无法经受时间和实践考验的，这个毋庸置疑。我们需要客户在需求输入端的不断input，但是在产品前期，往往客户并没有想清楚要什么，真正的痛点描述不够准确，而且客户需求转化成产品需求，再到技术需求，到最终实现，这个流程中，最后能产生什么程度的output，往往会和预期存在偏差。我想这个偏差也是一个管理者需要时刻关注的，对偏差进行分析，找到产生的原因，并且有优先级地进行调整，通过不断地迭代，产品才能逐渐迎合越来越多客户的需求，解决客户的问题。</p></li><li><p><strong>对ezCloud产品定位的理解</strong><br>我的理解是，产品内在价值，是通过软件服务，解决客户在会议室场景下会议室的控、管、维、用相关的问题，降低客户成本。然后基于内在价值，促进公司自研设备和代理设备的推广和销售。然而对于第二点，我以前的理解是，有了ezCloud软件上的支持，肯定会提高公司硬件产品的销售，但是就目前而言，其实ezCloud只是一个加分项而已，而且在整套解决方案中占比很少，是充分不必要条件。ezCloud在项目中的迭代打磨会让它越来越能符合更多客户的需求，但是这个本身不会直接增加硬件的销售。该如何破题，就需要设备库、分控、总控和其他自研硬件，在自检、联检、告警核心业务方向上，相互配合，一步步完善，能真正解决客户问题了。我们现在只能适配别人的设备，等客户多起来，通过我们和客户的推动，带动其他代理厂商对我们进行适配，这样ezCloud的影响力才能逐渐提升，价值也会逐渐体现。现阶段，ezCloud产品还在很初期的阶段，设备库、分控、总控也还有很多不足，我们自研硬件也还只是处在OEM的阶段，总之真的还任重道远。</p></li><li><p><strong>鲶鱼效应</strong><br>鲶鱼效应是指鲶鱼在搅动小鱼生存环境的同时，也激活了小鱼的求生能力。鲶鱼效应是采取一种手段或措施，刺激一些企业活跃起来投入到市场中积极参与竞争，从而激活市场中的同行业企业。而在一个团队中，通过小数主动的人行动上的正向刺激，潜移默化地带动其他相对被动的人，不管是对个人还是对团队，都能向着更好的方向发展。但是我存在一个疑问，对于相对被动的员工来说，那些积极主动员工的作为或者存在，是不是本身就是一种威胁或者说利益冲突，毕竟鲶鱼对于其他小鱼来说是捕食者和被捕食者的关系。我自己工作经历有限，还没遇到过这种情况，但如果一个团队真的出现这种情况，那肯定是有问题的。<br>然后如果我是那条鲶鱼，该怎么做好呢？怎么能在他人不抵触的前提下，正向地影响更多的人呢？如何提升思维的柔度，是需要自己慢慢思考的东西。</p></li></ul><h3 id="饭桌上的畅谈"><a href="#饭桌上的畅谈" class="headerlink" title="饭桌上的畅谈"></a>饭桌上的畅谈</h3><p>中午很有幸和Jerry和Jerry老爸老妈一起吃饭。Jerry老爸是个很健谈的人，既有北方人的豪爽，又有南方人的细致，给人第一印象是，一位知识渊博而又畅谈的老先生。Jerry妈妈给人印象就是知性，稳重，又平易近人，给人一种安全感，虽然言语不多，但让人觉得很亲切。Jerry的老爸老妈都很厉害，令人敬佩，不知道Jerry有这么优秀的爸妈，会不会觉得压力很大，哈哈。和Jerry老爸的聊天过程中，我觉得有两点我需要在这里记录一下，一个是如果有能力，帮人要帮到点上，小恩小惠没有什么用，雪中送炭才有意义。我想到的是，以我现在的能力，能够帮助他人帮到点上吗，然后长久以来，有哪些人为我雪中送过炭呢，需要我记住心里。第二点就是，人是很复杂的，看人需要看多面，而且要看多次，我觉得很有道理。</p><h3 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h3><p>在回家的路上，我想了一个很简单就能问出来的问题：Jerry为什么要和我说这么多东西呢？我给自己的答案：希望我能有所回应，不管是技术上还是管理上（我觉得Jerry更关心的是我在管理方向的能力发展）。但我现在回应的还不够好，这段时间自己渐渐笃定的职业发展规划，在这个阶段是否是最优的选择？或者说，我该在技术和管理两方面找到平衡？然后Jerry对Cuzz问的三个问题：想要什么？想成为什么？如何达到？我想也是问给我的。这些也都是要自己琢磨的问题……</p><hr><p>从小生活武汉，但一直以来对武汉印象都不太好，虽然家就在那，却总觉得对武汉没什么感情，这也许是我一直学不会武汉话的原因吧。今天听到Jerry老爸一口地道的武汉话，我的第一感觉却是无比的亲切和怀念。人真是种复杂的生物。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 核心 API 学习笔记</title>
      <link href="/2020/03/05/tech/vue/vue-core-api/"/>
      <url>/2020/03/05/tech/vue/vue-core-api/</url>
      
        <content type="html"><![CDATA[<p>Demo 地址：<a href="https://github.com/henry-zf-dev/vue-webpack-ssr" target="_blank" rel="noopener">Vue 进阶学习</a></p><h4 id="1-Vue-实例"><a href="#1-Vue-实例" class="headerlink" title="1. Vue 实例"></a>1. Vue 实例</h4><p>实例：对某个类，通过 new ClassA() 初始化而来的对象，叫做实例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer" target="_blank" rel="noopener">对象初始化参考</a></p><p><a href="https://www.cnblogs.com/shirliey/p/11696412.html" target="_blank" rel="noopener">初始化对象的几种方式</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  template: <span class="string">'&lt;div&gt;This is content&lt;/div&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 new Vue(<code>options</code>) 初始化的 Vue 实例，最终会通过 <code>render function</code> 将 template 的内容挂载到 <code>#root</code> 根节点上，在页面中展示，而且挂载的方式是使用 template render 生成的新节点，替换掉 指定的 <code>#root</code> 节点，正式这个原因，如果在 template 中存在多个根节点，Vue 会报一个警告：</p><p>注：如果 options 传入了 template，则将 template 编译到 render 函数中去，否则会将 el 外部的 html 作为 template 进行编译</p><blockquote><p>[Vue warn]: Error compiling template:<br>Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.</p></blockquote><p>因为 Vue 不知道用哪个节点替换指定的根节点。</p><p>不仅仅可以通过 <code>options.el</code> 指定要挂载的根节点，还可以手动进行挂载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.$mount(<span class="string">'#root'</span>);</span><br></pre></td></tr></table></figure><p>在 webpack 配置中，通过插件，可以指定以某个文件为模板，生成最终的 html 页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HTMLPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname, <span class="string">'index.html'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>初始化 Vue 传入的 <code>options</code> 会与默认的初始化参数结合起来，最终产生 Vue 实例，而且 <code>options</code> 中的属性可以通过 <code>app.$[attr]</code> 访问，如：</p><p><code>app.$el</code>、<code>app.$root</code>、<code>app.$options</code>、<code>app.$data</code>、<code>app.$props</code>、<code>app.$children</code>、<code>app.$refs</code>、<code>app.$slots</code> 等等</p><ul><li><p><code>app.$el</code> 是对最终挂载生成 html 节点的引用</p></li><li><p><code>app.$root</code> 是整个 Vue 树状结构的根节点，也是 Vue 实例，是对 app 的引用，即：<code>app.$root === app</code></p></li><li><p><code>app.$options</code> 是初始化 Vue 实例所有的参数，$options 中也可以看到诸如 <code>data</code>、<code>props</code>、<code>watch</code> 等属性，但不是对 <code>app.$[attr]</code> 的引用，所以如果更改 <code>app.$options.data</code> 的值，页面是不会响应式变化的，直接更改 <code>app.$data</code> 才有效</p></li><li><p><code>app.$data</code></p><p>定义在 data 对象中的属性，Vue 会复制一份引用到 app 层，即 <code>app.[attr]</code> 和 <code>app.$data[attr]</code> 访问到的是同一份地址，</p><p>定义在打 data 中的全局属性，如果不对属性进行字面量声明，则在 Vue 初始化完成之后，给 data 对象增加属性，或修改属性值，Vue 不会对这个对象做响应式处理，所以即使该对象的属性值变化了，也不会响应式地重新渲染</p><p>但可以通过 $set 方法给在初始化完成之后再给 data 增加或修改属性，而且也是响应式的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.$<span class="keyword">set</span>(app.obj, 'a', 'foo');</span><br></pre></td></tr></table></figure><p>另外，也删除某个属性，同时会解除对该属性的响应式处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.$<span class="keyword">delete</span>(app.obj, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p><em>强制组件重新渲染一次，也可以在没有字面量定义 data 属性时，页面重新渲染（尽量不使用这个方法）</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.$forceUpdate();</span><br></pre></td></tr></table></figure></li><li><p><code>app.$refs</code> 用于快速定位到模板的某个 html 节点，或某个组件实例</p></li><li><p><code>app.$isServer</code> 用于服务端渲染判断</p></li><li><p><code>app.$watch</code> </p><p>一下写法和在 options 中定义 watch 都可以监听到 foo 的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unWatch = app.$watch(<span class="string">'foo'</span>, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'newVal: '</span>, newVal);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oldVal: '</span>, oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>区别在于，通过 app.$watch 定义，需要手动进行销毁（比如路由跳转后），该方法回调一个 unWatch 方法，用于手动回收：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unWatch();</span><br></pre></td></tr></table></figure><p>而定义在 options 中，Vue 会自动回收销毁</p></li><li><p><code>app.$on</code> <code>app.$emit</code>  <code>app.$once</code></p><p><code>app.$on</code> 和 <code>app.$emit</code> 都只能同时作用于一个 Vue 对象，才会生效，Vue 对象 app 监听了 test 事件，那么必须由对象 app 自己触发事件 test，才会被监听到，而且不会像 dom 事件一样冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.$on(<span class="string">'test'</span>, (a, b) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'$on test emitted: '</span>, a, b);</span><br><span class="line">&#125;);</span><br><span class="line">app.$emit(<span class="string">'test'</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>app.$once 只会触发一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   app.$once(<span class="string">'test'</span>, (a, b) =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'$once test emitted'</span>, a, b);</span><br><span class="line">   &#125;)</span><br><span class="line"> <span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">#### 2. Vue 的生命周期方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![vue-lifecycle](vue-core-api/lifecycle.png)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* `</span>beforeCreate<span class="string">` 和 `</span>created<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> beforeCreate、created 方法在 new Vue(`</span>options<span class="string">`) 的过程中一定会被执行，而且 beforeCreate、created 两个生命周期中都不能进行 dom 操作，因为这时 Vue 还没有生成最终的根节点，一般操作 dom 相关的动作，要放在 mounted 中。操作数据相关的动作一般放在 created 中，但不要放在 beforeCreate 中，因为 beforeCreate 还没有进行数据的 reactive 响应式相关的初始化</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">* `</span>beforeMount<span class="string">` 和 `</span>mounted<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> mounted 之后会把当前 Vue 生成的 html 挂载到 dom 上，即：把生成的 html 把 `</span>&lt;div id=<span class="string">"root"</span>&gt;&lt;<span class="regexp">/div&gt;` 替换掉。如果在 options 中不指定 el，则不会执行 beforeMount、mounted。在 mounted 之后，所有生命周期中拿到的根节点，都是 mounted 之后产生的节点</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">beforeCreate、created、beforeMount、mounted 在整个组件生命周期中只会被调用一次，而且 beforeMount、mounted 在服务端渲染中不会被调用，因为这两个生命周期都和操作 dom 有关</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">* `beforeUpdate` 和 `updated`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> 只要响应式处理过的数据有变化，页面就会响应重新渲染，这两个方法也都会被重复调用</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">* `activated` 和 `deactivated`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> 与组件的 keep-alive 相关</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">* `beforeDestroy` 和 `destroyed`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> beforeDestroy 中会解除所有事件监听以及所有的 watch 监听</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">* `render`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render 方法第一次将在 beforeMount 和 mounted 之间执行，之后都将在 beforeUpdate 和 updated 之间执行</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">* `renderError`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> 只有在开发环境才会触发，并且只能用于当前组件，它的子组件的错误无法捕获到</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">* `errorCaptured`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> 不管是开发环境还是正式环境，只要捕获到当前组件，或者它的子组件渲染发生错误时，都会触发，除非子组件阻止了事件冒泡</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">#### 3. Vue 的数据绑定</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">```javascript</span></span><br><span class="line"><span class="regexp">import Vue from 'vue';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var globalVar = '111'; /</span><span class="regexp">/ eslint-disable-line</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#root',</span></span><br><span class="line"><span class="regexp">  template: `</span></span><br><span class="line"><span class="regexp">    &lt;div :id="id" :class="activeClass" @click="handleClick"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div :class="&#123;active: isActive&#125;"&gt;</span></span><br><span class="line"><span class="regexp">        模板中只能做用一行语句就能有结果的表达式</span></span><br><span class="line"><span class="regexp">        &#123;&#123;isActive ? "active" : "not active"&#125;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123;active: isActive&#125;, inactiveClass]"</span>&gt;</span><br><span class="line">        模板中可以访问 Vue 默认的全局变量白名单，但自己定义的全局变量不能访问（如 globalVar）</span><br><span class="line">        &#123;&#123;<span class="built_in">Date</span>.now()&#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div :style="[activeStyle, inactiveStyle]"&gt;</span></span><br><span class="line"><span class="regexp">        对 data 中定义的 HTML，Vue 会自动进行转移成纯的字符串，为了防止注入攻击</span></span><br><span class="line"><span class="regexp">        要以 v-html 方式使用</span></span><br><span class="line"><span class="regexp">        &lt;div v-html="html"&gt;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;getJoinedArr(arr)&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  `,</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    id: 'aaa',</span></span><br><span class="line"><span class="regexp">    activeClass: 'active',</span></span><br><span class="line"><span class="regexp">    inactiveClass: 'inactive',</span></span><br><span class="line"><span class="regexp">    activeStyle: &#123;</span></span><br><span class="line"><span class="regexp">      color: 'red',</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ Vue 会给需要加前缀的样式属性名自动加上前缀</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 该属性用于消除浏览默认样式</span></span><br><span class="line"><span class="regexp">      appearance: 'none'</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    inactiveStyle: &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ html 中所写样式的 '-' 分隔符格式转化成驼峰格式</span></span><br><span class="line"><span class="regexp">      fontSize: '15px'</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    isActive: true,</span></span><br><span class="line"><span class="regexp">    arr: [1, 2, 3],</span></span><br><span class="line"><span class="regexp">    html: '&lt;span&gt;123&lt;/</span>span&gt;<span class="string">'</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    handleClick () &#123;</span></span><br><span class="line">      console.log('##### handleClick #####');</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 建议这种情况使用 computed，</span></span><br><span class="line">    <span class="comment">// 因为 computed 会先判断数据源是否有变化，再来渲染页面，效率会更高</span></span><br><span class="line">    getJoinedArr (arr = []) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.join(<span class="string">'、'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-computed-和-watch"><a href="#4-computed-和-watch" class="headerlink" title="4. computed 和 watch"></a>4. computed 和 watch</h4><ul><li><p><strong>computed:</strong></p><p>定义在 <code>computed</code> 中的方法，可以像访问变量的属性一样去调用，这是因为 Vue 会对 fullName 声明 <code>get</code> 和 <code>set</code> 方法，并且会对计算的结果做缓存，只有当 <code>computed</code> 中所依赖的响应式变量（即：firstName 或 lastName）发生变化，才会重新计算。而如果是在 <code>methods</code> 中做同样的逻辑计算，那么只要 <code>data</code> 或者 <code>props</code> 中任何一个属性有变化，都会重新渲染页面，从而重新调用 <code>methods</code> 中的方法。所有定义在 <code>computed</code> 中性能消耗会更小，特别是计算的逻辑很复杂的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computed = &#123;</span><br><span class="line">   fullName () &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>也可以通过显示地定义 <code>get</code> 和 <code>set</code> 方法来定义 <code>computed</code></p><p><code>get:</code> 获取 fullName 的值时会做哪些计算<br><code>set:</code> 给 fullName 赋值时会做哪些计算。不建议使用 set，因为将多个值通过计算组装成一个值很简单，但把一个值拆解成多个值是很麻烦的，而且很容易出问题，造成死循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computed = &#123;</span><br><span class="line">   fullName: &#123;</span><br><span class="line">     <span class="keyword">get</span> () &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">set</span> (val) &#123;</span><br><span class="line">       <span class="keyword">const</span> names = val.split(<span class="string">' '</span>);</span><br><span class="line">       <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>watch:</strong></p><p><code>watch</code> 中可以对 <code>data</code> <code>props</code> <code>computed</code> 中的响应式变量进行监听，只要其发生变化，就执行一些逻辑处理</p><p>只有当 data.age 发生变化才会执行 age 方法中的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watch = &#123;</span><br><span class="line">   age (newVal, oldVal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.notYoung = newVal &gt;= <span class="number">30</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>也可以通过以下方式定义 <code>watch</code>：</p><p><code>immediate</code>：表示是否立即执行</p><p>作用：如果 age 的初始值本身已经大于 30，那么按照上面👆的形式定义 <code>watch</code>，第一次 handler 方法是不会执行的，只有当 age 再次发生变化才会执行，而 <code>immediate</code> 就是用来解决这个问题的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watch = &#123;</span><br><span class="line">   age: &#123;</span><br><span class="line">     handler (newVal, oldVal) &#123;</span><br><span class="line">       <span class="keyword">this</span>.notYoung = newVal &gt;= <span class="number">30</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     immediate: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>deep</code>：深度观察</p><p>作用：如果 other 是一个对象，那么只是修改 other 中属性的值，而不是直接给 other 重新赋值，那么按照上面👆的形式定义 <code>watch</code>，handle 方法也是不会执行的。但如果设置 <code>deep: true</code>，那么 other 不管哪个属性变化，handle 方法都会执行</p><p>原理：Vue 会逐层遍历 other 所有的属性，并为每个属性增加一个响应式监听，所有只要 other 任何层级的任何属性发生变化，都会执行 handle 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watch = &#123;</span><br><span class="line">   other: &#123;</span><br><span class="line">     handler (newVal, oldVal) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'other changed'</span>);</span><br><span class="line">     &#125;,</span><br><span class="line">     deep: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这种写法对性能开销较大，建议使用以下👇写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watch = &#123;</span><br><span class="line">   <span class="string">'other.hobby'</span> () &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'other.hobby changed'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-Vue-的原生指令"><a href="#5-Vue-的原生指令" class="headerlink" title="5. Vue 的原生指令"></a>5. Vue 的原生指令</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-text="text"&gt;aaa&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="html"&gt;aaa&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;类似于 dom 的 innerText 和 innerHtml&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-pre&gt;将内容当做纯文本显示: &#123;&#123;text&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-once="text"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;数据绑定的内容只执行一次，之后数据变化后也不会随之变化，&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;用处：展示静态内容时，通过声明 v-once 减少性能开销，&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;v-once 中的所有节点，Vue 都不会将其和虚拟 dom 进行检测对比，从而减少重新渲染的开销。&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-show="active"&gt;根据 show 的值，给 div 增加 display 的样式&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if="active"&gt;根据 show 的值，决定是否把 div 添加到 dom 流中&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-else&gt;else content&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;如果只是单纯想控制元素的显示和隐藏，那么最好使用 v-show，&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;因为 v-if 会对 dom 节点进行增删操作，导致重绘和重新排版，有性能的影响。&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;v-for 中的 key 是用来做数据缓存的，需要保证唯一，&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;当数据源发生变化时，Vue 会根据每个 item 的 key 在缓存中寻找，是否已经存在 key，&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;如果已经存在，则直接在缓存中复用 item 的 dom 节点，而不重新创建新的 dom 节点，提高渲染性能。&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;注：不要用 idx 作为 key，因为数组元素的顺序和具体值没有什么直接关系，&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;用 idx 作为 key，在数据源发生增、删之后，可能会导致产生错误的缓存。&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li v-for="(item, idx) in arr" :key="item"&gt;index: &#123;&#123;idx&#125;&#125;, value: &#123;&#123;item&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li v-for="(val, key, idx) in obj"&gt;key: &#123;&#123;key&#125;&#125;, value: &#123;&#123;val&#125;&#125;, index: &#123;&#123;idx&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-on:click="divClicked"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;v-on 做的事情是：&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;如果 v-on 加在普通的 dom 节点元素上，则会通过 document.addEventListener 给该节点增加事件监听&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;如果 v-on 加在 Vue 组件上，实际上是在 Vue 对象实例上绑定一个事件&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model="text"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model.number="number"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model.trim="text"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model.lazy="text"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="checkbox" v-model="active"&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;每个 checkbox 所绑定的值是固定的，checkbox 的 active/inactive 变化后:&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;active -&gt; inactive: 数据移除值为当前 checkbox 所绑定值的元素&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;inactive -&gt; active: 数据 push 一个值为当前 checkbox 所绑定值的元素&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="checkbox" value="a" v-model="arr"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="checkbox" value="b" v-model="arr"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="checkbox" value="c" v-model="arr"&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="radio" value="one" v-model="picked"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="radio" value="two" v-model="picked"&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: <span class="string">'text'</span>,</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    html: <span class="string">'&lt;span&gt;html&lt;/span&gt;'</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    arr: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    obj: &#123;</span><br><span class="line">      a: <span class="string">'a'</span>,</span><br><span class="line">      b: <span class="string">'b'</span>,</span><br><span class="line">      c: <span class="string">'c'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    picked: <span class="string">'one'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    text () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'##### text changed #####'</span>, <span class="keyword">this</span>.text);</span><br><span class="line">    &#125;,</span><br><span class="line">    arr () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'##### arr changed #####'</span>, <span class="keyword">this</span>.arr);</span><br><span class="line">    &#125;,</span><br><span class="line">    picked () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'##### arr picked #####'</span>, <span class="keyword">this</span>.picked);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    divClicked () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'##### divClicked #####'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-Vue-组件"><a href="#6-Vue-组件" class="headerlink" title="6. Vue 组件"></a>6. Vue 组件</h4><h5 id="6-1-组件的定义"><a href="#6-1-组件的定义" class="headerlink" title="6.1 组件的定义"></a>6.1 组件的定义</h5><ul><li>组件的全局注册和局部注册</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;This is a component&lt;/div&gt;`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册：</span></span><br><span class="line">Vue.component(<span class="string">'CompOne'</span>, component); <span class="comment">// 组件名称命名规则：大驼峰命名法（因为 component 本身也是一个 Vue 的 class）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部注册</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  component: &#123;<span class="attr">CompOne</span>: component&#125;,</span><br><span class="line">  template: <span class="string">`&lt;comp-one&gt;&lt;/comp-one&gt;`</span> <span class="comment">// 组件使用命名规则：全小写 '-' 分割</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>组件 <code>data</code> 定义：</p><p>不是通过 new Vue({<code>options</code>}) 创建的组件，<code>data</code> 必须以 function 形式返回，否则当一个父组件有多个相同类型的子组件时，所有的子组件都会引用同一份数据源，并且 Vue 会报警告：</p></li></ul><blockquote><p>[Vue warn]: The “data” option should be a function that returns a per-instance value in component definitions.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;This is a component&lt;/div&gt;`</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="string">'foo'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>组件 <code>props</code> 定义：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div @click="handleChange"&gt;This is a component&lt;/div&gt;`</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      active: &#123;</span><br><span class="line">        type: <span class="built_in">Boolean</span>, <span class="comment">// 类型</span></span><br><span class="line">        required: <span class="literal">true</span>, <span class="comment">// 是否必填</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">true</span>, <span class="comment">// 默认值</span></span><br><span class="line">        validator (val) &#123; <span class="comment">// 自定义校验</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'boolean'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      propOne: <span class="built_in">Number</span>, <span class="comment">// 属性命名规则：小驼峰命名法</span></span><br><span class="line">      <span class="comment">// 如果是对象，则必须以 function 形式返回一个对象</span></span><br><span class="line">      <span class="comment">// 原因和不是通过 new Vue() 创建的组件，data 必须以 function 形式返回一样</span></span><br><span class="line">      <span class="comment">// 即当两个相同类型的子组件的一个对象 props 引用了父组件的同一个值，那么就会相互影响</span></span><br><span class="line">      obj () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="keyword">default</span>: &#123;<span class="attr">a</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 也可以通过数组定义 props，但相对不严谨</span></span><br><span class="line">    <span class="comment">// props: ['active', 'propOne'],</span></span><br><span class="line">    <span class="comment">// mounted () &#123;</span></span><br><span class="line">    <span class="comment">//   this.propOne = 1;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleChange () &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p> Vue 不推荐在子组件中更改 <code>props</code> 的值，如果直接更改，会报警告：</p><blockquote><p>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “propOne”</p></blockquote><p> 如果要更改，可以通过子组件 <code>$emit</code> 事件，回调到父组件进行更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Comp: component</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      // 传递 props 时，使用全小写 '-' 分割</span></span><br><span class="line"><span class="string">      &lt;comp :active="true" :prop-one="propA" @change="handleChange"&gt;&lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    propA: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange () &#123;</span><br><span class="line">      <span class="keyword">this</span>.propA += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="6-2-组件的继承"><a href="#6-2-组件的继承" class="headerlink" title="6.2 组件的继承"></a>6.2 组件的继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="text"&gt;</span></span><br><span class="line"><span class="string">      &lt;span v-show="active"&gt;show if active&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;span @click="handleChange"&gt;&#123;&#123;propOne&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    active: <span class="built_in">Boolean</span>,</span><br><span class="line">    propOne: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### component mounted #####'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上 component 配置只是一个普通的 object，如何让配置生成 Vue 对象，除了通过 new Vue(<code>{component: {Comp: component}}</code>) 以外，还可以对 Vue 进行继承，生成 Vue 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CompVue = Vue.extend(component);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CompVue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  <span class="comment">// 通过 props 无法将外部属性传入</span></span><br><span class="line">  <span class="comment">// props: &#123;</span></span><br><span class="line">  <span class="comment">//   propOne: 'props 1'</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="comment">// 需要通过 propsData 传入</span></span><br><span class="line">  propsData: &#123;</span><br><span class="line">    propOne: <span class="string">'propsData 1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以传入 data 与 CompVue 默认的 data 合并覆盖</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期方法执行顺序：先执行 CompVue 默认配置中的生命周期方法，再执行 CompVue 实例中的生命周期方法</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### instance mounted #####'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CompVue 是 Vue 的一个子类，通过 new Vue(options) 初始化而来 Vue 对象，是默认内置配置下生成的，没有 data、props 等相关配置，通过 new CompVue() 生成的 Vue 对象会默认带有 data、props、methods 配置</p><p>也可以通过以下这种方式实现对 component 的继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component2 = &#123;</span><br><span class="line">  extends: component,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### instance mounted #####'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Comp: component2</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;comp prop-one="123"&gt;&lt;/comp&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：当我们开发好一个组件，可能比较公用，很多项目都会用到，而且功能描述比较泛，使用起来需要传入很多的配置项，而在某个具体项目中，很多参数都使用它的默认值，不需要传入，或者需要在原有基础上扩展一些特定的属性，这时候就可以通过 extend 的方式，在原有组件基础上，继承扩展出我们需要的组件，而不需要从头开始写一个新的组件</p><h5 id="6-3-组件自定义绑定"><a href="#6-3-组件自定义绑定" class="headerlink" title="6.3 组件自定义绑定"></a>6.3 组件自定义绑定</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 v-model 实现父子组件的双向绑定</span></span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" :value="value1" @input="handleInput"&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'value1'</span>, <span class="comment">// 指定双向绑定 prop 的 key</span></span><br><span class="line">    event: <span class="string">'change'</span> <span class="comment">// 指定回调时间的方法名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: [<span class="string">'value'</span>, <span class="string">'value1'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleInput (event) &#123;</span><br><span class="line">      <span class="comment">// this.$emit('input', event.target.value);</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, event.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Comp: component</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// template: `&lt;comp :value="value" @input="value = arguments[0]"&gt;&lt;/comp&gt;`,</span></span><br><span class="line">  template: <span class="string">`&lt;comp v-model="value"&gt;&lt;/comp&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">'123'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="6-4-组件高级属性"><a href="#6-4-组件高级属性" class="headerlink" title="6.4 组件高级属性"></a>6.4 组件高级属性</h5><ul><li><strong>slot 和 slot-scope</strong></li></ul><p>在子组件中可以通过指定不同插槽名，定义多个插槽：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="header"&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name="header"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="body"&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name="body"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="footer"&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name="footer"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      style: &#123;</span><br><span class="line">        width: <span class="string">'200px'</span>,</span><br><span class="line">        height: <span class="string">'200px'</span>,</span><br><span class="line">        border: <span class="string">'1px solid #aaa'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在父组件中根据插槽名传入不同的插槽：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#root'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      CompOne: component</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;comp-one&gt;</span></span><br><span class="line"><span class="string">          &lt;div slot="header"&gt;slot header&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div slot="body"&gt;slot body&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div slot="footer"&gt;slot footer&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/comp-one&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>带作用域的插槽：在子组件插槽中定义内部属性，父组件通过 <code>slot-scop</code> 可以访问到子组件的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">      &lt;slot :slotValue1="slotProp" :slotValue2="slotData"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    slotProp: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      style: &#123;</span><br><span class="line">        width: <span class="string">'200px'</span>,</span><br><span class="line">        height: <span class="string">'200px'</span>,</span><br><span class="line">        border: <span class="string">'1px solid #aaa'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      slotData: <span class="string">'abc'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过指定 “props” 作为 key，将插槽中的属性包装成 object，这样父组件就可以通过 props[key] 来访问插槽中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    CompOne: component</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;comp-one :slot-prop="value1"&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot-scope="props"&gt;</span></span><br><span class="line"><span class="string">          &lt;div&gt;slotValue1: &#123;&#123;props.slotValue1&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div&gt;slotValue2: &#123;&#123;props.slotValue2&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div&gt;selfValue: &#123;&#123;value2&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/comp-one&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value1: <span class="string">'def'</span>,</span><br><span class="line">      value2: <span class="string">'ijk'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>provide 和 inject</strong></li></ul><p>对于跨多级的组件中，父组件和子组件的参数传递，可以通过在父组件中定义 <code>provide</code>，子组件中定义 <code>inject</code> 来实现</p><p>孙组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GrandsonComponent = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;child component&lt;/div&gt;'</span>,</span><br><span class="line">  inject: [<span class="string">'const'</span>, <span class="string">'grandparent'</span>, <span class="string">'value'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### const #####'</span>, <span class="keyword">this</span>.const); <span class="comment">// xyz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### grandparent #####'</span>, <span class="keyword">this</span>.grandparent); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### value #####'</span>, <span class="keyword">this</span>.value); <span class="comment">// 在父组件中报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ChildComponent = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    GrandsonComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;grandson-component&gt;&lt;/grandson-component&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>父组件：</p><p>通过 <code>provide: {}</code> 的方式定义 <code>provide</code>，在子孙组件中是拿不到父组件的 <code>this</code> 的，只能接收到传入的常量，因为这样初始化 <code>provide</code> 对象，其实 Vue 本身还没有初始化完成，所有访问不了 <code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    <span class="keyword">const</span>: <span class="string">'xyz'</span>,</span><br><span class="line">    grandparent: <span class="keyword">this</span>,</span><br><span class="line">    value: <span class="keyword">this</span>.value <span class="comment">// 报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;child-component&gt;&lt;/child-component&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">'abc'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>孙组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GrandsonComponent = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;child component: &#123;&#123;value&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">  inject: [<span class="string">'const'</span>, <span class="string">'grandparent'</span>, <span class="string">'value'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### const #####'</span>, <span class="keyword">this</span>.const); <span class="comment">// xyz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### grandparent #####'</span>, <span class="keyword">this</span>.grandparent); <span class="comment">// 父组件 Vue 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### value #####'</span>, <span class="keyword">this</span>.value); <span class="comment">// abc</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>父组件：</p><p>通过方法返回定义 <code>provide</code>，才子孙组件中接收到父组件的 <code>this</code>，但是父组件中的响应式变量，不会在子孙组件中响应式地变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  provide () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">const</span>: <span class="string">'xyz'</span>,</span><br><span class="line">      grandparent: <span class="keyword">this</span>,</span><br><span class="line">      value: <span class="keyword">this</span>.value</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;child-component&gt;&lt;/child-component&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">'abc'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>孙组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GrandsonComponent = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;child component: &#123;&#123;value&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">  inject: [<span class="string">'const'</span>, <span class="string">'grandparent'</span>, <span class="string">'data'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### const #####'</span>, <span class="keyword">this</span>.const); <span class="comment">// xyz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### grandparent #####'</span>, <span class="keyword">this</span>.grandparent); <span class="comment">// 父组件 Vue 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'##### value #####'</span>, <span class="keyword">this</span>.data); <span class="comment">// &#123;value: 父组件的 value&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>父组件：</p><p>只有在 <code>provide</code> 中重定义 <code>get()</code> 方法，让子孙组件每次获取到的 value 都是其最新值，从而实现响应式。这也是 Vue 实现响应式的最基本原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  provide () &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, <span class="string">'value'</span>, &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; this.value,</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">      <span class="keyword">const</span>: <span class="string">'xyz'</span>,</span><br><span class="line">      grandparent: <span class="keyword">this</span>,</span><br><span class="line">      data</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;child-component&gt;&lt;/child-component&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="text" v-model="value"/&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">'abc'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="6-5-组件-render-function"><a href="#6-5-组件-render-function" class="headerlink" title="6.5 组件 render function"></a>6.5 组件 render function</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 配置 ESLint 规则</title>
      <link href="/2020/02/10/tech/vue/vue-eslint/"/>
      <url>/2020/02/10/tech/vue/vue-eslint/</url>
      
        <content type="html"><![CDATA[<h4 id="安装必要依赖包"><a href="#安装必要依赖包" class="headerlink" title="安装必要依赖包"></a>安装必要依赖包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br><span class="line">npm install babel-eslint --save-dev</span><br><span class="line">npm install eslint-friendly-formatter --save-dev &#x2F;&#x2F; 指定错误报告的格式规范插件</span><br><span class="line">npm install eslint-loader --save-dev  &#x2F;&#x2F; 启动 Vue cli 时就可以检测</span><br><span class="line">npm install eslint-plugin-vue --save-dev  &#x2F;&#x2F; 符合 Vue 项目推荐的代码风格</span><br></pre></td></tr></table></figure><h4 id="eslintrc-js-文件"><a href="#eslintrc-js-文件" class="headerlink" title=".eslintrc.js 文件"></a>.eslintrc.js 文件</h4><p>在项目根目录下创建规则验证文件 <code>.eslintrc.js</code>，以下为 Vue 推荐规则配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>, <span class="comment">// 根文件，不会往上一层查找</span></span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'plugin:vue/recommended'</span>, <span class="string">'eslint:recommended'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="comment">//it is base on https://github.com/vuejs/eslint-config-vue</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"vue/max-attributes-per-line"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">"singleline"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">"multiline"</span>: &#123;</span><br><span class="line">        <span class="string">"max"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"allowFirstLine"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"vue/name-property-casing"</span>: [<span class="string">"error"</span>, <span class="string">"PascalCase"</span>],</span><br><span class="line">    <span class="string">'accessor-pairs'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'arrow-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'before'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'after'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'block-spacing'</span>: [<span class="number">2</span>, <span class="string">'always'</span>],</span><br><span class="line">    <span class="string">'brace-style'</span>: [<span class="number">2</span>, <span class="string">'1tbs'</span>, &#123;</span><br><span class="line">      <span class="string">'allowSingleLine'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'camelcase'</span>: [<span class="number">0</span>, &#123;</span><br><span class="line">      <span class="string">'properties'</span>: <span class="string">'always'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'comma-dangle'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'comma-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'before'</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'after'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'comma-style'</span>: [<span class="number">2</span>, <span class="string">'last'</span>],</span><br><span class="line">    <span class="string">'constructor-super'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'curly'</span>: [<span class="number">2</span>, <span class="string">'multi-line'</span>],</span><br><span class="line">    <span class="string">'dot-location'</span>: [<span class="number">2</span>, <span class="string">'property'</span>],</span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'eqeqeq'</span>: [<span class="number">2</span>, <span class="string">'allow-null'</span>],</span><br><span class="line">    <span class="string">'generator-star-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'before'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'after'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'handle-callback-err'</span>: [<span class="number">2</span>, <span class="string">'^(err|error)$'</span>],</span><br><span class="line">    <span class="string">'indent'</span>: [<span class="number">2</span>, <span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'SwitchCase'</span>: <span class="number">1</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'jsx-quotes'</span>: [<span class="number">2</span>, <span class="string">'prefer-single'</span>],</span><br><span class="line">    <span class="string">'key-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'beforeColon'</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'afterColon'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'keyword-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'before'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'after'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'new-cap'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'newIsCap'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'capIsNew'</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'new-parens'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-array-constructor'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-caller'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-console'</span>: <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">'no-class-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-cond-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-const-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-control-regex'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-delete-var'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-dupe-args'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-dupe-class-members'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-dupe-keys'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-duplicate-case'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-empty-character-class'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-empty-pattern'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-eval'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-ex-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-extend-native'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-extra-bind'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-extra-boolean-cast'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-extra-parens'</span>: [<span class="number">2</span>, <span class="string">'functions'</span>],</span><br><span class="line">    <span class="string">'no-fallthrough'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-floating-decimal'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-func-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-implied-eval'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-inner-declarations'</span>: [<span class="number">2</span>, <span class="string">'functions'</span>],</span><br><span class="line">    <span class="string">'no-invalid-regexp'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-irregular-whitespace'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-iterator'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-label-var'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-labels'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'allowLoop'</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'allowSwitch'</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'no-lone-blocks'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-mixed-spaces-and-tabs'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-multi-spaces'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-multi-str'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-multiple-empty-lines'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'max'</span>: <span class="number">1</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'no-native-reassign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-negated-in-lhs'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-new-object'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-new-require'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-new-symbol'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-new-wrappers'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-obj-calls'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-octal'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-octal-escape'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-path-concat'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-proto'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-redeclare'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-regex-spaces'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-return-assign'</span>: [<span class="number">2</span>, <span class="string">'except-parens'</span>],</span><br><span class="line">    <span class="string">'no-self-assign'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-self-compare'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-sequences'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-shadow-restricted-names'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-spaced-func'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-sparse-arrays'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-this-before-super'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-throw-literal'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-trailing-spaces'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-undef'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-undef-init'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-unexpected-multiline'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-unmodified-loop-condition'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-unneeded-ternary'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'defaultAssignment'</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'no-unreachable'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-unsafe-finally'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-unused-vars'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-useless-call'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-useless-computed-key'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-useless-constructor'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-useless-escape'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-whitespace-before-property'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-with'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'one-var'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'initialized'</span>: <span class="string">'never'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'operator-linebreak'</span>: [<span class="number">2</span>, <span class="string">'after'</span>, &#123;</span><br><span class="line">      <span class="string">'overrides'</span>: &#123;</span><br><span class="line">        <span class="string">'?'</span>: <span class="string">'before'</span>,</span><br><span class="line">        <span class="string">':'</span>: <span class="string">'before'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'padded-blocks'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'quotes'</span>: [<span class="number">2</span>, <span class="string">'single'</span>, &#123;</span><br><span class="line">      <span class="string">'avoidEscape'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'allowTemplateLiterals'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'semi'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'semi-spacing'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'before'</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'after'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'space-before-blocks'</span>: [<span class="number">2</span>, <span class="string">'always'</span>],</span><br><span class="line">    <span class="string">'space-before-function-paren'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'space-in-parens'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'space-infix-ops'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'space-unary-ops'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">'words'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'nonwords'</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'spaced-comment'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, &#123;</span><br><span class="line">      <span class="string">'markers'</span>: [<span class="string">'global'</span>, <span class="string">'globals'</span>, <span class="string">'eslint'</span>, <span class="string">'eslint-disable'</span>, <span class="string">'*package'</span>, <span class="string">'!'</span>, <span class="string">','</span>]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'template-curly-spacing'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'use-isnan'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'valid-typeof'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'wrap-iife'</span>: [<span class="number">2</span>, <span class="string">'any'</span>],</span><br><span class="line">    <span class="string">'yield-star-spacing'</span>: [<span class="number">2</span>, <span class="string">'both'</span>],</span><br><span class="line">    <span class="string">'yoda'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'prefer-const'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">'object-curly-spacing'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, &#123;</span><br><span class="line">      objectsInObjects: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'array-bracket-spacing'</span>: [<span class="number">2</span>, <span class="string">'never'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eslintignore-文件"><a href="#eslintignore-文件" class="headerlink" title=".eslintignore 文件"></a>.eslintignore 文件</h4><p>根目录下创建 .eslintignore 文件，添加规则忽略验证的文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;build&#x2F;</span><br><span class="line">&#x2F;config&#x2F;</span><br><span class="line">&#x2F;node_modules&#x2F;</span><br><span class="line">&#x2F;dist&#x2F;</span><br><span class="line">&#x2F;*.js</span><br><span class="line">&#x2F;test&#x2F;unit&#x2F;coverage&#x2F;</span><br></pre></td></tr></table></figure><h4 id="添加-webpack-配置"><a href="#添加-webpack-配置" class="headerlink" title="添加 webpack 配置"></a>添加 webpack 配置</h4><p>webpack.base.config.js 中添加规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rules:[</span><br><span class="line"> &#x2F;&#x2F; 加到最前面</span><br><span class="line"> &#123;</span><br><span class="line">    test: &#x2F;\.(js|vue)$&#x2F;,</span><br><span class="line">    loader: &#39;eslint-loader&#39;,</span><br><span class="line">    enforce: &#39;pre&#39;,</span><br><span class="line">    include: [resolve(&#39;src&#39;)],</span><br><span class="line">    options: &#123;</span><br><span class="line">      formatter: require(&#39;eslint-friendly-formatter&#39;),</span><br><span class="line">      emitWarning: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ....</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="在-IDE-中开启-ESLint"><a href="#在-IDE-中开启-ESLint" class="headerlink" title="在 IDE 中开启 ESLint"></a>在 IDE 中开启 ESLint</h4><p><img src="/2020/02/10/tech/vue/vue-eslint/IDE-eslint-setting.png" alt="ide-eslint-setting"></p><h4 id="ESLint-规则级别"><a href="#ESLint-规则级别" class="headerlink" title="ESLint 规则级别"></a>ESLint 规则级别</h4><ul><li><p>off 或者 0：不启用这个规则</p></li><li><p>warn 或者 1：校验不通过会报警告</p></li><li><p>error 或者 2：校验不通过会报错</p></li></ul><h4 id="ESLint-规则屏蔽"><a href="#ESLint-规则屏蔽" class="headerlink" title="ESLint 规则屏蔽"></a>ESLint 规则屏蔽</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码会关闭所有规则</span></span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* eslint-enable */</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码会关闭某一行的所有规则</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>); <span class="comment">// eslint-disable-line</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码在某一行关闭指定的规则</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>); <span class="comment">// eslint-disable-line no-alert</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// eslint-disable-next-line no-alert</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><h4 id="package-json-中添加-scripts"><a href="#package-json-中添加-scripts" class="headerlink" title="package.json 中添加 scripts"></a>package.json 中添加 scripts</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">      <span class="attr">"lint"</span>: <span class="string">"eslint --ext .js --ext .jsx --ext .vue src/"</span>,</span><br><span class="line">      <span class="attr">"lint-fix"</span>: <span class="string">"eslint --fix --ext .js --ext .jsx --ext .vue src/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>npm run lint</code></p><p> 检验 <code>src/</code> 目录下文件是否符合 ESLint 验证规则</p><p><code>npm run lint-fix</code></p><p> 将 <code>src/</code> 目录下不符合 ESLint 验证规则的代码进行格式化</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 常用语法</title>
      <link href="/2020/02/05/tech/typeScript/ts-base/"/>
      <url>/2020/02/05/tech/typeScript/ts-base/</url>
      
        <content type="html"><![CDATA[<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0x14</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b10100</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o24</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'bob'</span></span><br><span class="line">name = <span class="string">'smith'</span></span><br></pre></td></tr></table></figure><p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>`</code>），并且以 <code>${ expr }</code> 这种形式嵌入表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Yee`</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span></span><br></pre></td></tr></table></figure><p>这与下面定义 <code>sentence</code> 的方式效果相同：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">'Hello, my name is '</span> + name + <span class="string">'.\n\n'</span> +</span><br><span class="line">    <span class="string">'I\'ll be '</span> + (age + <span class="number">1</span>) + <span class="string">' years old next month.'</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)) <span class="comment">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span> <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()) <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span> <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><p>联合类型是高级主题，我们会在以后的章节里讨论它。</p><p><strong>注意</strong>：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure><p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName)  <span class="comment">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">'maybe a string instead'</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This is my warning message'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p><p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p><p>下面是一些返回 <code>never</code> 类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p><p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: 0 &#125;</span>) // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">null</span></span>) // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">42</span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">'<span class="built_in">string</span>'</span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">false</span></span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">undefined</span></span>) // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure><p>另一个为 <code>as</code> 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p><hr><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p><p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p><p> 如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p><h2 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h2><p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p><p>我们也可以在函数内部定义变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且我们也可以在其它函数内部访问相同的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f()</span><br><span class="line">g() <span class="comment">// returns 11</span></span><br></pre></td></tr></table></figure><p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">shouldInitialize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldInitialize) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="literal">true</span>)  <span class="comment">// returns '10'</span></span><br><span class="line">f(<span class="literal">false</span>) <span class="comment">// returns 'undefined'</span></span><br></pre></td></tr></table></figure><p>有些人可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p><p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentRow = matrix[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">      sum += currentRow[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p><h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" class="headerlink" title="捕获变量怪异之处"></a>捕获变量怪异之处</h3><p>猜一下下面的代码会返回什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">100</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p></blockquote><p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p><p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">100</span> * i)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p><h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">'Hello!'</span></span><br></pre></td></tr></table></figure><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input) &#123;</span><br><span class="line">    <span class="comment">// OK: 仍然能访问到 a</span></span><br><span class="line">    <span class="keyword">let</span> b = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error: 'b' 在这里不存在</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p><p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'Oh no!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Catch it.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 'e' 在这里不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br></pre></td></tr></table></figure><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">// TS2448: Block-scoped variable 'a' used before its declaration.</span></span><br><span class="line"><span class="keyword">let</span> a</span><br></pre></td></tr></table></figure><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// okay to capture 'a'</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在'a'被声明前调用'foo'</span></span><br><span class="line"><span class="comment">// 运行时应该抛出错误</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a</span><br></pre></td></tr></table></figure><p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener">Mozilla Developer Network</a>。</p><h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x</span><br><span class="line">  <span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">20</span> <span class="comment">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure><p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span> <span class="comment">// Error: 干扰参数声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span> <span class="comment">// Error: 不能同时具有 x 的两个声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">condition, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="literal">false</span>, <span class="number">0</span>) <span class="comment">// returns 0</span></span><br><span class="line">f(<span class="literal">true</span>, <span class="number">0</span>)  <span class="comment">// returns 100</span></span><br></pre></td></tr></table></figure><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentRow = matrix[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">      sum += currentRow[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p><p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p><h3 id="块级作用域变量的获取"><a href="#块级作用域变量的获取" class="headerlink" title="块级作用域变量的获取"></a>块级作用域变量的获取</h3><p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p><p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p><p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">100</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出与预料一致的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h2><p><code>const</code> 声明是声明变量的另一种方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span></span><br></pre></td></tr></table></figure><p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p><p>这很好理解，它们引用的值是不可变的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span></span><br><span class="line"><span class="keyword">const</span> kitty = &#123;</span><br><span class="line">  name: <span class="string">'Kitty'</span>,</span><br><span class="line">  numLives: numLivesForCat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">kitty = &#123;</span><br><span class="line">  name: <span class="string">'Tommy'</span>,</span><br><span class="line">  numLives: numLivesForCat</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">kitty.name = <span class="string">'Jerry'</span></span><br><span class="line">kitty.numLives--</span><br></pre></td></tr></table></figure><p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p><h2 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs. const"></a>let vs. const</h2><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p><p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><p>最简单的解构莫过于数组的解构赋值了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> [first, second] = input</span><br><span class="line"><span class="built_in">console</span>.log(first) <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second) <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = input[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> second = input[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>作用于函数参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(first)</span><br><span class="line">  <span class="built_in">console</span>.log(second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(input)</span><br></pre></td></tr></table></figure><p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(first) <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest) <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>你也可以忽略你不关心的尾随元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(first) <span class="comment">// outputs 1</span></span><br></pre></td></tr></table></figure><p>或其它元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>你也可以解构对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">'foo'</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure><p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p><p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class="line"><span class="keyword">let</span> total = passthrough.b + passthrough.c.length</span><br></pre></td></tr></table></figure><h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>你也可以给属性以不同的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a: newName1, b: newName2 &#125; = o</span><br></pre></td></tr></table></figure><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newName1 = o.a</span><br><span class="line"><span class="keyword">let</span> newName2 = o.b</span><br></pre></td></tr></table></figure><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125;: &#123;a: <span class="built_in">string</span>, b: <span class="built_in">number</span>&#125; = o</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>解构也能用于函数声明。 看以下简单的情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a = '', b = 0 &#125; = &#123;&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p></blockquote><p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b = 0 &#125; = &#123; a: '' &#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f(&#123; a: <span class="string">'yes'</span> &#125;) <span class="comment">// OK, 默认 b = 0</span></span><br><span class="line">f() <span class="comment">// OK, 默认 a: '', b = 0</span></span><br><span class="line">f(&#123;&#125;) <span class="comment">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p><p>你还可以展开对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">'spicy'</span>, price: <span class="string">'$10'</span>, ambiance: <span class="string">'noisy'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, food: <span class="string">'rich'</span> &#125;</span><br></pre></td></tr></table></figure><p>search的值为 <code>{ food: &#39;rich&#39;, price: &#39;$10&#39;, ambiance: &#39;noisy&#39; }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">'spicy'</span>, price: <span class="string">'$10'</span>, ambiance: <span class="string">'noisy'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; food: <span class="string">'rich'</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure><p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &#39;rich&#39;</code>，在这里这并不是我们想要的结果。</p><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><p>下面通过一个简单示例来观察接口是如何工作的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; size: <span class="number">10</span>, label: <span class="string">'Size 10 Object'</span> &#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure><p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p><p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">'Size 10 Object'</span>&#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure><p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p><p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  color: <span class="built_in">string</span>,</span><br><span class="line">  area: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span> (<span class="params">config: SquareConfig</span>): <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;color: <span class="string">'white'</span>, area: <span class="number">100</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">'black'</span>&#125;)</span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  color: <span class="built_in">string</span>,</span><br><span class="line">  area: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">   color?: <span class="built_in">string</span>;</span><br><span class="line">   width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): <span class="title">Square</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> newSquare = &#123;color: <span class="string">'white'</span>, area: <span class="number">100</span>&#125;</span><br><span class="line">   <span class="keyword">if</span> (config.clor) &#123;</span><br><span class="line">     <span class="comment">// Error: 属性 'clor' 不存在于类型 'SquareConfig' 中</span></span><br><span class="line">     newSquare.color = config.clor</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">     newSquare.area = config.width * config.width</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newSquare</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">'black'</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span></span><br><span class="line">  readonly y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;</span><br><span class="line">p1.x = <span class="number">5</span> <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span> <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>) <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span> <span class="comment">// error!</span></span><br><span class="line">a = ro <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[]</span><br></pre></td></tr></table></figure><h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a>readonly vs const</h3><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p><h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p><p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span> (<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;color: <span class="string">'white'</span>, area: <span class="number">100</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">'red'</span>, width: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure><p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p><p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p><p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: 'colour' 不存在于类型 'SquareConfig' 中</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">'red'</span>, width: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure><p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig)</span><br></pre></td></tr></table></figure><p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p><p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">'red'</span>, width: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions)</span><br></pre></td></tr></table></figure><p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub)</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap[&#39;daniel&#39;]</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray</span><br><span class="line">myArray = [<span class="string">'Bob'</span>, <span class="string">'Fred'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p><p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>&#39;100&#39;</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  breed: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">  [x: <span class="built_in">number</span>]: Animal</span><br><span class="line">  [x: <span class="built_in">string</span>]: Dog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj[&#39;property&#39;]</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">'Mallory'</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p><h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p><p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beep beep'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick tock'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>)</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br><span class="line">square.penWidth = <span class="number">5.0</span></span><br></pre></td></tr></table></figure><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p><p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">  interval: <span class="built_in">number</span></span><br><span class="line">  reset(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;) <span class="keyword">as</span> Counter</span><br><span class="line">  counter.interval = <span class="number">123</span></span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter()</span><br><span class="line">c(<span class="number">10</span>)</span><br><span class="line">c.reset()</span><br><span class="line">c.interval = <span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> ImageC <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p><p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>下面看一个使用类的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br></pre></td></tr></table></figure><p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p><p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p><p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p><p>看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  move(distance: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Animal moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Woof! Woof!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.bark()</span><br><span class="line">dog.move(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p><p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p><p>下面我们来看个更加复杂的例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  move(distance: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  move(distance: <span class="built_in">number</span> = <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Slithering...'</span>)</span><br><span class="line">    <span class="keyword">super</span>.move(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Horse <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  move(distance: <span class="built_in">number</span> = <span class="number">45</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Galloping...'</span>)</span><br><span class="line">    <span class="keyword">super</span>.move(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">'Sammy'</span>)</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">'Tommy'</span>)</span><br><span class="line"></span><br><span class="line">sam.move()</span><br><span class="line">tom.move(<span class="number">34</span>)</span><br></pre></td></tr></table></figure><p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p><p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p><p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slithering...</span><br><span class="line">Sammy moved 5m.</span><br><span class="line">Galloping...</span><br><span class="line">Tommy moved 34m.</span><br></pre></td></tr></table></figure><h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><h3 id="默认为-public"><a href="#默认为-public" class="headerlink" title="默认为 public"></a>默认为 public</h3><p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p><p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> move(distance: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-private"><a href="#理解-private" class="headerlink" title="理解 private"></a>理解 private</h3><p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">'Cat'</span>).name <span class="comment">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure><p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p><p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p><p>下面来看一个例子，更好地说明了这一点：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'Rhino'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Goat'</span>)</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino()</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">'Bob'</span>)</span><br><span class="line"></span><br><span class="line">animal = rhino</span><br><span class="line">animal = employee <span class="comment">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure><p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p><h3 id="理解-protected"><a href="#理解-protected" class="headerlink" title="理解 protected"></a>理解 protected</h3><p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.department = department</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getElevatorPitch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'Howard'</span>, <span class="string">'Sales'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch())</span><br><span class="line"><span class="built_in">console</span>.log(howard.name) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p><p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 能够继承 Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.department = department</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'Howard'</span>, <span class="string">'Sales'</span>)</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>) <span class="comment">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure><h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>)</span><br><span class="line">john.name = <span class="string">'peter'</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p><p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullName = newName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error: Unauthorized update of employee!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p><p>对于存取器有下面几点需要注意的：</p><p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  scale: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">scale: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.scale = scale</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calculateDistanceFromOrigin(point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDist = point.x - Grid.origin.x</span><br><span class="line">    <span class="keyword">let</span> yDist = point.y - Grid.origin.y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) * <span class="keyword">this</span>.scale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>)  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>)  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class="number">3</span>, y: <span class="number">4</span>&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class="number">3</span>, y: <span class="number">4</span>&#125;))</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span></span><br><span class="line">  move(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'roaming the earth...'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName()</span><br><span class="line">department.printMeeting()</span><br><span class="line">department.generateReports() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">'Hello, there'</span></span><br><span class="line">  greeting: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter: Greeter</span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure><p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p><p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeter = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">  &#125;;</span><br><span class="line">  Greeter.standardGreeting = <span class="string">'Hello, there'</span>;</span><br><span class="line">  <span class="keyword">return</span> Greeter;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> greeter;</span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure><p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p><p>让我们稍微改写一下这个例子，看看它们之间的区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">'Hello, there'</span></span><br><span class="line">  </span><br><span class="line">  greeting: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.greeting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Greeter.standardGreeting</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter: Greeter</span><br><span class="line">greeter = <span class="keyword">new</span> Greeter()</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeterMaker: <span class="keyword">typeof</span> Greeter = Greeter</span><br><span class="line">greeterMaker.standardGreeting = <span class="string">'Hey there'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter2: Greeter = <span class="keyword">new</span> greeterMaker()</span><br><span class="line"><span class="built_in">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure><p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p><p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，”告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p><h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p><h2 id="基本示例-1"><a href="#基本示例-1" class="headerlink" title="基本示例"></a>基本示例</h2><p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p><p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToZ</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><p>让我们为上面那个函数添加类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p><h3 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h3><p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p><p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p><p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p><h2 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h2><p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'Bob'</span>)                  <span class="comment">// Error, 参数过少</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>, <span class="string">'Sr.'</span>);  <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>);         <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName)</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'Bob'</span>);  <span class="comment">// 现在正常了</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>, <span class="string">'Sr.'</span>)  <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>)  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p><p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = 'Smith'</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'Bob'</span>)                  <span class="comment">// 返回 "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'Bob'</span>, <span class="literal">undefined</span>)     <span class="comment">// 正常, 同样 "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>, <span class="string">'Sr.'</span>)  <span class="comment">// 错误, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>)        <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName = 'Will', lastName: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'Bob'</span>)                  <span class="comment">// Error, 参数过少</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>, <span class="string">"Sr."</span>)  <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>)         <span class="comment">// OK， 返回 "Bob Adams"</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="literal">undefined</span>, <span class="string">'Adams'</span>)     <span class="comment">// OK，  返回 "Will Adams"</span></span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p><p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + restOfName.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">'Joseph'</span>, <span class="string">'Samuel'</span>, <span class="string">'Lucas'</span>, <span class="string">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p><p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + restOfName.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buildNameFun: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p><h3 id="this-和箭头函数"><a href="#this-和箭头函数" class="headerlink" title="this 和箭头函数"></a>this 和箭头函数</h3><p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p><p>下面看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker()</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard.card + <span class="string">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure><p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p><p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：这里使用箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker()</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard.card + <span class="string">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure><h3 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h3><p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确保“this”在此独立函数中不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">  suit: <span class="built_in">string</span></span><br><span class="line">  card: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">  suits: <span class="built_in">string</span>[]</span><br><span class="line">  cards: <span class="built_in">number</span>[]</span><br><span class="line"></span><br><span class="line">  createCardPicker (<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">  suits: [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker()</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard.card + <span class="string">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure><p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p><h3 id="this-参数在回调函数里"><a href="#this-参数在回调函数里" class="headerlink" title="this 参数在回调函数里"></a>this 参数在回调函数里</h3><p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener (onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  onClickBad (<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = e.type</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uiElement: UIElement = &#123;</span><br><span class="line">  addClickListener () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uiElement.addClickListener(h.onClickBad) <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  onClickBad (<span class="keyword">this</span>: <span class="built_in">void</span>, e: Event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uiElement: UIElement = &#123;</span><br><span class="line">  addClickListener () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uiElement.addClickListener(h.onClickBad)</span><br></pre></td></tr></table></figure><p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = e.type </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(x)) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length)</span><br><span class="line">    <span class="keyword">return</span> pickedCard</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">'diamonds'</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">'spades'</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">'hearts'</span>, card: <span class="number">4</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard1.card + <span class="string">' of '</span> + pickedCard1.suit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard2.card + <span class="string">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure><p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p><p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;<span class="title">suit</span>: <span class="title">string</span></span>; card: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(x)) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length)</span><br><span class="line">    <span class="keyword">return</span> pickedCard</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">'diamonds'</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">'spades'</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">'hearts'</span>, card: <span class="number">4</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard1.card + <span class="string">' of '</span> + pickedCard1.suit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'card: '</span> + pickedCard2.card + <span class="string">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure><p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p><p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p><p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p><p>不用泛型的话，这个函数可能是下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们使用 <code>any</code> 类型来定义函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p><p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p><p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p><p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'myString'</span>)</span><br></pre></td></tr></table></figure><p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p><p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity(<span class="string">'myString'</span>)</span><br></pre></td></tr></table></figure><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p><h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h2><p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p><p>看下之前 <code>identity</code> 例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p><p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure><p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">  &lt;T&gt;(arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure><p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure><p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p><p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span></span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">stringNumeric.zeroValue = <span class="string">''</span></span><br><span class="line">stringNumeric.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class="string">'test'</span>))</span><br></pre></td></tr></table></figure><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p><p>我们在<a href="/chapter2/class">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p><p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length) <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt; (<span class="params">obj: T, key: K </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">'a'</span>) <span class="comment">// okay</span></span><br><span class="line">getProperty(x, <span class="string">'m'</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><hr><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p><p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p><h2 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h2><p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure><p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p><p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = [<span class="keyword">new</span> Bee(), <span class="keyword">new</span> Lion()]</span><br></pre></td></tr></table></figure><p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo: Animal[] = [<span class="keyword">new</span> Bee(), <span class="keyword">new</span> Lion()]</span><br></pre></td></tr></table></figure><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p><h2 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h2><p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mouseEvent.clickTime)  <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p><p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent:<span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mouseEvent.clickTime)  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p><p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createZoo</span>(<span class="params"></span>): <span class="title">Animal</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">new</span> Bee(), <span class="keyword">new</span> Lion()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure><p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p><hr><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p><p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; (<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T &amp; U</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    result[id] = first[id] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      result[id] = second[id] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">'Jim'</span>), <span class="keyword">new</span> ConsoleLogger())</span><br><span class="line"><span class="keyword">var</span> n = jim.name</span><br><span class="line">jim.log()</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">'Hello world'</span>, <span class="number">4</span>) <span class="comment">// returns "    Hello world"</span></span><br></pre></td></tr></table></figure><p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">'Hello world'</span>, <span class="literal">true</span>) <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">'Hello world'</span>, <span class="literal">true</span>) <span class="comment">// 编译阶段报错</span></span><br></pre></td></tr></table></figure><p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p><p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line">pet.layEggs() <span class="comment">// okay</span></span><br><span class="line">pet.swim()    <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让这段代码工作，我们要使用类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pet <span class="keyword">as</span> Fish).swim) &#123;</span><br><span class="line">  (pet <span class="keyword">as</span> Fish).swim()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (pet <span class="keyword">as</span> Bird).fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h3><p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p><p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> Fish).swim !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p><p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p><h3 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h3><p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span> (<span class="params">x: <span class="built_in">any</span></span>):<span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'number'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span> (<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'string'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span> (<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNumber(padding)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isString(padding)) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === &#39;number&#39;</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span> (<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p><h3 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a>instanceof 类型保护</h3><p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p><p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  fly () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird fly'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird lay eggs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Fish &#123;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fish swim'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fish lay eggs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPet</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="keyword">new</span> Bird() : <span class="keyword">new</span> Fish()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getRandomPet()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Fish) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以为-null-的类型"><a href="#可以为-null-的类型" class="headerlink" title="可以为 null 的类型"></a>可以为 null 的类型</h2><p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href="/chapter2/type">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href="https://en.wikipedia.org/wiki/Null_pointer#History" target="_blank" rel="noopener">价值亿万美金的错误</a>。</p><p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'foo'</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">// 错误, 'null'不能赋值给'string'</span></span><br><span class="line"><span class="keyword">let</span> sn: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="string">'bar'</span></span><br><span class="line">sn = <span class="literal">null</span> <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">sn = <span class="literal">undefined</span> <span class="comment">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure><p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p><h3 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h3><p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + (y || <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">null</span>) <span class="comment">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure><p>可选属性也会有同样的处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  a: <span class="built_in">number</span></span><br><span class="line">  b?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line">c.a = <span class="number">12</span></span><br><span class="line">c.a = <span class="literal">undefined</span> <span class="comment">// error, 'undefined' 不能赋值给 'number'</span></span><br><span class="line">c.b = <span class="number">13</span></span><br><span class="line">c.b = <span class="literal">undefined</span> <span class="comment">// ok</span></span><br><span class="line">c.b = <span class="literal">null</span> <span class="comment">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure><h3 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h3><p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sn === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">'default'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet <span class="comment">// error, 'name' 可能为 null</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">'Bob'</span></span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">'great'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">'Bob'</span></span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">'great'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">broken(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">  animate (dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">    <span class="keyword">if</span> (easing === <span class="string">'ease-in'</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-out'</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-in-out'</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// error! 不能传入 null 或者 undefined.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement()</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'ease-in'</span>)</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'uneasy'</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么到这里，我们的 TypeScript 常用语法学习就告一段落了，当然 TypeScript 还有其他的语法我们并没有讲，我们只是讲了 TypeScript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 TypeScript 开发项目中遇到了其他的 TypeScript 语法知识，你可以通过 TypeScript 的<a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">官网文档</a>学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 TypeScript</title>
      <link href="/2020/02/05/tech/typeScript/ts-init/"/>
      <url>/2020/02/05/tech/typeScript/ts-init/</url>
      
        <content type="html"><![CDATA[<h1 id="初识-TypeScript"><a href="#初识-TypeScript" class="headerlink" title="初识 TypeScript"></a>初识 TypeScript</h1><p>TypeScript 作为 JavaScript 语言的超集，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p><h2 id="TypeScript-的特点"><a href="#TypeScript-的特点" class="headerlink" title="TypeScript 的特点"></a>TypeScript 的特点</h2><p>TypeScript 主要有 3 大特点：</p><ul><li><strong>始于JavaScript，归于JavaScript</strong></li></ul><p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p><ul><li><strong>强大的工具构建大型应用程序</strong></li></ul><p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p><p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p><ul><li><strong>先进的 JavaScript</strong></li></ul><p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p><p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。都 2019 年了，如果你还没有开始学习 TypeScript，那么你可能要落后了哟，所以还等什么，快来和我一起学习并使用 TypeScript 吧，来感受一下它为我们带来的奇妙体验。</p><hr><h1 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h1><p>命令行运行如下命令，全局安装 TypeScript：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -V</span><br></pre></td></tr></table></figure><hr><h1 id="编写第一个-TypeScript-程序"><a href="#编写第一个-TypeScript-程序" class="headerlink" title="编写第一个 TypeScript 程序"></a>编写第一个 TypeScript 程序</h1><p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, '</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Yee'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p><p>在命令行上，运行 TypeScript 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc greeter.ts</span><br></pre></td></tr></table></figure><p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p><p>在命令行上，通过 Node.js 运行这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node greeter.js</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Yee</span><br></pre></td></tr></table></figure><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span> (<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, '</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Yee'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure><p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span> (<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, '</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure><p>重新编译，你会看到产生了一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TS2345: Argument of type &#39;number[]&#39; is not assignable to parameter of type &#39;string&#39;.</span><br></pre></td></tr></table></figure><p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p><p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span></span><br><span class="line">  lastName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span> (<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, '</span> + person.firstName + <span class="string">' '</span> + person.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Yee'</span>,</span><br><span class="line">  lastName: <span class="string">'Huang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p><p>让我们创建一个 <code>User</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p><p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span></span><br><span class="line">  firstName: <span class="built_in">string</span></span><br><span class="line">  lastName: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName</span><br><span class="line">    <span class="keyword">this</span>.fullName = firstName + <span class="string">' '</span> + lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span></span><br><span class="line">  lastName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span> (<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, '</span> + person.firstName + <span class="string">' '</span> + person.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">'Yee'</span>, <span class="string">'Huang'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure><p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM 相关知识点</title>
      <link href="/2020/02/04/tech/npm-all-about/"/>
      <url>/2020/02/04/tech/npm-all-about/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://juejin.im/post/5ab3f77df265da2392364341" target="_blank" rel="noopener">you don’t know npm</a></p><p>nodejs 社区乃至 Web 前端工程化领域发展到今天，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但是现实状况是，我们很多人对这个 nodejs 基础设施的使用和了解还停留在：会用 <code>npm install</code> 这里（一言不合就删除整个 node_modules 目录然后重新 install）</p><p>当然 npm 能成为现在世界上最大规模的<strong>包管理系统</strong>，很大程度上确实归功于它足够<strong>用户友好</strong>，你即使只会执行 install 也不必担心出大问题。但是 npm 的功能远不止于 install 这么简单。一下对 npm 的原理、特性、技巧以及最佳实践做一些归纳总结。</p><h3 id="1-npm-init"><a href="#1-npm-init" class="headerlink" title="1. npm init"></a>1. npm init</h3><p>我们都知道 package.json 文件是用来定义一个 package 的面熟文件，也知道 <code>npm init</code> 命令用来初始化一个简单的 package.json 文件，执行该命令后中断一次询问 name、version、description 等字段。</p><h4 id="1-1-npm-init-执行默认行为"><a href="#1-1-npm-init-执行默认行为" class="headerlink" title="1.1 npm init 执行默认行为"></a>1.1 npm init 执行默认行为</h4><p>而如果想要免去一直按 enter，只需要在命令后追加 –yes 参数即可执行默认行为。</p><p><code>npm init --yes</code></p><h4 id="1-2-自定义-npm-init-行为"><a href="#1-2-自定义-npm-init-行为" class="headerlink" title="1.2 自定义 npm init 行为"></a>1.2 自定义 npm init 行为</h4><p>npm init 命令的原理并不复杂，调用脚本，输出一个初始化的 package.json 文件。所有相应的，定制 npm init 命令的实现方式也不浮躁，在 Home 目录下创建一个 <code>.npm-init.js</code> 即可，该文件的 module.exports 即为 package.json 的配置内容，需要获取用户输入时，使用 <code>prompt()</code> 方法即可。</p><p>例如编写如下 ~/.npm-init.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = prompt(<span class="string">'description?'</span>, <span class="string">'A new package...'</span>);</span><br><span class="line"><span class="keyword">const</span> bar = prompt(<span class="string">'bar?'</span>, <span class="string">''</span>);</span><br><span class="line"><span class="keyword">const</span> count = prompt(<span class="string">'count?'</span>, <span class="string">'100'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  key: <span class="string">'value'</span>,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: bar,</span><br><span class="line">    count: count</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// process.cwd() 获取当前被执行的 js 文件的工作目录</span></span><br><span class="line">  name: prompt(<span class="string">'name?'</span>, process.cwd().split(<span class="string">'/'</span>).pop()),</span><br><span class="line">  version: prompt(<span class="string">'version?'</span>, <span class="string">'0.1.0'</span>),</span><br><span class="line">  description: desc,</span><br><span class="line">  main: <span class="string">'index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时在 ~/npm-all-about 目录下执行 <code>npm init</code> 将会生成这样的 package.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"foo"</span>: &#123;</span><br><span class="line">    <span class="attr">"bar"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="string">"100"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm-all-about"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A new package..."</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 .npm-init.js 是一个常规的模块，所以意味着，除了生成 package.json，我们可以执行任何 node 脚本来完成一些任务。例如通过 fs 创建 README、.eslintrc 等项目必需文件，实现项目脚手架的作用。</p><h3 id="2-依赖包安装"><a href="#2-依赖包安装" class="headerlink" title="2. 依赖包安装"></a>2. 依赖包安装</h3><p>依赖管理是 npm 的核心功能，原理是执行 <code>npm install</code> 从 package.json 中的 dependencies、devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。</p><h4 id="2-1-package-定义"><a href="#2-1-package-定义" class="headerlink" title="2.1 package 定义"></a>2.1 package 定义</h4><p>我们知道，要手动安装一个依赖包时，执行 <code>npm install &lt;package&gt;</code> 命令即可。这里的第三个参数 package 通常就是所需要安装的包名，默认配置下 npm 会从默认的源（Registry）中查找该包名对应的报地址，并下载安装。但除了可以简单地指定包名以外，package 还可以是一个执行有效包名的 http url/git url/ 文件夹路径。</p><p>阅读 <a href="https://docs.npmjs.com/getting-started/packages#what-is-a-package-" target="_blank" rel="noopener">npm 文档</a>，我们会发现 package 的准确订阅，只要符合以下a)到g)其中之一条件，就是一个 package:</p><table><thead><tr><th align="center">id</th><th align="left">说明</th><th align="left">例子</th></tr></thead><tbody><tr><td align="center">a)</td><td align="left">一个包含了程序和描述该程序的 package.json 文件的 <strong>文件夹</strong></td><td align="left">./local-module/</td></tr><tr><td align="center">b)</td><td align="left">一个包含了(a)的 <strong>gzip 压缩文件</strong></td><td align="left">./module.tar.gz</td></tr><tr><td align="center">c)</td><td align="left">一个可以下载的(b)资源的 <strong>url</strong>(通常是 http(s) url)</td><td align="left"><a href="https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz" target="_blank" rel="noopener">https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz</a></td></tr><tr><td align="center">d)</td><td align="left">一个格式为 <code>&lt;name&gt;@&lt;version&gt;</code> 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件(c)</td><td align="left"><a href="mailto:webpack@4.1.0">webpack@4.1.0</a></td></tr><tr><td align="center">e)</td><td align="left">一个格式为 <code>&lt;name&gt;@&lt;tag&gt;</code> 的字符串，在 npm 源上该 <code>&lt;tag&gt;</code> 指向某个 <code>&lt;version&gt;</code> 得到 <code>&lt;name&gt;@&lt;version&gt;</code>，后者满足条件(d)</td><td align="left">webpack@latest</td></tr><tr><td align="center">f)</td><td align="left">一个格式为 <code>&lt;name&gt;</code> 的字符串，默认添加 <code>latest</code> 标签所得到的 <code>&lt;name&gt;@latest</code> 满足条件(e)</td><td align="left">webpack</td></tr><tr><td align="center">g)</td><td align="left">一个 <strong>git url</strong>，该 url 所指向的代码库满足条件(a)</td><td align="left"><a href="mailto:git@github.com">git@github.com</a>:webpack/webpack.git</td></tr></tbody></table><h4 id="2-2-安装本地包-远程-git-仓库包"><a href="#2-2-安装本地包-远程-git-仓库包" class="headerlink" title="2.2 安装本地包/远程 git 仓库包"></a>2.2 安装本地包/远程 git 仓库包</h4><p>上面表格的订阅意味着，我们在共享依赖包时，并不是非要将包发表到 npm 源上才可以提供给用着来安装。这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源进行改造，但依然需要把包共享出去的场景来说是非常实用的。</p><p><strong>场景1: 本地模块引用</strong></p><p>nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能遇到这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../../../../config.js'</span>);</span><br></pre></td></tr></table></figure><p>除了看上去不直观以外，这样的路径引用也不利于代码的重构。这样的重复代码多了也就意味着是时候把这个模块分离除了供应用中其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块使用。</p><p>无需手动开吧文件或者创建软连接到 node_modules 目录，npm 有更优雅的解决方案。</p><p><strong>方案：</strong></p><ol><li><p>创建 config 包：新增 config 文件夹；重命名 config.js 为 config/index.js 文件；创建 package.json 定义 config 包。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"config"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在应用层 package.json 文件中新增依赖项，然后执行 <code>npm install</code>；或直接执行第3步。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"config"</span>: <span class="string">"file:./config"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(等价于第2步) 直接在应用目录执行 <code>npm install file:./config</code>。</p></li></ol><p>此时，查看 <code>node_modules</code> 目录我们会发现多了一个名为 <code>config</code> 的依赖包，指向上层 <code>config/</code> 文件夹的软连接。这是因为 npm 识别 <code>file:</code> 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软连接到 node_modules 中，完成 “安装”过程。</p><p>相比手动软连接，我们既不需要关系 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 <code>npm install</code> 后直接使用。</p><p><strong>场景2: 私有 git 共享 package</strong></p><p>有些时候，我们一个团队内会有一些代码/公用库需要在团队内<strong>不同项目</strong>间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源上。</p><p>这种情况，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将 git url 保存到 dependencies 中。npm 会直接调用系统的 git 命令，从 git 仓库拉取包的内容到 node_modules 中。</p><p><a href="https://docs.npmjs.com/files/package.json#git-urls-as-dependencies" target="_blank" rel="noopener">npm 支持的 git url 格式:</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;:&#x2F;&#x2F;[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][&#x2F;]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure><p>git 路径后可以使用 # 指定特定的 git branch/commit/tag，也可以 #semver: 指定特定的 semver range。</p><blockquote><p>semver（语义化版本）约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号.</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm.git#v1.0.27</span><br><span class="line">git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm#semver:^5.0</span><br><span class="line">git+https:&#x2F;&#x2F;isaacs@github.com&#x2F;npm&#x2F;npm.git</span><br><span class="line">git:&#x2F;&#x2F;github.com&#x2F;npm&#x2F;npm.git#v1.0.27</span><br></pre></td></tr></table></figure><p><strong>场景3: 开源 package 问题修复</strong></p><p>使用某个 npm 包时发现他有某个严重的 bug，但或许最初坐着已不再维护代码了，又或许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。</p><p>此时我们可以手动进入 node_modules 目录下修改相应的内容，也许修改了一行代码就修复了问题。但是这种做法非常不明智！</p><p>首先 node_modules 本身不应该放进版本控制系统，对 node_modules 文件夹中内容的修改不会被记录进 git 提交记录了；其次，就算我们非要反模式，把 node_modules 放进版本控制中，你的修改内容也很容易在下次 team 中某个成员执行 <code>npm install</code> 或 <code>npm update</code> 时被覆盖，而这样的一次提交很可能包含了几十几百个包的更新，你自己所做的修改很容易就被淹没在庞大的 diff 文件列表中了，让版本控制变得非常不合理。</p><p><strong>方案：</strong></p><p>最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖更改为自己修复后版本的 git url 即可解决问题。（fork 代码库后，也便于向原作者体检 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。）</p><h3 id="3-npm-install-如何工作-–-node-modules-目录结构"><a href="#3-npm-install-如何工作-–-node-modules-目录结构" class="headerlink" title="3. npm install 如何工作 – node_modules 目录结构"></a>3. npm install 如何工作 – node_modules 目录结构</h3><p>npm install 执行完毕后，我们可以在 node_modules 中看到所有的依赖包。虽然使用者无需关注这个目录里的文件结构细节，只管在业务代码中引用依赖包即可，但了解 node_modules 的内容可以帮我们更好地理解 npm 如何工作，了解 npm2 到 npm5 有哪些变化和该井。</p><p>为简单起见，假设应用目录为 app，用两个流行的包 <code>webpack</code>、<code>nconf</code> 作为依赖包做实例说明。并且为了正常安装，使用了 npm2 时期的版本 <code>webpack@1.15.0</code>、<code>nconf@0.8.5</code>。</p><h4 id="3-1-npm2"><a href="#3-1-npm2" class="headerlink" title="3.1 npm2"></a>3.1 npm2</h4><p>npm2 在安装依赖包时，采用简单的递归安装方法。执行 <code>npm install</code> 后，npm2 依次递归安装 <code>webpack</code>、<code>nconf</code> 两个包到 node_modules 中。执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_modules&#x2F;</span><br><span class="line">├── nconf&#x2F;</span><br><span class="line">└── webpack&#x2F;</span><br></pre></td></tr></table></figure><p>进入更深一层 nconf 或者 webpack 目录，将看到这两个包各自的 node_modules 中，已经由 npm 递归安装好了自身的依赖包。包括 <code>./node_modules/webpack/node_modules/webpack-core</code>，<code>./node_modules/conf/node_modules/async</code> 等等。而每一个包都有自己的依赖包，每个包自己的依赖都安装在了自己的 node_modules 中。依赖关系层层递进，构成一整个依赖树，这个依赖树与文件系统中的问价结构树刚好层层对应。</p><p>最方便的查看依赖树的方式是直接在 app 目录下执行 <code>npm ls</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app@0.1.0</span><br><span class="line">├─┬ nconf@0.8.5</span><br><span class="line">│ ├── async@1.5.2</span><br><span class="line">│ ├── ini@1.3.5</span><br><span class="line">│ ├── secure-keys@1.0.0</span><br><span class="line">│ └── yargs@3.32.0</span><br><span class="line">└─┬ webpack@1.15.0</span><br><span class="line">  ├── acorn@3.3.0</span><br><span class="line">  ├── async@1.5.2</span><br><span class="line">  ├── clone@1.0.3</span><br><span class="line">  ├── ...</span><br><span class="line">  ├── optimist@0.6.1</span><br><span class="line">  ├── supports-color@3.2.3</span><br><span class="line">  ├── tapable@0.1.10</span><br><span class="line">  ├── uglify-js@2.7.5</span><br><span class="line">  ├── watchpack@0.2.9</span><br><span class="line">  └─┬ webpack-core@0.6.9</span><br><span class="line">    ├── source-list-map@0.1.8</span><br><span class="line">    └── source-map@0.4.4</span><br></pre></td></tr></table></figure><p>这样的目录结构优点在于层级结构明显，便于进行傻瓜式的管理：</p><ol><li>例如新增一个依赖包，可以立即在第一层 node_modules 中看到子目录。</li><li>在已知所需要包名和版本号时，甚至可以从别的文件夹手动拷贝需要的包到 node_modules 文件夹中，再手动修改 package.json 中的依赖配置。</li><li>要删除这个包，也可以简单地手动删除这个包的子目录，斌删除 package.json 文件中相对应的一行即可。</li></ol><p>实际上，很多人在 npm2 时代也的确这样实践过，的确也都可以安装和删除成功，并不会导致什么差错。</p><p>但这样的文件结构也有很明显的问题：</p><ol><li>对复杂的工程，node_module 内目录结构可能会太深，导致深层的文件路径过长而触发 windows 文件系统中，文件路径不能超过<strong>260</strong>个字符长度的限制。</li><li>部分被多个包所依赖的包，很可能在应用 node_modules 目录中的很多地方被重复安装。随着工程规模越来越多，依赖树越来越复杂，这样的包情况会越来越多，造成大量冗余。</li></ol><p>————在这个示例中,<code>webpack</code> 和 <code>nconf</code> 都依赖 <code>async</code> 这个包，所以在文件系统中，webpack 和 nconf 的 node_modules 子目录中都安装了相同的 async 包，并且是相同的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|                   app&#x2F;                    |</span><br><span class="line">+----------+------------------------+-------+</span><br><span class="line">           |                        |</span><br><span class="line">           |                        |</span><br><span class="line">+----------v------+       +---------v-------+</span><br><span class="line">|                 |       |                 |</span><br><span class="line">|  webpack@1.15.0 |       |  nconf@0.8.5    |</span><br><span class="line">|                 |       |                 |</span><br><span class="line">+--------+--------+       +--------+--------+</span><br><span class="line">         |                         |</span><br><span class="line">   +-----v-----+             +-----v-----+</span><br><span class="line">   |async@1.5.2|             |async@1.5.2|</span><br><span class="line">   +-----------+             +-----------+</span><br></pre></td></tr></table></figure><h4 id="3-2-npm3-扁平结构"><a href="#3-2-npm3-扁平结构" class="headerlink" title="3.2 npm3-扁平结构"></a>3.2 npm3-扁平结构</h4><p>主要为了解决以上问题，npm3 的 node_modules 目录改成； 更加扁平的层级结构。文件系统中 <code>webpack</code>、<code>nconf</code>、<code>async</code> 的层级关系变成了平级关系，处于同一级目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------+</span><br><span class="line">         |                   app&#x2F;                    |</span><br><span class="line">         +-+---------------------------------------+-+</span><br><span class="line">           |                                       |</span><br><span class="line">           |                                       |</span><br><span class="line">+----------v------+    +-------------+   +---------v-------+</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">|  webpack@1.15.0 |    | async@1.5.2 |   |  nconf@0.8.5    |</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">+-----------------+    +-------------+   +-----------------+</span><br></pre></td></tr></table></figure><p>虽然这样一来 webpack/node_modules 和 nconf/node_modules 中都不再有 async 文件夹，但得益于 node 的模块加载机制，他们都可以在上一级 node_modules 目录中找到 async 库。所以 webpack 和 nconf 的代码库中 <code>require(&#39;async&#39;)</code> 语句的执行都不会有任何问题。</p><p>这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况，npm3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。</p><p>npm 文档提供了更直接的例子解释这种情况：</p><blockquote><p>加入 <code>package{dep}</code> 写法代表包和包的依赖，那么 <code>A{B, C}</code>，<code>B{C}</code>，<code>C{D}</code> 的依赖结构在安装之后的 node_modules 是这样的结构：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">+-- D</span><br></pre></td></tr></table></figure><p>这里之所以 D 也安装到了与 B C 同一级目录，是因为 npm 默认会在无冲突的前提下，尽可能地将包安装到较高的层级。</p><blockquote><p>如果是 <code>A{B, C}</code>，<code>B{C, D@1}</code>，<code>C{D@2}</code> 的依赖关系，得到的安装后结构是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">   +-- D@2</span><br><span class="line">+-- D@1</span><br></pre></td></tr></table></figure><p>这里是因为，对与 npm 来说，同名但不同版本的包是两个独立的包，而同层不能有两个同名子目录，所以其中的 D@2 放到了 C 的子目录而另一个 D@1 被放到了再上一层的目录。</p><p>很明显在 npm3 之后 npm 的依赖树结构不再与文件夹层级一一对应了。想要查看 app 的直接依赖项，需要通过 <code>npm ls</code> 命令指定 <code>--depth</code> 参数来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls --depth 1</span><br></pre></td></tr></table></figure><blockquote><p>PS：与本地依赖包把不同，如果我们通过 <code>npm install --global</code> 全局安装依赖包到全局目录时，得到的目录依然是”传统的”目录结构。而如果使用 npm3 想得到”传统”形式的本地 node_modules 目录，使用 <code>npm install --global-style</code> 即可。</p></blockquote><h4 id="3-3-npm5-package-lock-文件"><a href="#3-3-npm5-package-lock-文件" class="headerlink" title="3.3 npm5-package-lock 文件"></a>3.3 npm5-package-lock 文件</h4><p>npm5 发布与 2017 年，也是目前最新的 npm 版本，这一版本依然沿用 npm3 之后扁平化的依赖包安装方式，此外最大的变化时增加了 <code>package-lock.json</code> 文件。</p><p>package-lock.json 的作用是<strong>锁定</strong>依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件结构是一一对应的。</p><p>以依赖关系为：<code>app{webpack}</code> 的 ‘app’ 项目为例，其 package-lock 文件包含这样的片段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:  <span class="string">"app"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:  <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="attr">"lockfileVersion"</span>:  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"requires"</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"1.8.11"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz"</span>,</span><br><span class="line">            <span class="attr">"integrity"</span>: <span class="string">"sha1-Yu0hnstBy/qcKuanu6laSYtgkcI="</span>,</span><br><span class="line">            <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                <span class="attr">"async"</span>: <span class="string">"0.9.2"</span>,</span><br><span class="line">                <span class="attr">"clone"</span>: <span class="string">"0.1.19"</span>,</span><br><span class="line">                <span class="attr">"enhanced-resolve"</span>: <span class="string">"0.8.6"</span>,</span><br><span class="line">                <span class="attr">"esprima"</span>: <span class="string">"1.2.5"</span>,</span><br><span class="line">                <span class="attr">"interpret"</span>: <span class="string">"0.5.2"</span>,</span><br><span class="line">                <span class="attr">"memory-fs"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">                <span class="attr">"mkdirp"</span>: <span class="string">"0.5.1"</span>,</span><br><span class="line">                <span class="attr">"node-libs-browser"</span>: <span class="string">"0.4.3"</span>,</span><br><span class="line">                <span class="attr">"optimist"</span>: <span class="string">"0.6.1"</span>,</span><br><span class="line">                <span class="attr">"supports-color"</span>: <span class="string">"1.3.1"</span>,</span><br><span class="line">                <span class="attr">"tapable"</span>: <span class="string">"0.1.10"</span>,</span><br><span class="line">                <span class="attr">"uglify-js"</span>: <span class="string">"2.4.24"</span>,</span><br><span class="line">                <span class="attr">"watchpack"</span>: <span class="string">"0.2.9"</span>,</span><br><span class="line">                <span class="attr">"webpack-core"</span>: <span class="string">"0.6.9"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"webpack-core"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"0.6.9"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz"</span>,</span><br><span class="line">            <span class="attr">"integrity"</span>: <span class="string">"sha1-/FcViMhVjad76e+23r3Fo7FyvcI="</span>,</span><br><span class="line">            <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                <span class="attr">"source-list-map"</span>: <span class="string">"0.1.8"</span>,</span><br><span class="line">                <span class="attr">"source-map"</span>: <span class="string">"0.4.4"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">                <span class="attr">"source-map"</span>: &#123;</span><br><span class="line">                    <span class="attr">"version"</span>: <span class="string">"0.4.4"</span>,</span><br><span class="line">                    <span class="attr">"resolved"</span>: <span class="string">"https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz"</span>,</span><br><span class="line">                    <span class="attr">"integrity"</span>: <span class="string">"sha1-66T12pwNyZneaAMti092FzZSA2s="</span>,</span><br><span class="line">                    <span class="attr">"requires"</span>: &#123;</span><br><span class="line">                        <span class="attr">"amdefine"</span>: <span class="string">"1.0.1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看懂 package-lock 文件并不难，其结构是同样类型的几个字段嵌套起来的，只要是 <code>version</code>，<code>resolved</code>，<code>integrity</code>，<code>requires</code>，<code>dependencies</code> 这几个字段。</p><ul><li><code>version</code>，<code>resolved</code>，<code>integrity</code> 用来记录包的准确版本号、安装源、内容 hash，决定了要安装的包的准确”身份<br>信息。</li><li>假设不看其他字段，只关注 <code>dependencies: {}</code>，可以发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次机构是完全对照的。</li><li>假设只关注 <code>requires: {}</code>，可以发现，除去最外层的 <code>requires</code> 属性为 true 以外，其它层的 requires 属性都对应着这个包的 package.json 里记录自己的所有依赖项。</li></ul><p>因为这个文件记录了 node_modules 里所有包的结构、层级和版本号，甚至安装源，它也就事实上提供了”保存” node_modules 状态的能力。只要有这样一个 lock 文件，那不管在哪一台机器上执行 <code>npm install</code> 都会得到完全相同的 node_modules 结果。</p><p>这就是 package-lock 文件致力于优化的场景：在从前仅仅用 package.json 记录依赖，由于 semver range 机制，一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 <code>npm install</code>，所得到的的 node_modules 结果很可能和一个月前 A 得到的结果存在许多差异，虽然 semver 有机制的限制，同一份 package.json 不会生成大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。</p><p>其实，相同作用的文件在 npm5 之前就有，成为 <code>npm shrinkwrap</code> 文件，二者作用完全相同，不同的是后者需要手动生成，而 npm5 默认会在执行 <code>npm install</code> 后就生成 package-lock 文件，并建议提交到 gi/svn 代码库中。</p><p>package-lock.json 文件在最初 npm5.0 默认引入时引起了相当大的<a href="https://github.com/npm/npm/issues/16866" target="_blank" rel="noopener">争议</a>。在 npm5.0 中，如果已有 package-lock 文件存在，若手动在 package.json 文件中新增一条依赖，再执行 <code>npm install</code>，新增的依赖并不会被安装到 node_modules 中，package-lock 也不会做相应的更新。这样的表现与使用者的自然期望表现不符。在 npm5.1 的首个 <a href="https://github.com/npm/npm/issues/16866" target="_blank" rel="noopener">Release</a> 版本中这个问题得以修复。所以这个事情告诉我吗，要升级，不要使用 npm5.0 版本。</p><p>————但依然有反对的声音认为 package-lock 太复杂，对此 npm 也提供了禁用配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set package-lock false</span><br></pre></td></tr></table></figure><h3 id="4-依赖包版本管理"><a href="#4-依赖包版本管理" class="headerlink" title="4. 依赖包版本管理"></a>4. 依赖包版本管理</h3><p>依赖包安装完并不意味着就万事大吉了，版本的维护和更新也很重要。这一章介绍依赖包升级管理相关知识。</p><h4 id="4-1-semver"><a href="#4-1-semver" class="headerlink" title="4.1 semver"></a>4.1 semver</h4><p>npm 依赖管理的一个重要特性是采用了<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本规范(semver)</a>，作为依赖<strong>版本</strong>管理方案。</p><p>semver 约定一个包的版本号必须包含 <strong>3</strong> 个数字，格式必须为 <code>MAJOR.MINOR.PATCH</code>，意为 <code>主版本号.小版本号.修订版本号</code>。</p><ul><li>MAJOR 对应大的版本号迭代，做了不兼容旧版本的修改时要更新 MAJOR 版本号</li><li>MINOR 对应小版本迭代，发生兼容旧版本 API 的修改或者更能更新时，更新 MINOR 版本号</li><li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号</li></ul><p>对应包作者（发布者），npm 要求在 publish 之前，必须更新版本号。npm 提供了 <code>npm version</code> 工具，执行 <code>npm version major|minor|patch</code> 可以简单地将版本号中响应的数字 <code>+1</code>。</p><blockquote><p>如果包是一个 git 仓库，<code>npm version</code> 还会自动创建一条注释为更新后版本号的 git commit 和名为该版本号的 tag。</p></blockquote><p>对于包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 <a href="https://semver.npmjs.com" target="_blank" rel="noopener">https://semver.npmjs.com</a> 可方便地计算所输入的表达式的匹配范围。常规的规则示例如下表：</p><table><thead><tr><th align="left">range</th><th align="left">含义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>^2.2.1</code></td><td align="left">指定的 MAJOR 版本号下，所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>，<code>2.3.0</code>；不匹配 <code>1.0.3</code>，<code>3.0.1</code></td></tr><tr><td align="left"><code>~2.2.1</code></td><td align="left">指定 MAJOR.MINOR 版本号下，所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>，<code>2.2.9</code>；不匹配 <code>2.3.0</code>，<code>2.3.5</code></td></tr><tr><td align="left"><code>&gt;=2.1</code></td><td align="left">版本号大于或等于 <code>2.1.0</code></td><td align="left">匹配 <code>2.1.2</code>，<code>3.1</code>；</td></tr><tr><td align="left"><code>&lt;=2.2</code></td><td align="left">版本号小于或等于 <code>2.2</code></td><td align="left">匹配 <code>1.0.0</code>，<code>2.2.1</code>，<code>2.2.11</code></td></tr><tr><td align="left"><code>1.0.0 - 2.0.0</code></td><td align="left">版本号从 <code>1.0.0(包含)</code> 到 <code>2.0.0(包含)</code></td><td align="left">匹配 <code>1.0.0</code>，<code>1.3.4</code>，<code>2.0.0</code></td></tr></tbody></table><p>任意两条规则，通过空格连接起来，表示”与”逻辑，即两条规则的交集：</p><p>如 <code>&gt;=2.3.1 &lt;=2.8.0</code> 可以解读为：<code>&gt;=2.3.1</code> 且 <code>&lt;=2.8.0</code>。</p><ul><li>匹配 <code>2.3.1</code>，<code>2.4.5</code>，<code>2.8.0</code></li><li>不匹配 <code>1.0.0</code>，<code>2.3.0</code>，<code>2.8.1</code>，<code>3.0.0</code></li></ul><p>任意两条规则，通过 <code>||</code> 连接起来，表示”或”逻辑，即两条规则的并集：</p><p>如 <code>^2 &gt;=2.3.1 || ^3 &gt;3.2</code></p><ul><li>匹配 <code>2.3.1</code>，<code>2.8.1</code>，<code>3.3.1</code></li><li>不匹配 <code>1.0.0</code>，<code>2.2.0</code>，<code>3.1.0</code>，<code>4.0.0</code></li></ul><p>PS：处理这几种，还有如下更直观的表示版本号范围的写法：</p><ul><li><code>*</code> 或 <code>x</code> 匹配徐偶有主版本</li><li><code>1</code> 或 <code>1.x</code> 匹配主版本为 <strong>1</strong> 的所有版本</li><li><code>1.2</code> 或 <code>1.2.x</code> 匹配版本号为 <strong>1.2</strong> 开头的所有版本</li></ul><p>PPS：在常规仅包含数字的版本号之外，semver 还允许在 <code>MAJOR.MONOR.PATCH</code> 后追加 <code>-</code> 后跟点号分隔的标签，作为预发布版本标签 - <a href="https://github.com/npm/node-semver#prerelease-tags" target="_blank" rel="noopener">Prerelese Tags</a>，通常被视为不稳定、不建议生产环境使用的版本。例如：</p><ul><li><code>1.0.0-alpha</code></li><li><code>1.0.0-beta.1</code></li><li><code>1.0.0-rc.3</code></li></ul><p>上表中我们最常见的是 <code>^1.8.11</code> 这种格式的 range，因为我们使用 <code>npm install &lt;package&gt;</code> 安装依赖包时，npm 默认安装当前最新版本，例如 <code>1.8.11</code>，然后在所安装的版本号前加 <code>^</code> 号，将 <code>^1.8.11</code> 写入 package.json 依赖配置，意味着可以匹配 <code>1.8.11</code> 以上，<code>2.0.0</code> 以下所有的版本。</p><h4 id="4-2-依赖版本升级"><a href="#4-2-依赖版本升级" class="headerlink" title="4.2 依赖版本升级"></a>4.2 依赖版本升级</h4><p>在安装完一个依赖包之后又新版本发布了，如何使用 npm 进行版本升级呢？答案很简单：<code>npm install</code> 或 <code>npm update</code> 即可。但在不同 npm 版本，不同的 package.json，package-lock.json 文件，安装升级的表现也不同。</p><p>还是以 <code>webpack</code> 为例，做如下<strong>前提假设:</strong></p><ul><li>工程项目 <code>app</code> 依赖 <code>webpack</code></li><li>项目最初始化时，安装了当时最新的包 <code>webpack@1.8.0</code>，并且 package.json 中依赖配置为：<code>&quot;webpack&quot;: &quot;^1.8.0&quot;</code></li><li>当前（2018年3月）<code>webpack</code> 最新版本为 <code>4.2.0</code>，<code>webpack 1.x</code> 的最新子版本为 <code>1.15.0</code></li></ul><p>如果我们使用的是 npm3，并且项目不包含 package-lock.json，那么根据 node_modules 是否为空，执行 install/update 结果如下（<strong>node 6.13.1, npm 3.10.10</strong> 环境下测试）：</p><table><thead><tr><th align="left">id</th><th align="left">package.json(BEFORE)</th><th align="left">node_modules(BEFORE)</th><th align="left">command(npm 3)</th><th align="left">package.json(AFTER)</th><th align="left">node_modules(AFTER)</th></tr></thead><tbody><tr><td align="left">a)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td><td align="left"><code>install</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td></tr><tr><td align="left">b)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>空</code></td><td align="left"><code>install</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr><tr><td align="left">c)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr><tr><td align="left">d)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>空</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr></tbody></table><p>根据上表可以对 npm3 做出以下结论：</p><ul><li>如果本地 node_modules 已安装，再次执行 install 不会更新包版本，执行 update 才会更新；而如果本地 node_modules 为空时，执行 install/update 都会直接安装更新包；</li><li>npm update 总会把包更新到符合 package.json 中指定的 semver 的最新版本——本例中符合 <code>^1.8.0</code> 的最新版本为 <code>1.15.9</code>0</li><li>一旦给定 package.json，无论后面执行 npm install 还是 update，package.json 中的 webpack 版本一直保持开始的 <code>^1.8.0</code> 不变</li></ul><p>这里不合理的地方在于，如果最开始团队中第一个人安装了 <code>webpack@1.8.0</code>，而新加入项目的成员，checkout 工程代码后，执行 <code>npm install</code> 会安装得到不太一样的 <code>1.15.0</code> 版本。虽然 semver 约定了小版本号应当向下兼容（相同大版本号下的小版本号兼容），但万一有不熟悉不遵守此约定的包发布者，发布了不兼容的包，此时就可能出现因依赖环境不同导致的 bug。</p><p>如果我们使用的是 npm5，并且项目包含 package-lock.json 文件，那么根据 node_modules 是否为空，执行 install/update 结果如下（<strong>node 9.8.0, npm 5.7.1</strong> 环境下测试）：</p><table><thead><tr><th align="left">id</th><th align="left">package.json(BEFORE)</th><th align="left">node_modules(BEFORE)</th><th align="left">package-lock(BEFORE)</th><th align="left">command(npm 3)</th><th align="left">package.json(AFTER)</th><th align="left">node_modules(AFTER)</th></tr></thead><tbody><tr><td align="left">a)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td><td align="left"><code>@1.8.0</code></td><td align="left"><code>install</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td></tr><tr><td align="left">b)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>空</code></td><td align="left"><code>@1.8.0</code></td><td align="left"><code>install</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td></tr><tr><td align="left">c)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.8.0</code></td><td align="left"><code>@1.8.0</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.15.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr><tr><td align="left">d)</td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>空</code></td><td align="left"><code>@1.8.0</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.8.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr><tr><td align="left">e)</td><td align="left"><code>webpack: ^1.15.0</code></td><td align="left"><code>webpack@1.8.0(旧)</code></td><td align="left"><code>@1.15.0</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.15.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr><tr><td align="left">f)</td><td align="left"><code>webpack: ^1.15.0</code></td><td align="left"><code>webpack@1.8.0(旧)</code></td><td align="left"><code>@1.15.0</code></td><td align="left"><code>update</code></td><td align="left"><code>webpack: ^1.15.0</code></td><td align="left"><code>webpack@1.15.0</code></td></tr></tbody></table><p>与 npm3 相比，在安装和更新依赖版本上主要的区别为：</p><ul><li>无论何时执行 install，npm 都会优先按照 package-lock 中指定的版本来安装 webpack，避免了 npm3 表中情况(b)的出现</li><li>无论何时执行 install/update，package-lock 文件总会跟着 node_modules 更新（因此可以视 package-lock 文件为 node_modules 的 JSON 表述）</li><li>已安装 node_modules 后若执行 npm update，package.json 中版本号也会随之更改为 <code>^1.15.0</code></li></ul><p>由此可见，npm5.1 使得 package.json 和 package-lock.json 中所保存的版本号更加统一，解决了 npm 之前的各种问题。只要准寻好的实践习惯，团队成员可以很方便地维护一套应用代码和 node_modules 依赖都一致的环境。</p><h4 id="4-3-最佳实践"><a href="#4-3-最佳实践" class="headerlink" title="4.3 最佳实践"></a>4.3 最佳实践</h4><ul><li><p>使用 npm: <code>&gt;=5.1</code> 版本，保持 package-lock.json 文件默认开启配置</p></li><li><p>初始化：第一作者初始化项目时使用 <code>npm install &lt;package&gt;</code> 安装依赖包，默认保存 <code>^X.Y.Z</code> 依赖 range 到 package.json 中；提交 <code>package.json</code>，<code>pacakge-lock.json</code>，不提交 <code>node_modules</code> 目录。</p></li><li><p>初始化：项目成员首次 checkout/clone 项目代码后，执行一次 <code>npm install</code> 安装依赖包</p></li><li><p>不要手动修改 package-lock.json 文件</p></li><li><p>升级依赖包：</p><ul><li>升级小版本：本地执行 <code>npm update</code> 升级到新的小版本</li><li>升级大版本：本地执行 <code>npm install &lt;package-name&gt;@&lt;version&gt;</code> 升级到新的大版本</li><li>也可以手动修改 package.json 中版本号为要升级的版本（大于现有版本号）并指定所需的 semver，然后执行 <code>npm install</code></li><li>本地验证升级后新版本无问题后，提交新的 package.json，package-lock.json 文件</li></ul></li><li><p>降级依赖包：</p><ul><li>正确：<code>npm install &lt;package-name&gt;@&lt;version&gt;</code> 验证无问题后，提交新的 package.json，package-lock.json文件</li><li>错误：手动修改 package.json 中的版本号为更低的版本 semver，这样修改并不会生效，因为再次执行 <code>npm install</code> 依然会安装 package-lock.json 中锁定的版本</li></ul></li><li><p>删除依赖包：</p><ul><li>方案1：<code>npm uninstall &lt;package&gt;</code> 并提交 package.json，package-lock.json 文件</li><li>方案2： 把要卸载的包从 package.json 中 dependencies 字段删除，然后执行 <code>npm intall</code> 并提交 package.json，package-lock.json 文件</li></ul></li><li><p>任何时候有人提交了 package.json，package-lock.json 更新后，团队其他成员应该在拉取最新代码后执行 <code>npm install</code> 安装更新后的依赖包</p></li></ul><h3 id="5-npm-scripts"><a href="#5-npm-scripts" class="headerlink" title="5. npm scripts"></a>5. npm scripts</h3><h4 id="5-1-基本使用"><a href="#5-1-基本使用" class="headerlink" title="5.1 基本使用"></a>5.1 基本使用</h4><p>npm scripts 是 npm 另一个很重要的特性。通过 package.json 中 scripts 字段定义一个搅拌，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"echo"</span>: <span class="string">"echo hello world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就可以通过 <code>npm run echo</code> 命令来执行这段脚本，像在 shell 中执行命令 <code>echo hello world</code> 一样，看到终端输出 <code>hello world</code></p><p>npm scripts 提供了一个简单的接口来调用工程相关的脚本。关于更详细的信息，可以参考阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts 使用指南</a></p><p>总结阮一峰老师文章内容：</p><ol><li><code>npm run</code> 命令执行时，会把 <code>./node_modules/.bin/</code> 目录添加到执行环境的 <code>PATH</code> 变量中，因此如果某个<strong>命令行包</strong>没有全局安装，而只安装在了当前项目的 node_modules 中，通过 <code>npm run</code> 一样可以调用该命令</li><li>执行 npm 脚本时要传入参数，需要在命令后加 <code>--</code> 标明，如 <code>npm run test -- --grep=&quot;pattern&quot;</code> 可以将 <code>--grep=&quot;pattern&quot;</code> 参数传递给 <code>test</code> 命令</li><li>npm 提供了 <code>pre</code> 和 <code>post</code> 两个钩子机制，可以定义某个脚本执行前后的所要执行的脚本</li><li>运行时变量：在 <code>npm run</code> 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 <code>process.env</code> 对象访问获得：<ul><li><code>npm_lifecycle_event</code> ——正在运行的脚本名称</li><li><code>npm_package_&lt;key&gt;</code> ——获取当前包 package.json 中某个字段的配置值：如 <code>npm_package_name</code> 获取报名</li><li><code>npm_package_&lt;key&gt;_&lt;sub-key&gt;</code> —— package.json 中嵌套字段属性：如 <code>npm_package_dependencies_webpack</code> 可以获取到 package.json 中的 <code>dependencies.webpack</code> 字段的值，及 webpack 的版本号</li></ul></li></ol><h4 id="5-2-node-modules-bin-目录"><a href="#5-2-node-modules-bin-目录" class="headerlink" title="5.2 node_modules/.bin 目录"></a>5.2 node_modules/.bin 目录</h4><p>上面所说的 <code>node_module/.bin</code> 目录，保存了依赖目录中所安装的可供调用的<strong>命令行包</strong></p><p>何谓命令行包？例如 <code>webpack</code> 就属于一个命令行包。如果我们在安装 webpack 时添加 <code>--global</code> 参数，就可以在终端直接输入 <code>webpack</code> 进行调用。但如果不加 <code>--global</code> 参数，我们会在 <code>node_moldues/.bin</code> 目录里看到名为 webpack 的文件，如果在终端直接输入 <code>./node_modules/.bin/webpack</code> 命令，一样可以执行。</p><p>这是因为 <code>webpack</code> 在 <code>package.json</code> 文件中定义了 <code>bin</code> 字段为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bin 字段的配置格式为：<code>&lt;command&gt;: &lt;file&gt;</code>，即<code>命令名: 可执行文件</code>。npm 执行 install 时，会分析每个依赖包的 package.json 中 <code>bin</code> 字段，并将其包含的条目安装到 <code>./node_modules/.bin</code> 目录中，文件名为 <code>&lt;command&gt;</code>。而如果是全局模式安装，则会在 npm 全局安装路径的 bin 目录下创建指向 <code>&lt;file&gt;</code> 名为 <code>&lt;command&gt;</code> 的软连接。因此，<code>,.node_modules/.bin/webpack</code> 文件在通过命令行调用时，实际上就是执行 <code>node ./node_modules/.bin/webppack.js</code> 命令</p><p>正如上一节所说，<code>npm run</code> 命令在执行时会把 <code>./node_modules/.bin</code> 加入到 <code>PATH</code> 中，使得我们可以直接调用所有提供了命令行调用接口的依赖包。所以最佳的实践是：</p><blockquote><p>将项目依赖的命令行工具安装到项目依赖文件夹中，然后通过 npm scripts 调用，而非全局安装</p></blockquote><p>举例而言，<code>webpack</code> 作为前端最常用的构建工具，虽然我们都习惯了全局安装并直接使用命令行调用，但不同的项目依赖的 webpack 版本可能不同，响应的 <code>webpack.config.js</code> 配置文件也可能只兼容了特定版本的 webpack，如果我们仅仅全局安装了罪行的 webpack4.x，并使用 webpack 命令调用，在一个依赖 webpack3.x 的工程中就会无法成功执行构建</p><p>但如果这类工具总是本地安装，我们要调用一个命令，要手动添加 <code>./node_modules/.bin</code> 这个很长的前缀，未免就太麻烦了，于是 npm 从 <strong>5.2</strong> 版本开始自带了一个新的工具：<code>npx</code></p><h4 id="5-3-npx"><a href="#5-3-npx" class="headerlink" title="5.3 npx"></a>5.3 npx</h4><p>npx 的使用很简单，执行 <code>npx &lt;command&gt;</code> 即可，这里的 <code>&lt;command&gt;</code> 默认就是 <code>./node_modules</code> 目录中安装的可执行脚本名。例如上面本地安装后的 webpack 包，我们可以直接使用 <code>npx webpack</code> 执行即可</p><p>处理这种最简单的场景，npm cli 团队开发者 Kat Marchan 还在这篇文章中介绍了其他几种 npx 的用法：<a href="https://bit.ly/2uzuIHv" target="_blank" rel="noopener">Introducing npx: an npm package runner</a>，国内也有位开发者 robin.law 将原文翻译为中文：<a href="https://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/" target="_blank" rel="noopener">npx是什么，为什么需要npx?</a></p><p>总结：</p><p><strong>场景A：一键执行远程 npm 源的二进制包</strong></p><p>除了在 package 中执行 <code>./node_modules/.bin</code> 中已经安装的命令，还可以直接指定未安装的二进制包名执行。例如我们在一个没有 package.json 也没有 node_modules 的目录下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx cowsay hello</span><br></pre></td></tr></table></figure><p>npx 将会从 npm 源下载 <code>cowsay</code> 这个包（但不安装）并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> _______ </span><br><span class="line">&lt; hello &gt;</span><br><span class="line"> ------- </span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\&#x2F;\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure><p>这种用途非常适合的场景：</p><ul><li>在本地简单测试或调试 npm 源上这些二进制包的功能</li><li>调用 create-react-app 或 yeoman 这类往往每个项目只需要使用一次的脚手架工具</li></ul><p><strong>场景B：一建执行 GitHub Gist</strong></p><p>在 [2.1 package 定义] 这一节中，<code>npm install &lt;package&gt;</code> 可以使包含了有效 package.json 的 git url</p><p>而 GitHub Gist 也是 git 仓库的一种，集合 npx 就可以方便地将简单的脚本共享给其他人，用于该链接的人无需将脚本安装到本地工作目录也可以执行。将 package.json 和需要执行的二进制脚本上传至 Gist，再运行 <code>npx &lt;gist url&gt;</code> 就可以方便地执行该 Gist 定义的命令</p><p>原文作者 Kat Marchan 提供了 <a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="noopener">示例</a>，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx https:&#x2F;&#x2F;gist.github.com&#x2F;zkat&#x2F;4bc19503fe9e9309e2bfaa2c58074d32</span><br></pre></td></tr></table></figure><p>可以得到一个来自 GitHub Gist 的 hello world 问候</p><p><strong>场景C：使用不同版本的 node 执行命令</strong></p><p>将 npx 与 Aria Stewart 创建的 <code>node</code> 包(<a href="https://www.npmjs.com/package/node" target="_blank" rel="noopener">https://www.npmjs.com/package/node</a>) 结合，可以实现在一行命令中使用指定版本的 node 执行命令</p><p>例如先后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx node@4 -e &quot;console.log(process.version)&quot;</span><br><span class="line">npx node@6 -e &quot;console.log(process.version)&quot;</span><br></pre></td></tr></table></figure><p>将分别输出 <code>v4.8.7</code> 和 <code>v6.13.0</code></p><p>往常这种工作是由 <code>nvm</code> 这类 node 版本管理工具来做的，但 <code>npx node@4</code> 这种方式免去了 nvm 手动切换配置的步骤，更加简洁简单</p><h3 id="6-npm-配置"><a href="#6-npm-配置" class="headerlink" title="6. npm 配置"></a>6. npm 配置</h3><h4 id="6-1-npm-config"><a href="#6-1-npm-config" class="headerlink" title="6.1 npm config"></a>6.1 npm config</h4><p>npm cli 提供了 <code>npm config</code> 命令进行 npm 相关配置，通过 <code>npm config ls -l</code> 可查看 npm 的所有配置，包括默认配置。npm 文档页为每个配置项提供了详细的说明 <a href="https://docs.npmjs.com/misc/config" target="_blank" rel="noopener">https://docs.npmjs.com/misc/config</a></p><p>修改配置的命令为：<code>npm config set &lt;ket&gt; &lt;value&gt;</code>，我们使用相关的常见重要配置：</p><ul><li><code>proxy</code>，<code>https-procy</code> ——指定 npm 使用的代理</li><li><code>registry</code> ——指定 npm 下载安装时的源，默认为 <a href="https://registry.npmjs.org/，可以指定私有的" target="_blank" rel="noopener">https://registry.npmjs.org/，可以指定私有的</a> Registry 源</li><li><code>package-lock</code> ——指定是否默认生成 package-lock 文件，建议保持默认 true</li><li><code>save</code> —— true/false 指定是否在 npm install 后保存依赖包为 dependencies，npm5 起默认为 true</li></ul><p>删除指定的配置项命令为：<code>npm config delete &lt;key&gt;</code></p><h4 id="6-2-npmrc-文件"><a href="#6-2-npmrc-文件" class="headerlink" title="6.2 npmrc 文件"></a>6.2 npmrc 文件</h4><p>除了使用 CLI 提供的 <code>npm config</code> 命令显示更改 npm 配置，还可以通过 <code>npmrc</code> 文件直接修改配置</p><p>这样的 npmrc 文件优先级由高到低包括：</p><ul><li>工程内配置文件：<code>/path/to/my/project/.npmrc</code></li><li>用户级配置文件：<code>!/.npmrc</code></li><li>全局配置文件：<code>$PREFIX/etc/npmrc</code>（即 <code>npm config get globalconfig 输出的路径</code>）</li><li>npm 内置配置文件：<code>path/to/npm/npmrc</code></li></ul><p>通过这个机制，我们可以方便地在工程根目录创建一个 <code>.pnmrc</code> 文件来共享需要在团队间共享的 npm 运行相关配置。比如如果我们在公司内网环境下需要通过代理才可以访问 registry.npmjs.org 源，或需要访问内网的 registry，就可以在工作项目下新增 .npmrc 文件并提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;</span><br><span class="line">https-proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;</span><br><span class="line">registry &#x3D; http:&#x2F;&#x2F;registry.example.com&#x2F;</span><br></pre></td></tr></table></figure><p>因为项目级 .pnmrc 文件的作用域只作用在本项目下，所以在非本目录下，这些配置并不生效。对于使用笔记本工作的开发者，可以很好地隔离公司的工作项目、在家学习研究项目两种不同的环境</p><p>将这个功能已 <code>~/.npm-init.js</code> 配置相结合，可以将特定配置的 .npmrc 跟 .gitignore，README 之类的文件一起做到 npm init 脚手架中，进一步减少手动配置。</p><h4 id="6-3-node-版本约束"><a href="#6-3-node-版本约束" class="headerlink" title="6.3 node 版本约束"></a>6.3 node 版本约束</h4><p>虽然一个项目的团队都共享了相同的diamante，但每个人的开发及其可能安装了不同的 node 版本，此外服务器端的版本也可能和本地开发机器不一致</p><p>这又是一个可能带来不一致性的隐私——但也可以通过<strong>声明式约束+脚本限制</strong>来解决</p><p><strong>声明</strong>：通过 <code>package.json</code> 的 <code>engines</code> 属性声明应用运行所需的版本运行时要求。例如项目中使用了 <code>async</code>，<code>awit</code> 特性，<a href="https://node.green/" target="_blank" rel="noopener">查阅兼容性表格</a>得知最低支持版本为 7.6.0，因此指定 engines 配置为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=7.6.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强约束(可选)</strong>：在 npm 中以上字段内容仅作为建议字段使用，若要在私有项目中添加强约束，需要自己写脚本钩子，读取并解析 engines 字段的 semver rang ，然后与运行时环境做对比校验，做适当提醒</p><h3 id="7-小结-npm-最佳实践"><a href="#7-小结-npm-最佳实践" class="headerlink" title="7. 小结 npm 最佳实践"></a>7. 小结 npm 最佳实践</h3><ul><li>使用 npm-init 初始化新项目</li><li>统一项目配置：需要团队共享的 npm config 配置项，固化到 .npmrc 文件中</li><li>统一运行环境，统一 package.json，package-lock.json 文件</li><li>合理使多样化的源安装依赖包：<code>npm install &lt;git url&gt;|&lt;local file&gt;</code></li><li>使用 npm: &gt;=5.2 版本</li><li>使用 npm scripts 与 npx(npm: &gt;=5.2) 脚本管理应用相关脚本</li></ul><h3 id="8-更多资料"><a href="#8-更多资料" class="headerlink" title="8. 更多资料"></a>8. 更多资料</h3><p>参考</p><ul><li>npm team 成员 Ashley Williams 在 2016 年 Node.js Live 的 talk：You Don’t Know npm，当时还没有 npm5<ul><li>YouTube 视频连接：<a href="https://www.youtube.com/watch?v=hopWbVKmiVQ&t=537s" target="_blank" rel="noopener">Node.js Live (Paris) - Ashley Williams, You Don’t Know npm</a></li><li>演讲用的 sliders：<a href="http://ashleygwilliams.github.io/you-dont-know-npm" target="_blank" rel="noopener">the ag_deck</a></li></ul></li><li>这篇 2015 年的文章介绍了如何使用本地模块打包 node_modules 依赖：<a href="https://bit.ly/2DLnaCd" target="_blank" rel="noopener">Build modular application with npm local modules</a></li><li>一篇很好的介绍 package-lock.json 的文章：<a href="https://bit.ly/2Fiok9Z" target="_blank" rel="noopener">Everything you wanted to know about package-lock.json</a></li><li>阮一峰 <a href="http://ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts 使用指南</a></li><li>Kat Marchan 介绍 npx:<ul><li>原文：<a href="http://t.cn/RKIYHBA" target="_blank" rel="noopener">Introducing npx: an npm package runner</a></li><li>中文：<a href="https://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/" target="_blank" rel="noopener">npx是什么，为什么需要npx?</a></li></ul></li></ul><p>文档</p><ul><li>npm 官方文档，无中文翻译<ul><li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">package.json 文件</a></li><li><a href="https://docs.npmjs.com/misc/config" target="_blank" rel="noopener">npm config 配置</a></li><li><a href="https://semver.npmjs.com/" target="_blank" rel="noopener">npm semver 计算器</a></li><li><a href="https://docs.npmjs.com/cli/install" target="_blank" rel="noopener">node_modules 目录扁平化</a></li></ul></li><li>yarn 中文文档，虽然是 npm 竞争者但兼容 package.json 和 node_modules 目录，因此这两部分可以作参考<ul><li><a href="https://yarnpkg.com/zh-Hans/docs/package-json" target="_blank" rel="noopener">package.json - 中文</a></li><li><a href="https://yarnpkg.com/zh-Hans/docs/dependencies" target="_blank" rel="noopener">依赖与版本 - 中文</a></li></ul></li></ul><p>延伸阅读</p><ul><li>sam boyer 《所以你想开发一个包管理系统》，从五官特定语言的角度，介绍一个包管理系统的方方面面：<a href="https://bit.ly/2G36U1e" target="_blank" rel="noopener">So you want to write a package manager</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 Git 命令</title>
      <link href="/2020/02/02/tech/frequently-git-command/"/>
      <url>/2020/02/02/tech/frequently-git-command/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener" title="www.ruanyifeng.com">www.ruanyifeng.com</a></p><p>Git 基本的工作流程如下：<br><img src="/2020/02/02/tech/frequently-git-command/git-flow.jpg" alt="git-flow"></p><p>几个专用名词：</p><blockquote><ul><li>Workspace: 工作区</li><li>Index / Stage: 暂存区</li><li>Repository: 仓库区（或本地仓库）</li><li>Remote: 远程仓库</li></ul></blockquote><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个 Git 代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为 Git 代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和他的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git 的设置文件为 .gitconfig，他可以在用户目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的 Git 配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑 Git 配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line">#停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到残酷去</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有 diff 信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次的提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做一次 commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend ...</span><br></pre></td></tr></table></figure><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定的 commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch -trach [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 在现有分支与指定的远程分支之间，建立追踪关系</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个 commit，合并到当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete</span><br><span class="line">$ git branch -dr</span><br></pre></td></tr></table></figure><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有 tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 在当前分支新建一个 tag</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 在指定 commit 上新建一个 tag</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 查看 tag 信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定 tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有 tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个 tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 查看有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 查看当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 查看 commit 历史，以及每次 commit 发生变更的问价</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 查看某个文件的版本历史，包括问价改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 查看指定文件相关的每一次 diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 查看指定文件什么时间被什么人修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 查看咋黁去和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 查看暂存区和上一个 commit 的差异</span><br><span class="line">$ git diff --cached []</span><br><span class="line"></span><br><span class="line"># 查看工作区与当前分支最新 commit 之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 查看两次提交之间的差异</span><br><span class="line">$ git diff [first-branch] ... [second-branch]</span><br><span class="line"></span><br><span class="line"># 查看某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 查看某次提交发生变化的文件</span><br><span class="line">$ git show --name-onle [commit]</span><br><span class="line"></span><br><span class="line"># 查看某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[file-name]</span><br><span class="line"></span><br><span class="line"># 查看当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库所有的变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 查看所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 查看某个远程仓库的信息</span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 新增一个新的远程仓库，并与其命名</span><br><span class="line">$ git remote add [short-name] [url]</span><br><span class="line"></span><br><span class="line"># 拉取远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --forece</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个 commit 的指定文件到工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复上一个 commit 的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次 commit 保持一致</span><br><span class="line">git reser --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个 commit，用来撤销指定的 commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br></pre></td></tr></table></figure><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br><span class="line"></span><br><span class="line"># 备份当前工作区的内容</span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"># 从 Cit 栈中读取最近一次保存的内容，恢复工作区相关的内容</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"># 查看 Git 栈内所有备份</span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line"># 清空 Git 栈</span><br><span class="line">$ git stash clear</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/01/hello-world/"/>
      <url>/2020/02/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
