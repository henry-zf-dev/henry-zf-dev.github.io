{"meta":{"title":"HenryV2进阶中…","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-05-08T10:40:26.940Z","updated":"2020-01-25T10:13:40.861Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-22T12:48:22.000Z","updated":"2020-02-01T11:56:49.689Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-05-08T10:40:26.941Z","updated":"2020-01-25T10:13:40.851Z","comments":true,"path":"project/index.html","permalink":"http://yoursite.com/project/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-08T10:40:26.941Z","updated":"2020-01-25T10:13:40.863Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"互联网本质的一点讨论","slug":"thinking/20200306","date":"2020-03-06T12:47:46.087Z","updated":"2020-03-06T12:47:46.087Z","comments":true,"path":"2020/03/06/thinking/20200306/","link":"","permalink":"http://yoursite.com/2020/03/06/thinking/20200306/","excerpt":"","text":"今天 Jerry 请我吃麦当劳，顺便陪他去充电桩充电，路上一起讨论了互联网本质的一些东西，感觉 Jerry 总结的很有道理，我准备记录一下，希望以后自己也能对一些事物做出自己的判断 互联网本质讨论的三个结论 客户：相对不是很富裕的人群 服务：让相对高质量的服务廉价化 成本：用空间成本换时间成本 例子：互联网健身房和传统健身房的区别 传统健身房盈利主要靠的是前期会员加入的会员卡费，以及会员购买私教授课的费用，其中会员卡费一般是一次性付完，私教课则按照课时收费。而且相对私教课程，会员费要低很多，市面上普通健身房一年的会员卡费大概在1500-3000之间，而一节私教费就在300~700之间（和城市/地段有关）。而为什么私教课很贵，先不看私教老师本身的专业性、口碑等价值，有一个本质原因是：私教授课过程中，他的时间只能被一个或者少量的人所占用，其时间成本是很高的。而同时教授的人越多，每个人所分担的费用也会相对更少。 另一方面，传统健身房的私教的主要收入也依赖于他所在健身房的客源，所以其价值在一定程度上是被限制的。而诸如超级猩猩这类互联网健身房，由互联网提供的平台，让更多的人不需要办健身房的会员卡，就能有机会接触到更多的优秀私教。相对的，私教也不会受限于他所在健身房的固定圈子，能有更多的机会授课。同时报名私教课的人所要分担的费用也会被平均下来，变得更低，而且也不用办长周期的会员卡绑定消费，所有他们要承担的风险变小，使得更多的人接受这种模式。 互联网让原本相对高质量的私教健身服务，变得廉价，让原本没有太好经济基础的人也能享受到，即使这种模式下的健身私教服务相对于传统的一对一服务，会打折扣，但对于很多人来讲，这已经满足他们的需求了。而对于经济基础很好的人，比如一些明星，肯定就不会接受这种模式，他们追求的就是更专业，更高质量，长期且稳定的服务，对成本的顾虑不在他们考量的第一位。 最后希望自己慢慢变成一个有思想的人，哈哈","categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"春节随想","slug":"thinking/20200125","date":"2020-03-06T12:41:00.665Z","updated":"2020-03-06T12:41:00.665Z","comments":true,"path":"2020/03/06/thinking/20200125/","link":"","permalink":"http://yoursite.com/2020/03/06/thinking/20200125/","excerpt":"","text":"今年因为武汉肺炎的原因，没有回家过年，又一次错失了和家人吃团圆饭的机会，但是有失也有得，我把春节期间自己的所见所想记录在这里，这些都是自己的收获。 峰哥家的团圆饭算来这是第二次在峰哥家吃年饭，因为都是湖北人，饭菜都很合胃口。饭桌上峰哥和我讲了很多比较抽象的东西，还是向来的风格，哈哈。一些道理我可以理解，但一些更深的东西，现阶段的我还无法真正有所体会，阅历不够，思想高度也达不到，也许可以通过多看书来慢慢补上吧。总之，希望自己在技-&gt;术-&gt;通-&gt;道的路上越走越好吧。 和Jerry在公园漫步今天看望了Kim姐和’小朱朱’，小宝贝睡相很可爱，哈哈。吃完午饭就和Jerry还有Jerry老爸老妈在附近的公园转了好大一圈。一路上主要和Jerry聊了不少，以下是对聊天内容的记录和总结。 城市规划和软件产品开发的联系不管是哪个城市，在建设发展中，不可避免地会经历规划、建设、改造、重建等过程，深圳这座发达又年轻的城市也不例外。就拿离我很近的大沙河水质治理为例，深圳到处都能看到对老旧楼宇、基础公共设施的翻新或者重建，城市管理者对城市规划的理解会随着时代变迁而变化，也许这个变迁只需要短短几年。而软件产品的开发也是一样，在最开始，没有人能够完全规划好所有的东西，只能在当前有限的时间、成本、开发人员能力的前提下，做到最好。而随着迭代的进行，客户需求的累计或变更，一定会暴露越来越多的问题，代码的维护性、扩展性、复用性、性能、安全等等，就像房子翻新和重建，我们也需要对代码做优化甚至重构。而这也一样需要考虑当前情况下的时间、成本以及开发人员能力，产品迭代本身就是个动态的过程，把握住一种动态平衡可能就是管理的一部分吧。 对产品开发和客户需求悖论的思考首先闭门造车地开发产品肯定是无法经受时间和实践考验的，这个毋庸置疑。我们需要客户在需求输入端的不断input，但是在产品前期，往往客户并没有想清楚要什么，真正的痛点描述不够准确，而且客户需求转化成产品需求，再到技术需求，到最终实现，这个流程中，最后能产生什么程度的output，往往会和预期存在偏差。我想这个偏差也是一个管理者需要时刻关注的，对偏差进行分析，找到产生的原因，并且有优先级地进行调整，通过不断地迭代，产品才能逐渐迎合越来越多客户的需求，解决客户的问题。 对ezCloud产品定位的理解我的理解是，产品内在价值，是通过软件服务，解决客户在会议室场景下会议室的控、管、维、用相关的问题，降低客户成本。然后基于内在价值，促进公司自研设备和代理设备的推广和销售。然而对于第二点，我以前的理解是，有了ezCloud软件上的支持，肯定会提高公司硬件产品的销售，但是就目前而言，其实ezCloud只是一个加分项而已，而且在整套解决方案中占比很少，是充分不必要条件。ezCloud在项目中的迭代打磨会让它越来越能符合更多客户的需求，但是这个本身不会直接增加硬件的销售。该如何破题，就需要设备库、分控、总控和其他自研硬件，在自检、联检、告警核心业务方向上，相互配合，一步步完善，能真正解决客户问题了。我们现在只能适配别人的设备，等客户多起来，通过我们和客户的推动，带动其他代理厂商对我们进行适配，这样ezCloud的影响力才能逐渐提升，价值也会逐渐体现。现阶段，ezCloud产品还在很初期的阶段，设备库、分控、总控也还有很多不足，我们自研硬件也还只是处在OEM的阶段，总之真的还任重道远。 鲶鱼效应鲶鱼效应是指鲶鱼在搅动小鱼生存环境的同时，也激活了小鱼的求生能力。鲶鱼效应是采取一种手段或措施，刺激一些企业活跃起来投入到市场中积极参与竞争，从而激活市场中的同行业企业。而在一个团队中，通过小数主动的人行动上的正向刺激，潜移默化地带动其他相对被动的人，不管是对个人还是对团队，都能向着更好的方向发展。但是我存在一个疑问，对于相对被动的员工来说，那些积极主动员工的作为或者存在，是不是本身就是一种威胁或者说利益冲突，毕竟鲶鱼对于其他小鱼来说是捕食者和被捕食者的关系。我自己工作经历有限，还没遇到过这种情况，但如果一个团队真的出现这种情况，那肯定是有问题的。然后如果我是那条鲶鱼，该怎么做好呢？怎么能在他人不抵触的前提下，正向地影响更多的人呢？如何提升思维的柔度，是需要自己慢慢思考的东西。 饭桌上的畅谈中午很有幸和Jerry和Jerry老爸老妈一起吃饭。Jerry老爸是个很健谈的人，既有北方人的豪爽，又有南方人的细致，给人第一印象是，一位知识渊博而又畅谈的老先生。Jerry妈妈给人印象就是知性，稳重，又平易近人，给人一种安全感，虽然言语不多，但让人觉得很亲切。Jerry的老爸老妈都很厉害，令人敬佩，不知道Jerry有这么优秀的爸妈，会不会觉得压力很大，哈哈。和Jerry老爸的聊天过程中，我觉得有两点我需要在这里记录一下，一个是如果有能力，帮人要帮到点上，小恩小惠没有什么用，雪中送炭才有意义。我想到的是，以我现在的能力，能够帮助他人帮到点上吗，然后长久以来，有哪些人为我雪中送过炭呢，需要我记住心里。第二点就是，人是很复杂的，看人需要看多面，而且要看多次，我觉得很有道理。 一点总结在回家的路上，我想了一个很简单就能问出来的问题：Jerry为什么要和我说这么多东西呢？我给自己的答案：希望我能有所回应，不管是技术上还是管理上（我觉得Jerry更关心的是我在管理方向的能力发展）。但我现在回应的还不够好，这段时间自己渐渐笃定的职业发展规划，在这个阶段是否是最优的选择？或者说，我该在技术和管理两方面找到平衡？然后Jerry对Cuzz问的三个问题：想要什么？想成为什么？如何达到？我想也是问给我的。这些也都是要自己琢磨的问题…… 从小生活武汉，但一直以来对武汉印象都不太好，虽然家就在那，却总觉得对武汉没什么感情，这也许是我一直学不会武汉话的原因吧。今天听到Jerry老爸一口地道的武汉话，我的第一感觉却是无比的亲切和怀念。人真是种复杂的生物。","categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"Vue 核心 API 学习笔记","slug":"tech/vue/vue-core-api","date":"2020-03-05T13:54:30.430Z","updated":"2020-03-05T13:54:30.431Z","comments":true,"path":"2020/03/05/tech/vue/vue-core-api/","link":"","permalink":"http://yoursite.com/2020/03/05/tech/vue/vue-core-api/","excerpt":"","text":"Demo 地址：Vue 进阶学习 1. Vue 实例实例：对某个类，通过 new ClassA() 初始化而来的对象，叫做实例。对象初始化参考 初始化对象的几种方式 1234const app = new Vue(&#123; el: '#root', template: '&lt;div&gt;This is content&lt;/div&gt;'&#125;); 通过 new Vue(options) 初始化的 Vue 实例，最终会通过 render function 将 template 的内容挂载到 #root 根节点上，在页面中展示，而且挂载的方式是使用 template render 生成的新节点，替换掉 指定的 #root 节点，正式这个原因，如果在 template 中存在多个根节点，Vue 会报一个警告： 注：如果 options 传入了 template，则将 template 编译到 render 函数中去，否则会将 el 外部的 html 作为 template 进行编译 [Vue warn]: Error compiling template:Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 因为 Vue 不知道用哪个节点替换指定的根节点。 不仅仅可以通过 options.el 指定要挂载的根节点，还可以手动进行挂载： 1app.$mount('#root'); 在 webpack 配置中，通过插件，可以指定以某个文件为模板，生成最终的 html 页面： 123new HTMLPlugin(&#123; template: path.join(__dirname, 'index.html')&#125;); 初始化 Vue 传入的 options 会与默认的初始化参数结合起来，最终产生 Vue 实例，而且 options 中的属性可以通过 app.$[attr] 访问，如： app.$el、app.$root、app.$options、app.$data、app.$props、app.$children、app.$refs、app.$slots 等等 app.$el 是对最终挂载生成 html 节点的引用 app.$root 是整个 Vue 树状结构的根节点，也是 Vue 实例，是对 app 的引用，即：app.$root === app app.$options 是初始化 Vue 实例所有的参数，$options 中也可以看到诸如 data、props、watch 等属性，但不是对 app.$[attr] 的引用，所以如果更改 app.$options.data 的值，页面是不会响应式变化的，直接更改 app.$data 才有效 app.$data 定义在 data 对象中的属性，Vue 会复制一份引用到 app 层，即 app.[attr] 和 app.$data[attr] 访问到的是同一份地址， 定义在打 data 中的全局属性，如果不对属性进行字面量声明，则在 Vue 初始化完成之后，给 data 对象增加属性，或修改属性值，Vue 不会对这个对象做响应式处理，所以即使该对象的属性值变化了，也不会响应式地重新渲染 但可以通过 $set 方法给在初始化完成之后再给 data 增加或修改属性，而且也是响应式的 1app.$set(app.obj, 'a', 'foo'); 另外，也删除某个属性，同时会解除对该属性的响应式处理 1app.$delete(app.obj, 'a'); 强制组件重新渲染一次，也可以在没有字面量定义 data 属性时，页面重新渲染（尽量不使用这个方法） 1app.$forceUpdate(); app.$refs 用于快速定位到模板的某个 html 节点，或某个组件实例 app.$isServer 用于服务端渲染判断 app.$watch 一下写法和在 options 中定义 watch 都可以监听到 foo 的变化： 1234const unWatch = app.$watch('foo', (newVal, oldVal) =&gt; &#123; console.log('newVal: ', newVal); console.log('oldVal: ', oldVal);&#125;) 区别在于，通过 app.$watch 定义，需要手动进行销毁（比如路由跳转后），该方法回调一个 unWatch 方法，用于手动回收： 1unWatch(); 而定义在 options 中，Vue 会自动回收销毁 app.$on app.$emit app.$once app.$on 和 app.$emit 都只能同时作用于一个 Vue 对象，才会生效，Vue 对象 app 监听了 test 事件，那么必须由对象 app 自己触发事件 test，才会被监听到，而且不会像 dom 事件一样冒泡 1234app.$on('test', (a, b) =&gt; &#123; console.log('$on test emitted: ', a, b);&#125;);app.$emit('test', 1, 2); app.$once 只会触发一次 123app.$once('test', (a, b) =&gt; &#123; console.log('$once test emitted', a, b);&#125;) 2. Vue 的生命周期方法 beforeCreate 和 created beforeCreate、created 方法在 new Vue(options) 的过程中一定会被执行，而且 beforeCreate、created 两个生命周期中都不能进行 dom 操作，因为这时 Vue 还没有生成最终的根节点，一般操作 dom 相关的动作，要放在 mounted 中。操作数据相关的动作一般放在 created 中，但不要放在 beforeCreate 中，因为 beforeCreate 还没有进行数据的 reactive 响应式相关的初始化 beforeMount 和 mounted mounted 之后会把当前 Vue 生成的 html 挂载到 dom 上，即：把生成的 html 把 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 替换掉。如果在 options 中不指定 el，则不会执行 beforeMount、mounted。在 mounted 之后，所有生命周期中拿到的根节点，都是 mounted 之后产生的节点 beforeCreate、created、beforeMount、mounted 在整个组件生命周期中只会被调用一次，而且 beforeMount、mounted 在服务端渲染中不会被调用，因为这两个生命周期都和操作 dom 有关 beforeUpdate 和 updated 只要响应式处理过的数据有变化，页面就会响应重新渲染，这两个方法也都会被重复调用 activated 和 deactivated 与组件的 keep-alive 相关 beforeDestroy 和 destroyed beforeDestroy 中会解除所有事件监听以及所有的 watch 监听 render render 方法第一次将在 beforeMount 和 mounted 之间执行，之后都将在 beforeUpdate 和 updated 之间执行 renderError 只有在开发环境才会触发，并且只能用于当前组件，它的子组件的错误无法捕获到 errorCaptured 不管是开发环境还是正式环境，只要捕获到当前组件，或者它的子组件渲染发生错误时，都会触发，除非子组件阻止了事件冒泡 3. Vue 的数据绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import Vue from 'vue';var globalVar = '111'; // eslint-disable-linenew Vue(&#123; el: '#root', template: ` &lt;div :id=\"id\" :class=\"activeClass\" @click=\"handleClick\"&gt; &lt;div :class=\"&#123;active: isActive&#125;\"&gt; 模板中只能做用一行语句就能有结果的表达式 &#123;&#123;isActive ? \"active\" : \"not active\"&#125;&#125; &lt;/div&gt; &lt;div :class=\"[&#123;active: isActive&#125;, inactiveClass]\"&gt; 模板中可以访问 Vue 默认的全局变量白名单，但自己定义的全局变量不能访问（如 globalVar） &#123;&#123;Date.now()&#125;&#125; &lt;/div&gt; &lt;div :style=\"[activeStyle, inactiveStyle]\"&gt; 对 data 中定义的 HTML，Vue 会自动进行转移成纯的字符串，为了防止注入攻击 要以 v-html 方式使用 &lt;div v-html=\"html\"&gt;&lt;/div&gt; &lt;div&gt;&#123;&#123;getJoinedArr(arr)&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `, data: &#123; id: 'aaa', activeClass: 'active', inactiveClass: 'inactive', activeStyle: &#123; color: 'red', // Vue 会给需要加前缀的样式属性名自动加上前缀 // 该属性用于消除浏览默认样式 appearance: 'none' &#125;, inactiveStyle: &#123; // html 中所写样式的 '-' 分隔符格式转化成驼峰格式 fontSize: '15px' &#125;, isActive: true, arr: [1, 2, 3], html: '&lt;span&gt;123&lt;/span&gt;' &#125;, methods: &#123; handleClick () &#123; console.log('##### handleClick #####'); &#125;, // 建议这种情况使用 computed， // 因为 computed 会先判断数据源是否有变化，再来渲染页面，效率会更高 getJoinedArr (arr = []) &#123; return arr.join('、'); &#125; &#125;&#125;); 4. computed 和 watch computed: 定义在 computed 中的方法，可以像访问变量的属性一样去调用，这是因为 Vue 会对 fullName 声明 get 和 set 方法，并且会对计算的结果做缓存，只有当 computed 中所依赖的响应式变量（即：firstName 或 lastName）发生变化，才会重新计算。而如果是在 methods 中做同样的逻辑计算，那么只要 data 或者 props 中任何一个属性有变化，都会重新渲染页面，从而重新调用 methods 中的方法。所有定义在 computed 中性能消耗会更小，特别是计算的逻辑很复杂的情况 12345const computed = &#123; fullName () &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;&#125;; 也可以通过显示地定义 get 和 set 方法来定义 computed get: 获取 fullName 的值时会做哪些计算set: 给 fullName 赋值时会做哪些计算。不建议使用 set，因为将多个值通过计算组装成一个值很简单，但把一个值拆解成多个值是很麻烦的，而且很容易出问题，造成死循环 123456789101112const computed = &#123; fullName: &#123; get () &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, set (val) &#123; const names = val.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;; watch: watch 中可以对 data props computed 中的响应式变量进行监听，只要其发生变化，就执行一些逻辑处理 只有当 data.age 发生变化才会执行 age 方法中的逻辑 12345const watch = &#123; age (newVal, oldVal) &#123; this.notYoung = newVal &gt;= 30; &#125;&#125; 也可以通过以下方式定义 watch： immediate：表示是否立即执行 作用：如果 age 的初始值本身已经大于 30，那么按照上面👆的形式定义 watch，第一次 handler 方法是不会执行的，只有当 age 再次发生变化才会执行，而 immediate 就是用来解决这个问题的 12345678const watch = &#123; age: &#123; handler (newVal, oldVal) &#123; this.notYoung = newVal &gt;= 30; &#125;, immediate: true &#125;&#125;; deep：深度观察 作用：如果 other 是一个对象，那么只是修改 other 中属性的值，而不是直接给 other 重新赋值，那么按照上面👆的形式定义 watch，handle 方法也是不会执行的。但如果设置 deep: true，那么 other 不管哪个属性变化，handle 方法都会执行 原理：Vue 会逐层遍历 other 所有的属性，并为每个属性增加一个响应式监听，所有只要 other 任何层级的任何属性发生变化，都会执行 handle 方法 12345678const watch = &#123; other: &#123; handler (newVal, oldVal) &#123; console.log('other changed'); &#125;, deep: true &#125;&#125;; 但这种写法对性能开销较大，建议使用以下👇写法 12345const watch = &#123; 'other.hobby' () &#123; console.log('other.hobby changed'); &#125;&#125;; 5. Vue 的原生指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import Vue from 'vue';new Vue(&#123; el: '#root', template: ` &lt;div&gt; &lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;div v-text=\"text\"&gt;aaa&lt;/div&gt; &lt;div v-html=\"html\"&gt;aaa&lt;/div&gt; &lt;div&gt;类似于 dom 的 innerText 和 innerHtml&lt;/div&gt; &lt;br/&gt; &lt;div v-pre&gt;将内容当做纯文本显示: &#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;br/&gt; &lt;div v-once=\"text\"&gt; &lt;div&gt;数据绑定的内容只执行一次，之后数据变化后也不会随之变化，&lt;/div&gt; &lt;div&gt;用处：展示静态内容时，通过声明 v-once 减少性能开销，&lt;/div&gt; &lt;div&gt;v-once 中的所有节点，Vue 都不会将其和虚拟 dom 进行检测对比，从而减少重新渲染的开销。&lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div v-show=\"active\"&gt;根据 show 的值，给 div 增加 display 的样式&lt;/div&gt; &lt;div v-if=\"active\"&gt;根据 show 的值，决定是否把 div 添加到 dom 流中&lt;/div&gt; &lt;div v-else&gt;else content&lt;/div&gt; &lt;div&gt;如果只是单纯想控制元素的显示和隐藏，那么最好使用 v-show，&lt;/div&gt; &lt;div&gt;因为 v-if 会对 dom 节点进行增删操作，导致重绘和重新排版，有性能的影响。&lt;/div&gt; &lt;br/&gt; &lt;div&gt;v-for 中的 key 是用来做数据缓存的，需要保证唯一，&lt;/div&gt; &lt;div&gt;当数据源发生变化时，Vue 会根据每个 item 的 key 在缓存中寻找，是否已经存在 key，&lt;/div&gt; &lt;div&gt;如果已经存在，则直接在缓存中复用 item 的 dom 节点，而不重新创建新的 dom 节点，提高渲染性能。&lt;/div&gt; &lt;div&gt;注：不要用 idx 作为 key，因为数组元素的顺序和具体值没有什么直接关系，&lt;/div&gt; &lt;div&gt;用 idx 作为 key，在数据源发生增、删之后，可能会导致产生错误的缓存。&lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"(item, idx) in arr\" :key=\"item\"&gt;index: &#123;&#123;idx&#125;&#125;, value: &#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=\"(val, key, idx) in obj\"&gt;key: &#123;&#123;key&#125;&#125;, value: &#123;&#123;val&#125;&#125;, index: &#123;&#123;idx&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; &lt;div v-on:click=\"divClicked\"&gt; &lt;div&gt;v-on 做的事情是：&lt;/div&gt; &lt;div&gt;如果 v-on 加在普通的 dom 节点元素上，则会通过 document.addEventListener 给该节点增加事件监听&lt;/div&gt; &lt;div&gt;如果 v-on 加在 Vue 组件上，实际上是在 Vue 对象实例上绑定一个事件&lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &lt;input type=\"text\" v-model.number=\"number\"&gt; &lt;input type=\"text\" v-model.trim=\"text\"&gt; &lt;input type=\"text\" v-model.lazy=\"text\"&gt; &lt;input type=\"checkbox\" v-model=\"active\"&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; &lt;div&gt;每个 checkbox 所绑定的值是固定的，checkbox 的 active/inactive 变化后:&lt;/div&gt; &lt;div&gt;active -&gt; inactive: 数据移除值为当前 checkbox 所绑定值的元素&lt;/div&gt; &lt;div&gt;inactive -&gt; active: 数据 push 一个值为当前 checkbox 所绑定值的元素&lt;/div&gt; &lt;input type=\"checkbox\" value=\"a\" v-model=\"arr\"&gt; &lt;input type=\"checkbox\" value=\"b\" v-model=\"arr\"&gt; &lt;input type=\"checkbox\" value=\"c\" v-model=\"arr\"&gt; &lt;/div&gt; &lt;br/&gt; &lt;div&gt; &lt;input type=\"radio\" value=\"one\" v-model=\"picked\"&gt; &lt;input type=\"radio\" value=\"two\" v-model=\"picked\"&gt; &lt;/div&gt; &lt;/div&gt; `, data: &#123; text: 'text', number: 0, html: '&lt;span&gt;html&lt;/span&gt;', active: true, arr: ['a', 'b', 'c'], obj: &#123; a: 'a', b: 'b', c: 'c' &#125;, picked: 'one' &#125;, watch: &#123; text () &#123; console.log('##### text changed #####', this.text); &#125;, arr () &#123; console.log('##### arr changed #####', this.arr); &#125;, picked () &#123; console.log('##### arr picked #####', this.picked); &#125; &#125;, methods: &#123; divClicked () &#123; console.log('##### divClicked #####'); &#125; &#125;&#125;); 6. Vue 组件6.1 组件的定义 组件的全局注册和局部注册 123456789101112const component = &#123; template: `&lt;div&gt;This is a component&lt;/div&gt;`&#125;;// 全局注册：Vue.component('CompOne', component); // 组件名称命名规则：大驼峰命名法（因为 component 本身也是一个 Vue 的 class）// 局部注册new Vue(&#123; component: &#123;CompOne: component&#125;, template: `&lt;comp-one&gt;&lt;/comp-one&gt;` // 组件使用命名规则：全小写 '-' 分割&#125;); 组件 data 定义： 不是通过 new Vue({options}) 创建的组件，data 必须以 function 形式返回，否则当一个父组件有多个相同类型的子组件时，所有的子组件都会引用同一份数据源，并且 Vue 会报警告： [Vue warn]: The “data” option should be a function that returns a per-instance value in component definitions. 12345678const component = &#123; template: `&lt;div&gt;This is a component&lt;/div&gt;`, data () &#123; return &#123; a: 'foo' &#125; &#125; &#125;; 组件 props 定义： 1234567891011121314151617181920212223242526272829303132const component = &#123; template: `&lt;div @click=\"handleChange\"&gt;This is a component&lt;/div&gt;`, props: &#123; active: &#123; type: Boolean, // 类型 required: true, // 是否必填 default: true, // 默认值 validator (val) &#123; // 自定义校验 return typeof val === 'boolean' &#125; &#125;, propOne: Number, // 属性命名规则：小驼峰命名法 // 如果是对象，则必须以 function 形式返回一个对象 // 原因和不是通过 new Vue() 创建的组件，data 必须以 function 形式返回一样 // 即当两个相同类型的子组件的一个对象 props 引用了父组件的同一个值，那么就会相互影响 obj () &#123; return &#123; default: &#123;a: 'foo'&#125; &#125; &#125; &#125;, // 也可以通过数组定义 props，但相对不严谨 // props: ['active', 'propOne'], // mounted () &#123; // this.propOne = 1; // &#125;, methods: &#123; handleChange () &#123; this.$emit('change') &#125; &#125; &#125;; Vue 不推荐在子组件中更改 props 的值，如果直接更改，会报警告： [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “propOne” 如果要更改，可以通过子组件 $emit 事件，回调到父组件进行更改 1234567891011121314151617181920new Vue(&#123; el: '#root', components: &#123; Comp: component &#125;, template: ` &lt;div&gt; // 传递 props 时，使用全小写 '-' 分割 &lt;comp :active=\"true\" :prop-one=\"propA\" @change=\"handleChange\"&gt;&lt;/comp&gt; &lt;/div&gt; `, data: &#123; propA: 1 &#125;, methods: &#123; handleChange () &#123; this.propA += 1; &#125; &#125;&#125;); 6.2 组件的继承1234567891011121314151617181920212223242526const component = &#123; template: ` &lt;div&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &lt;span v-show=\"active\"&gt;show if active&lt;/span&gt; &lt;span @click=\"handleChange\"&gt;&#123;&#123;propOne&#125;&#125;&lt;/span&gt; &lt;/div&gt; `, props: &#123; active: Boolean, propOne: String &#125;, data () &#123; return &#123; text: 0 &#125;; &#125;, mounted () &#123; console.log('##### component mounted #####'); &#125;, methods: &#123; handleChange () &#123; this.$emit('change'); &#125; &#125;&#125;; 以上 component 配置只是一个普通的 object，如何让配置生成 Vue 对象，除了通过 new Vue({component: {Comp: component}}) 以外，还可以对 Vue 进行继承，生成 Vue 对象： 12345678910111213141516171819202122232425import Vue from 'vue';const CompVue = Vue.extend(component);new CompVue(&#123; el: '#root', // 通过 props 无法将外部属性传入 // props: &#123; // propOne: 'props 1' // &#125;, // 需要通过 propsData 传入 propsData: &#123; propOne: 'propsData 1' &#125;, // 可以传入 data 与 CompVue 默认的 data 合并覆盖 data () &#123; return &#123; text: 3 &#125;; &#125;, // 生命周期方法执行顺序：先执行 CompVue 默认配置中的生命周期方法，再执行 CompVue 实例中的生命周期方法 mounted () &#123; console.log('##### instance mounted #####'); &#125;&#125;); CompVue 是 Vue 的一个子类，通过 new Vue(options) 初始化而来 Vue 对象，是默认内置配置下生成的，没有 data、props 等相关配置，通过 new CompVue() 生成的 Vue 对象会默认带有 data、props、methods 配置 也可以通过以下这种方式实现对 component 的继承： 123456789101112131415161718192021import Vue from 'vue';const component2 = &#123; extends: component, data () &#123; return &#123; text: 1 &#125;; &#125;, mounted () &#123; console.log('##### instance mounted #####'); &#125;&#125;;new Vue(&#123; el: '#root', components: &#123; Comp: component2 &#125;, template: `&lt;comp prop-one=\"123\"&gt;&lt;/comp&gt;`&#125;); 使用场景：当我们开发好一个组件，可能比较公用，很多项目都会用到，而且功能描述比较泛，使用起来需要传入很多的配置项，而在某个具体项目中，很多参数都使用它的默认值，不需要传入，或者需要在原有基础上扩展一些特定的属性，这时候就可以通过 extend 的方式，在原有组件基础上，继承扩展出我们需要的组件，而不需要从头开始写一个新的组件 6.3 组件自定义绑定1234567891011121314151617181920212223242526272829303132333435import Vue from 'vue';// 通过 v-model 实现父子组件的双向绑定const component = &#123; template: ` &lt;div&gt; &lt;input type=\"text\" :value=\"value1\" @input=\"handleInput\"&gt; &lt;/div&gt; `, model: &#123; prop: 'value1', // 指定双向绑定 prop 的 key event: 'change' // 指定回调时间的方法名 &#125;, props: ['value', 'value1'], methods: &#123; handleInput (event) &#123; // this.$emit('input', event.target.value); this.$emit('change', event.target.value); &#125; &#125;&#125;;new Vue(&#123; el: '#root', components: &#123; Comp: component &#125;, // template: `&lt;comp :value=\"value\" @input=\"value = arguments[0]\"&gt;&lt;/comp&gt;`, template: `&lt;comp v-model=\"value\"&gt;&lt;/comp&gt;`, data () &#123; return &#123; value: '123' &#125;; &#125;&#125;); 6.4 组件高级属性 slot 和 slot-scope 在子组件中可以通过指定不同插槽名，定义多个插槽： 1234567891011121314151617181920212223242526import Vue from 'vue';const component = &#123; template: ` &lt;div :style=\"style\"&gt; &lt;div class=\"header\"&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"body\"&gt; &lt;slot name=\"body\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `, data () &#123; return &#123; style: &#123; width: '200px', height: '200px', border: '1px solid #aaa' &#125; &#125;; &#125;&#125;; 在父组件中根据插槽名传入不同的插槽： 1234567891011121314151617import Vue from 'vue';new Vue(&#123; el: '#root', components: &#123; CompOne: component &#125;, template: ` &lt;div&gt; &lt;comp-one&gt; &lt;div slot=\"header\"&gt;slot header&lt;/div&gt; &lt;div slot=\"body\"&gt;slot body&lt;/div&gt; &lt;div slot=\"footer\"&gt;slot footer&lt;/div&gt; &lt;/comp-one&gt; &lt;/div&gt; ` &#125;); 带作用域的插槽：在子组件插槽中定义内部属性，父组件通过 slot-scop 可以访问到子组件的属性： 12345678910111213141516171819202122import Vue from 'vue';const component = &#123; template: ` &lt;div :style=\"style\"&gt; &lt;slot :slotValue1=\"slotProp\" :slotValue2=\"slotData\"&gt;&lt;/slot&gt; &lt;/div&gt; `, props: &#123; slotProp: String &#125;, data () &#123; return &#123; style: &#123; width: '200px', height: '200px', border: '1px solid #aaa' &#125;, slotData: 'abc' &#125;; &#125;&#125;; 通过指定 “props” 作为 key，将插槽中的属性包装成 object，这样父组件就可以通过 props[key] 来访问插槽中的属性 12345678910111213141516171819202122232425import Vue from 'vue';new Vue(&#123; el: '#root', components: &#123; CompOne: component &#125;, template: ` &lt;div&gt; &lt;comp-one :slot-prop=\"value1\"&gt; &lt;div slot-scope=\"props\"&gt; &lt;div&gt;slotValue1: &#123;&#123;props.slotValue1&#125;&#125;&lt;/div&gt; &lt;div&gt;slotValue2: &#123;&#123;props.slotValue2&#125;&#125;&lt;/div&gt; &lt;div&gt;selfValue: &#123;&#123;value2&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/comp-one&gt; &lt;/div&gt; `, data () &#123; return &#123; value1: 'def', value2: 'ijk' &#125;; &#125;&#125;); provide 和 inject 对于跨多级的组件中，父组件和子组件的参数传递，可以通过在父组件中定义 provide，子组件中定义 inject 来实现 孙组件： 123456789const GrandsonComponent = &#123; template: '&lt;div&gt;child component&lt;/div&gt;', inject: ['const', 'grandparent', 'value'], mounted () &#123; console.log('##### const #####', this.const); // xyz console.log('##### grandparent #####', this.grandparent); // undefined console.log('##### value #####', this.value); // 在父组件中报错 &#125;&#125;; 子组件： 12345678const ChildComponent = &#123; components: &#123; GrandsonComponent &#125;, template: ` &lt;grandson-component&gt;&lt;/grandson-component&gt; `&#125;; 父组件： 通过 provide: {} 的方式定义 provide，在子孙组件中是拿不到父组件的 this 的，只能接收到传入的常量，因为这样初始化 provide 对象，其实 Vue 本身还没有初始化完成，所有访问不了 this 123456789101112131415161718192021import Vue from 'vue';new Vue(&#123; el: '#root', components: &#123; ChildComponent &#125;, provide: &#123; const: 'xyz', grandparent: this, value: this.value // 报错 &#125;, template: ` &lt;child-component&gt;&lt;/child-component&gt; `, data () &#123; return &#123; value: 'abc' &#125;; &#125;&#125;); 孙组件： 123456789const GrandsonComponent = &#123; template: '&lt;div&gt;child component: &#123;&#123;value&#125;&#125;&lt;/div&gt;', inject: ['const', 'grandparent', 'value'], mounted () &#123; console.log('##### const #####', this.const); // xyz console.log('##### grandparent #####', this.grandparent); // 父组件 Vue 实例 console.log('##### value #####', this.value); // abc &#125;&#125;; 父组件： 通过方法返回定义 provide，才子孙组件中接收到父组件的 this，但是父组件中的响应式变量，不会在子孙组件中响应式地变化 1234567891011121314151617181920212223import Vue from 'vue';new Vue(&#123; el: '#root', components: &#123; ChildComponent &#125;, provide () &#123; return &#123; const: 'xyz', grandparent: this, value: this.value &#125;; &#125;, template: ` &lt;child-component&gt;&lt;/child-component&gt; `, data () &#123; return &#123; value: 'abc' &#125;; &#125;&#125;); 孙组件： 123456789const GrandsonComponent = &#123; template: '&lt;div&gt;child component: &#123;&#123;value&#125;&#125;&lt;/div&gt;', inject: ['const', 'grandparent', 'data'], mounted () &#123; console.log('##### const #####', this.const); // xyz console.log('##### grandparent #####', this.grandparent); // 父组件 Vue 实例 console.log('##### value #####', this.data); // &#123;value: 父组件的 value&#125; &#125;&#125;; 父组件： 只有在 provide 中重定义 get() 方法，让子孙组件每次获取到的 value 都是其最新值，从而实现响应式。这也是 Vue 实现响应式的最基本原理 1234567891011121314151617181920212223242526272829import Vue from 'vue';new Vue(&#123; el: '#root', components: &#123; ChildComponent &#125;, provide () &#123; const data = &#123;&#125;; Object.defineProperty(data, 'value', &#123; get: () =&gt; this.value, enumerable: true &#125;); return &#123; const: 'xyz', grandparent: this, data &#125;; &#125;, template: ` &lt;child-component&gt;&lt;/child-component&gt; &lt;input type=\"text\" v-model=\"value\"/&gt; `, data () &#123; return &#123; value: 'abc' &#125;; &#125;&#125;); 6.5 组件 render function","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue 配置 ESLint 规则","slug":"tech/vue/vue-eslint","date":"2020-02-10T15:56:02.016Z","updated":"2020-02-10T15:56:02.016Z","comments":true,"path":"2020/02/10/tech/vue/vue-eslint/","link":"","permalink":"http://yoursite.com/2020/02/10/tech/vue/vue-eslint/","excerpt":"","text":"安装必要依赖包12345npm install eslint --save-devnpm install babel-eslint --save-devnpm install eslint-friendly-formatter --save-dev &#x2F;&#x2F; 指定错误报告的格式规范插件npm install eslint-loader --save-dev &#x2F;&#x2F; 启动 Vue cli 时就可以检测npm install eslint-plugin-vue --save-dev &#x2F;&#x2F; 符合 Vue 项目推荐的代码风格 .eslintrc.js 文件在项目根目录下创建规则验证文件 .eslintrc.js，以下为 Vue 推荐规则配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192module.exports = &#123; root: true, // 根文件，不会往上一层查找 parserOptions: &#123; parser: 'babel-eslint', sourceType: 'module' &#125;, env: &#123; browser: true, node: true, es6: true, &#125;, extends: ['plugin:vue/recommended', 'eslint:recommended'], // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: &#123; \"vue/max-attributes-per-line\": [2, &#123; \"singleline\": 10, \"multiline\": &#123; \"max\": 1, \"allowFirstLine\": false &#125; &#125;], \"vue/name-property-casing\": [\"error\", \"PascalCase\"], 'accessor-pairs': 2, 'arrow-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'block-spacing': [2, 'always'], 'brace-style': [2, '1tbs', &#123; 'allowSingleLine': true &#125;], 'camelcase': [0, &#123; 'properties': 'always' &#125;], 'comma-dangle': [2, 'never'], 'comma-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'comma-style': [2, 'last'], 'constructor-super': 2, 'curly': [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 2, 'eqeqeq': [2, 'allow-null'], 'generator-star-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'handle-callback-err': [2, '^(err|error)$'], 'indent': [2, 2, &#123; 'SwitchCase': 1 &#125;], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [2, &#123; 'beforeColon': false, 'afterColon': true &#125;], 'keyword-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'new-cap': [2, &#123; 'newIsCap': true, 'capIsNew': false &#125;], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 0, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [2, &#123; 'allowLoop': false, 'allowSwitch': false &#125;], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [2, &#123; 'max': 1 &#125;], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 2, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 0, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [2, &#123; 'defaultAssignment': false &#125;], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': 0, 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [2, &#123; 'initialized': 'never' &#125;], 'operator-linebreak': [2, 'after', &#123; 'overrides': &#123; '?': 'before', ':': 'before' &#125; &#125;], 'padded-blocks': [2, 'never'], 'quotes': [2, 'single', &#123; 'avoidEscape': true, 'allowTemplateLiterals': true &#125;], 'semi': [2, 'never'], 'semi-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [2, &#123; 'words': true, 'nonwords': false &#125;], 'spaced-comment': [2, 'always', &#123; 'markers': ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] &#125;], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], 'yoda': [2, 'never'], 'prefer-const': 2, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [2, 'always', &#123; objectsInObjects: false &#125;], 'array-bracket-spacing': [2, 'never'] &#125;&#125; .eslintignore 文件根目录下创建 .eslintignore 文件，添加规则忽略验证的文件配置 123456&#x2F;build&#x2F;&#x2F;config&#x2F;&#x2F;node_modules&#x2F;&#x2F;dist&#x2F;&#x2F;*.js&#x2F;test&#x2F;unit&#x2F;coverage&#x2F; 添加 webpack 配置webpack.base.config.js 中添加规则： 1234567891011121314rules:[ &#x2F;&#x2F; 加到最前面 &#123; test: &#x2F;\\.(js|vue)$&#x2F;, loader: &#39;eslint-loader&#39;, enforce: &#39;pre&#39;, include: [resolve(&#39;src&#39;)], options: &#123; formatter: require(&#39;eslint-friendly-formatter&#39;), emitWarning: true &#125; &#125;, ....] 在 IDE 中开启 ESLint ESLint 规则级别 off 或者 0：不启用这个规则 warn 或者 1：校验不通过会报警告 error 或者 2：校验不通过会报错 ESLint 规则屏蔽123456// 下面的代码会关闭所有规则/* eslint-disable */ console.log('foo'); /* eslint-enable */ 12345// 下面的代码会关闭某一行的所有规则console.log('foo'); // eslint-disable-line // eslint-disable-next-lineconsole.log('foo'); 12345// 下面的代码在某一行关闭指定的规则console.log('foo'); // eslint-disable-line no-alert // eslint-disable-next-line no-alertconsole.log('foo'); package.json 中添加 scripts123456&#123; \"scripts\": &#123; \"lint\": \"eslint --ext .js --ext .jsx --ext .vue src/\", \"lint-fix\": \"eslint --fix --ext .js --ext .jsx --ext .vue src/\" &#125;&#125; npm run lint 检验 src/ 目录下文件是否符合 ESLint 验证规则 npm run lint-fix 将 src/ 目录下不符合 ESLint 验证规则的代码进行格式化","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"TypeScript 常用语法","slug":"tech/typeScript/ts-base","date":"2020-02-05T08:11:40.837Z","updated":"2020-02-05T08:11:40.837Z","comments":true,"path":"2020/02/05/tech/typeScript/ts-base/","link":"","permalink":"http://yoursite.com/2020/02/05/tech/typeScript/ts-base/","excerpt":"","text":"基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 boolean（其它语言中也一样）。 1let isDone: boolean = false 数字和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 20let hexLiteral: number = 0x14let binaryLiteral: number = 0b10100let octalLiteral: number = 0o24 字符串JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（&quot;）或单引号（&#39;）表示字符串。 12let name: string = 'bob'name = 'smith' 你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以 ${ expr } 这种形式嵌入表达式 12345let name: string = `Yee`let age: number = 37let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.` 这与下面定义 sentence 的方式效果相同： 12let sentence: string = 'Hello, my name is ' + name + '.\\n\\n' + 'I\\'ll be ' + (age + 1) + ' years old next month.' 数组TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： 1let list: number[] = [1, 2, 3] 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3] 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 123let x: [string, number]x = ['hello', 10] // OKx = [10, 'hello'] // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)) // OKconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = 'world' // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toStringx[6] = true // Error, 布尔不是(string | number)类型 联合类型是高级主题，我们会在以后的章节里讨论它。 注意：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。 枚举enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： 12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green 或者，全部都采用手动赋值： 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字： 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]console.log(colorName) // 显示'Green'因为上面代码里它的值是2 any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： 123let notSure: any = 4notSure = 'maybe a string instead'notSure = false // 也可以是个 boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let list: any[] = [1, true, 'free']list[1] = 100 void某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123function warnUser(): void &#123; console.log('This is my warning message')&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null： 1let unusable: void = undefined null 和 undefinedTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大： 12let u: undefined = undefinedlet n: null = null 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 然而，当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。 再次说明，稍后我们会介绍联合类型。 nevernever 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。 never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 下面是一些返回 never 类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message)&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\")&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; objectobject 表示非原始类型，也就是除 number，string，boolean，symbol，null或undefined 之外的类型。 使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如： 123456789declare function create(o: object | null): voidcreate(&#123; prop: 0 &#125;) // OKcreate(null) // OKcreate(42) // Errorcreate('string') // Errorcreate(false) // Errorcreate(undefined) // Error 类型断言有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = 'this is a string'let strLength: number = (&lt;string&gt;someValue).length 另一个为 as 语法： 123let someValue: any = 'this is a string'let strLength: number = (someValue as string).length 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。 变量声明let 和 const 是 JavaScript 里相对较新的变量声明方式。let 在很多方面与 var 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。const 是对 let 的一个增强，它能阻止对一个变量再次赋值。 因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 let 和 const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。 如果你已经对 var 声明的怪异之处了如指掌，那么你可以轻松地略过这节。 var 声明在 ES5 的时代，我们都是通过 var 关键字定义JavaScript 变量： 1var a = 10 大家都能理解，这里定义了一个名为 a 值为 10 的变量。 我们也可以在函数内部定义变量： 12345function f() &#123; var message = 'Hello World!' return message&#125; 并且我们也可以在其它函数内部访问相同的变量： 12345678910function f() &#123; var a = 10 return function g() &#123; var b = a + 1 return b &#125;&#125;var g = f()g() // returns 11 上面的例子是一个典型的闭包场景，g 可以获取到 f 函数里定义的 a 变量。 每当 g 被调用时，它都可以访问到 f 里的 a 变量。 即使当 g 在 f 已经执行完后才被调用，它仍然可以访问 a。 作用域规则var 声明有些奇怪的作用域规则。 看下面的例子： 12345678910function f(shouldInitialize) &#123; if (shouldInitialize) &#123; var x = 10 &#125; return x&#125;f(true) // returns '10'f(false) // returns 'undefined' 有些人可能要多看几遍这个例子。 变量 x 是定义在 if 语句里面，但是我们却可以在语句的外面访问它。 这是因为 var 声明的作用域是函数作用域，函数参数也使用函数作用域。 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错： 1234567891011function sumMatrix(matrix) &#123; var sum = 0 for (var i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i] for (var i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i] &#125; &#125; return sum&#125; 这里很容易看出一些问题，里层的 for 循环会覆盖变量 i，因为所有 i 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。 捕获变量怪异之处猜一下下面的代码会返回什么： 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 100 * i)&#125; 答案是，setTimeout 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）： 1234567891010101010101010101010 很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样： 123456789100123456789 我们传给 setTimeout 的每一个函数表达式实际上都引用了相同作用域里的同一个 i。 让我们花点时间思考一下这是为什么。 setTimeout 在若干毫秒后执行一个函数，并且是在 for 循环结束后。for 循环结束后，i 的值为 10。 所以当函数被调用的时候，它会打印出 10。 一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 i 的值： 1234567for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i) &#125;, 100 * i) &#125;)(i)&#125; 这种奇怪的形式我们已经司空见惯了。 参数 i 会覆盖 for 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 for 循环体里的代码。 let 声明现在你已经知道了 var 存在一些问题，这恰好说明了为什么用 let 语句来声明变量。 除了名字不同外， let 与 var 的写法一致： 1let hello = 'Hello!' 主要的区别不在语法上，而是语义，我们接下来会深入研究。 块作用域当用 let 声明一个变量，它使用的是块作用域。 不同于使用 var 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 for 循环之外是不能访问的。 123456789101112function f(input: boolean) &#123; let a = 100 if (input) &#123; // OK: 仍然能访问到 a let b = a + 1 return b &#125; // Error: 'b' 在这里不存在 return b&#125; 这里我们定义了 2 个变量 a 和 b。 a 的作用域是 f 函数体内，而 b 的作用域是 if 语句块里。 在 catch 语句里声明的变量也具有同样的作用域规则。 123456789try &#123; throw 'Oh no!';&#125;catch (e) &#123; console.log('Catch it.')&#125;// Error: 'e' 在这里不存在console.log(e) 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于暂时性死区。 它只是用来说明我们不能在 let 语句之前访问它们，幸运的是 TypeScript 可以告诉我们这些信息。 12a++ // TS2448: Block-scoped variable 'a' used before its declaration.let a 注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。 12345678910function foo() &#123; // okay to capture 'a' return a&#125;// 不能在'a'被声明前调用'foo'// 运行时应该抛出错误foo()let a 关于暂时性死区的更多信息，查看这里 Mozilla Developer Network。 重定义及屏蔽我们提过使用 var 声明时，它不在乎你声明多少次；你只会得到 1 个。 12345678function f(x) &#123; var x var x if (true) &#123; var x &#125;&#125; 在上面的例子里，所有 x 的声明实际上都引用一个相同的x，并且这是完全有效的代码，但这经常会成为 bug 的来源。幸运的是 let 的声明就不会这么宽松了。 12let x = 10let x = 20 // 错误，不能在 1 个作用域里多次声明 x 并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。 12345678function f(x) &#123; let x = 100 // Error: 干扰参数声明&#125;function g() &#123; let x = 100 var x = 100 // Error: 不能同时具有 x 的两个声明&#125; 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。 1234567891011function f(condition, x) &#123; if (condition) &#123; let x = 100 return x &#125; return x&#125;f(false, 0) // returns 0f(true, 0) // returns 100 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let 重写之前的 sumMatrix 函数。 1234567891011function sumMatrix(matrix: number[][]) &#123; let sum = 0 for (let i = 0; i &lt; matrix.length; i++) &#123; let currentRow = matrix[i] for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i] &#125; &#125; return sum&#125; 这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 i。 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。 块级作用域变量的获取每次进入一个作用域时，let 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。 回想一下前面 setTimeout 的例子，我们最后需要使用立即执行的函数表达式来获取每次 for 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 TypeScript 里这样做了。 当 let 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 setTimeout 例子里我们仅使用 let 声明就可以了。 12345for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 100 * i)&#125; 会输出与预料一致的结果： 123456789100123456789 const 声明const 声明是声明变量的另一种方式。 1const numLivesForCat = 9 它们与 let 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let 相同的作用域规则，但是不能对它们重新赋值。 这很好理解，它们引用的值是不可变的。 123456789101112131415const numLivesForCat = 9const kitty = &#123; name: 'Kitty', numLives: numLivesForCat&#125;// Errorkitty = &#123; name: 'Tommy', numLives: numLivesForCat&#125;;// OKkitty.name = 'Jerry'kitty.numLives-- 除非你使用特殊的方法去避免，实际上 const 变量的内部状态是可修改的。 幸运的是，TypeScript 允许你将对象的成员设置成只读的。接口一章有详细说明。 let vs. const现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。 使用最小特权原则，所有变量除了你计划去修改的都应该使用 const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 const 也可以让我们更容易的推测数据的流动。 解构解构数组最简单的解构莫过于数组的解构赋值了： 1234let input = [1, 2]let [first, second] = inputconsole.log(first) // outputs 1console.log(second) // outputs 2 这创建了 2 个命名变量 first 和 second。 相当于使用了索引，但更为方便： 12let first = input[0]let second = input[1] 作用于函数参数： 12345678let input: [number, number] = [1, 2]function f([first, second]: [number, number]) &#123; console.log(first) console.log(second)&#125;f(input) 你可以在数组里使用 ... 语法创建剩余变量： 123let [first, ...rest] = [1, 2, 3, 4]console.log(first) // outputs 1console.log(rest) // outputs [ 2, 3, 4 ] 你也可以忽略你不关心的尾随元素： 12let [first] = [1, 2, 3, 4]console.log(first) // outputs 1 或其它元素： 1let [, second, , fourth] = [1, 2, 3, 4] 对象解构你也可以解构对象： 123456let o = &#123; a: 'foo', b: 12, c: 'bar'&#125;let &#123; a, b &#125; = o 这通过 o.a 和 o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。 你可以在对象里使用 ... 语法创建剩余变量： 12let &#123; a, ...passthrough &#125; = olet total = passthrough.b + passthrough.c.length 属性重命名你也可以给属性以不同的名字： 1let &#123; a: newName1, b: newName2 &#125; = o 这里的语法开始变得混乱。 你可以将 a: newName1 读做 &quot;a 作为 newName1&quot;。 方向是从左到右，好像你写成了以下样子： 12let newName1 = o.alet newName2 = o.b 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。 1let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o 默认值默认值可以让你在属性为 undefined 时使用缺省值： 123function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject&#125; 现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。 函数声明解构也能用于函数声明。 看以下简单的情况： 1234type C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123; // ...&#125; 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。 1234function f(&#123; a = '', b = 0 &#125; = &#123;&#125;): void &#123; // ...&#125;f() 上面的代码是一个类型推断的例子，将在后续章节介绍。 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性： 123456function f(&#123; a, b = 0 &#125; = &#123; a: '' &#125;): void &#123; // ...&#125;f(&#123; a: 'yes' &#125;) // OK, 默认 b = 0f() // OK, 默认 a: '', b = 0f(&#123;&#125;) // Error, 一旦传入参数则 a 是必须的 要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 展开123let first = [1, 2]let second = [3, 4]let bothPlus = [0, ...first, ...second, 5] 这会令 bothPlus 的值为 [0, 1, 2, 3, 4, 5]。 展开操作创建了 first 和 second的 一份浅拷贝。 它们不会被展开操作所改变。 你还可以展开对象： 12let defaults = &#123; food: 'spicy', price: '$10', ambiance: 'noisy' &#125;let search = &#123; ...defaults, food: 'rich' &#125; search的值为 { food: &#39;rich&#39;, price: &#39;$10&#39;, ambiance: &#39;noisy&#39; }。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话： 12let defaults = &#123; food: 'spicy', price: '$10', ambiance: 'noisy' &#125;let search = &#123; food: 'rich', ...defaults &#125; 那么，defaults 里的 food 属性会重写 food: &#39;rich&#39;，在这里这并不是我们想要的结果。 接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探下面通过一个简单示例来观察接口是如何工作的： 123456function printLabel(labelledObj: &#123; label: string &#125;) &#123; console.log(labelledObj.label)&#125;let myObj = &#123; size: 10, label: 'Size 10 Object' &#125;printLabel(myObj) 类型检查器会查看 printLabel 的调用。printLabel 有一个参数，并要求这个对象参数有一个名为 label 类型为 string 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。 下面我们重写上面的例子，这次使用接口来描述：必须包含一个label 属性且类型为 string： 12345678910interface LabelledValue &#123; label: string&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label)&#125;let myObj = &#123;size: 10, label: 'Size 10 Object'&#125;printLabel(myObj) LabelledValue 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 label 属性且类型为string 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。 12345678910111213141516171819202122interface Square &#123; color: string, area: number&#125;interface SquareConfig &#123; color?: string width?: number&#125;function createSquare (config: SquareConfig): Square &#123; let newSquare = &#123;color: 'white', area: 100&#125; if (config.color) &#123; newSquare.color = config.color &#125; if (config.width) &#123; newSquare.area = config.width * config.width &#125; return newSquare&#125;let mySquare = createSquare(&#123;color: 'black'&#125;) 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare 里的 color 属性名拼错，就会得到一个错误提示： 1234567891011121314151617181920212223interface Square &#123; color: string, area: number&#125;interface SquareConfig &#123; color?: string; width?: number;&#125; function createSquare(config: SquareConfig): Square &#123; let newSquare = &#123;color: 'white', area: 100&#125; if (config.clor) &#123; // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中 newSquare.color = config.clor &#125; if (config.width) &#123; newSquare.area = config.width * config.width &#125; return newSquare &#125; let mySquare = createSquare(&#123;color: 'black'&#125;) 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性: 1234interface Point &#123; readonly x: number readonly y: number&#125; 你可以通过赋值一个对象字面量来构造一个 Point。 赋值后，x 和 y 再也不能被改变了。 12let p1: Point = &#123; x: 10, y: 20 &#125;p1.x = 5 // error! TypeScript 具有 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 123456let a: number[] = [1, 2, 3, 4]let ro: ReadonlyArray&lt;number&gt; = aro[0] = 12 // error!ro.push(5) // error!ro.length = 100 // error!a = ro // error! 上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： 1a = ro as number[] readonly vs const最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。 额外的属性检查我们在第一个例子里使用了接口，TypeScript 让我们传入 { size: number; label: string; } 到仅期望得到 { label: string; } 的函数里, 并且我们已经学过了可选属性。 然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 createSquare 例子来说： 123456789101112131415161718interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare (config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123;color: 'white', area: 100&#125; if (config.color) &#123; newSquare.color = config.color &#125; if (config.width) &#123; newSquare.area = config.width * config.width &#125; return newSquare&#125;let mySquare = createSquare(&#123; colour: 'red', width: 100 &#125;) 注意传入 createSquare 的参数拼写为 colour 而不是 color。 在 JavaScript 里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为 width 属性是兼容的，不存在 color 属性，而且额外的 colour 属性是无意义的。 然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 12// error: 'colour' 不存在于类型 'SquareConfig' 中let mySquare = createSquare(&#123; colour: 'red', width: 100 &#125;) 绕开这些检查非常简单。 最简便的方法是使用类型断言： 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig) 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig 带有上面定义的类型的 color 和 width 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： 12345interface SquareConfig &#123; color?: string width?: number [propName: string]: any&#125; 我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig 可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么。 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions 不会经过额外属性检查，所以编译器不会报错。 12let squareOptions = &#123; colour: 'red', width: 100 &#125;let mySquare = createSquare(squareOptions) 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 color 或 colour 属性到 createSquare，你应该修改 SquareConfig 定义来体现出这一点。 函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 123interface SearchFunc &#123; (source: string, subString: string): boolean&#125; 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345let mySearch: SearchFuncmySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： 12345let mySearch: SearchFuncmySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1&#125; 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false 和 true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc 接口中的定义不匹配。 12345let mySearch: SearchFuncmySearch = function(src, sub) &#123; let result = src.search(sub) return result &gt; -1&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[&#39;daniel&#39;]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： 12345678interface StringArray &#123; [index: number]: string&#125;let myArray: StringArraymyArray = ['Bob', 'Fred']let myStr: string = myArray[0] 上面例子里，我们定义了 StringArray 接口，它具有索引签名。 这个索引签名表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。 TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用&#39;100&#39;（一个 string ）去索引，因此两者需要保持一致。 123456789101112class Animal &#123; name: string&#125;class Dog extends Animal &#123; breed: string&#125;// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay &#123; [x: number]: Animal [x: string]: Dog&#125; 字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property 和 obj[&#39;property&#39;] 两种形式都可以。 下面的例子里， name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： 12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = ['Alice', 'Bob'];myArray[2] = 'Mallory'; // error! 类类型实现接口与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。 12345678interface ClockInterface &#123; currentTime: Date&#125;class Clock implements ClockInterface &#123; currentTime: Date constructor(h: number, m: number) &#123; &#125;&#125; 你也可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样： 123456789101112interface ClockInterface &#123; currentTime: Date setTime(d: Date)&#125;class Clock implements ClockInterface &#123; currentTime: Date setTime(d: Date) &#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123; &#125;&#125; 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： 123456789interface ClockConstructor &#123; new (hour: number, minute: number)&#125;// errorclass Clock implements ClockConstructor &#123; currentTime: Date constructor(h: number, m: number) &#123; &#125;&#125; 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor 存在于类的静态部分，所以不在检查的范围内。 看下面的例子，我们定义了两个接口， ClockConstructor 为构造函数所用和 ClockInterface 为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。 1234567891011121314151617181920212223242526interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface&#125;interface ClockInterface &#123; tick()&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute)&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log('beep beep') &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log('tick tock') &#125;&#125;let digital = createClock(DigitalClock, 12, 17)let analog = createClock(AnalogClock, 7, 32) 因为 createClock 的第一个参数是 ClockConstructor 类型，在 createClock(AnalogClock, 7, 32) 里，会检查 AnalogClock 是否符合构造函数签名。 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Shape &#123; color: string&#125;interface Square extends Shape &#123; sideLength: number&#125;let square = &#123;&#125; as Squaresquare.color = 'blue'square.sideLength = 10 一个接口可以继承多个接口，创建出多个接口的合成接口。 12345678910111213141516interface Shape &#123; color: string&#125;interface PenStroke &#123; penWidth: number&#125;interface Square extends Shape, PenStroke &#123; sideLength: number&#125;let square = &#123;&#125; as Squaresquare.color = 'blue'square.sideLength = 10square.penWidth = 5.0 混合类型先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 1234567891011121314151617interface Counter &#123; (start: number): string interval: number reset(): void&#125;function getCounter(): Counter &#123; let counter = (function (start: number) &#123; &#125;) as Counter counter.interval = 123 counter.reset = function () &#123; &#125; return counter&#125;let c = getCounter()c(10)c.reset()c.interval = 5.0 在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 axios 库就是一个很好的例子。 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例： 1234567891011121314151617181920class Control &#123; private state: any&#125;interface SelectableControl extends Control &#123; select(): void&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// Error：“ImageC”类型缺少“state”属性。class ImageC implements SelectableControl &#123; select() &#123; &#125;&#125; 在上面的例子里，SelectableControl 包含了 Control 的所有成员，包括私有成员 state。 因为 state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口。 因为只有 Control 的子类才能够拥有一个声明于Control 的私有成员 state，这对私有成员的兼容性是必需的。 在 Control 类内部，是允许通过 SelectableControl 的实例来访问私有成员 state 的。 实际上，SelectableControl 接口和拥有 select 方法的 Control 类是一样的。Button和 TextBox 类是 SelectableControl 的子类（因为它们都继承自Control 并有 select 方法），但 ImageC 类并不是这样的。 类对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。 基本示例下面看一个使用类的例子： 1234567891011class Greeter &#123; greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet() &#123; return 'Hello, ' + this.greeting &#125;&#125;let greeter = new Greeter('world') 如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 Greeter 类。这个类有 3 个成员：一个叫做 greeting 的属性，一个构造函数和一个 greet 方法。 你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。 最后一行，我们使用 new 构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。 继承在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 看下面的例子： 123456789101112131415class Animal &#123; move(distance: number = 0) &#123; console.log(`Animal moved $&#123;distance&#125;m.`) &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log('Woof! Woof!') &#125;&#125;const dog = new Dog()dog.bark()dog.move(10) 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Dog 是一个 派生类，它派生自 Animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。 因为 Dog 继承了 Animal 的功能，因此我们可以创建一个 Dog 的实例，它能够 bark() 和 move()。 下面我们来看个更加复杂的例子。 1234567891011121314151617181920212223242526272829303132333435class Animal &#123; name: string constructor(name: string) &#123; this.name = name &#125; move(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;m.`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distance: number = 5) &#123; console.log('Slithering...') super.move(distance) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distance: number = 45) &#123; console.log('Galloping...') super.move(distance) &#125;&#125;let sam = new Snake('Sammy')let tom: Animal = new Horse('Tommy')sam.move()tom.move(34) 这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal的两个子类：Horse 和 Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 move 方法，它们重写了从 Animal 继承来的 move 方法，使得 move 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.move(34) 时，它会调用 Horse 里重写的方法。 1234Slithering...Sammy moved 5m.Galloping...Tommy moved 34m. 公共，私有与受保护的修饰符默认为 public在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，C# 要求必须明确地使用 public 指定成员是可见的。 在 TypeScript 里，成员都默认为 public。 你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal 类： 123456789class Animal &#123; public name: string public constructor(name: string) &#123; this.name = name &#125; public move(distance: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;m.`) &#125;&#125; 理解 private当成员被标记成 private 时，它就不能在声明它的类的外部访问。比如： 12345678class Animal &#123; private name: string constructor(name: string) &#123; this.name = name &#125;&#125;new Animal('Cat').name // 错误: 'name' 是私有的. TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。 下面来看一个例子，更好地说明了这一点： 1234567891011121314151617181920212223242526class Animal &#123; private name: string constructor(name: string) &#123; this.name = name &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super('Rhino') &#125;&#125;class Employee &#123; private name: string constructor(name: string) &#123; this.name = name &#125;&#125;let animal = new Animal('Goat')let rhino = new Rhino()let employee = new Employee('Bob')animal = rhinoanimal = employee // 错误: Animal 与 Employee 不兼容. 这个例子中有 Animal 和 Rhino 两个类， Rhino 是 Animal 类的子类。 还有一个 Employee 类，其类型看上去与 Animal 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal 和 Rhino 共享了来自 Animal 里的私有成员定义 private name: string，因此它们是兼容的。然而 Employee 却不是这样。当把 Employee 赋值给 Animal 的时候，得到一个错误，说它们的类型不兼容。尽管 Employee 里也有一个私有成员 name，但它明显不是 Animal 里面定义的那个。 理解 protectedprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 1234567891011121314151617181920212223class Person &#123; protected name: string constructor(name: string) &#123; this.name = name &#125;&#125;class Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.` &#125;&#125;let howard = new Employee('Howard', 'Sales')console.log(howard.getElevatorPitch())console.log(howard.name) // error 注意，我们不能在 Person 类外使用 name，但是我们仍然可以通过 Employee 类的实例方法访问，因为 Employee 是由 Person 派生而来的。 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如： 1234567891011121314151617181920212223class Person &#123; protected name: string protected constructor(name: string) &#123; this.name = name &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.` &#125;&#125;let howard = new Employee('Howard', 'Sales')let john = new Person('John') // 错误: 'Person' 的构造函数是被保护的. readonly 修饰符你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 123456789class Person &#123; readonly name: string constructor(name: string) &#123; this.name = name &#125;&#125;let john = new Person('John')john.name = 'peter' 参数属性在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性： 1234class Person &#123; constructor(readonly name: string) &#123; &#125;&#125; 注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。 存取器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。 123456789class Employee &#123; fullName: string&#125;let employee = new Employee()employee.fullName = 'Bob Smith'if (employee.fullName) &#123; console.log(employee.fullName)&#125; 我们可以设置 fullName，因为它是 public 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。 下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 fullName 的直接访问改成了可以检查密码的 set 方法。 我们也加了一个 get 方法，让上面的例子仍然可以工作。 123456789101112131415161718192021222324let passcode = 'secret passcode'class Employee &#123; private _fullName: string get fullName(): string &#123; return this._fullName &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == 'secret passcode') &#123; this._fullName = newName &#125; else &#123; console.log('Error: Unauthorized update of employee!') &#125; &#125;&#125;let employee = new Employee()employee.fullName = 'Bob Smith'if (employee.fullName) &#123; console.log(employee.fullName)&#125; 我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。 对于存取器有下面几点需要注意的： 首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 Grid.xxx 来访问静态属性。 123456789101112131415161718192021class Grid &#123; static origin = &#123;x: 0, y: 0&#125; scale: number constructor (scale: number) &#123; this.scale = scale &#125; calculateDistanceFromOrigin(point: &#123;x: number; y: number&#125;) &#123; let xDist = point.x - Grid.origin.x let yDist = point.y - Grid.origin.y return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale &#125;&#125;let grid1 = new Grid(1.0) // 1x scalelet grid2 = new Grid(5.0) // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 3, y: 4&#125;))console.log(grid2.calculateDistanceFromOrigin(&#123;x: 3, y: 4&#125;)) 抽象类抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。 123456abstract class Animal &#123; abstract makeSound(): void move(): void &#123; console.log('roaming the earth...') &#125;&#125; 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符。 12345678910111213141516171819202122232425262728293031323334abstract class Department &#123; name: string constructor(name: string) &#123; this.name = name &#125; printName(): void &#123; console.log('Department name: ' + this.name) &#125; abstract printMeeting(): void // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.') &#125; generateReports(): void &#123; console.log('Generating accounting reports...') &#125;&#125;let department: Department // 允许创建一个对抽象类型的引用department = new Department() // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值department.printName()department.printMeeting()department.generateReports() // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的实例的类型。 1234567891011121314class Greeter &#123; static standardGreeting = 'Hello, there' greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet() &#123; return 'Hello, ' + this.greeting &#125;&#125;let greeter: Greetergreeter = new Greeter('world')console.log(greeter.greet()) 这里，我们写了 let greeter: Greeter，意思是 Greeter 类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 我们也创建了一个叫做构造函数的值。 这个函数会在我们使用 new 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的： 12345678910111213var Greeter = /** @class */ (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return 'Hello, ' + this.greeting; &#125;; Greeter.standardGreeting = 'Hello, there'; return Greeter;&#125;());var greeter;greeter = new Greeter('world');console.log(greeter.greet()); 上面的代码里，var Greeter 将被构造函数赋值。 当我们调用 new 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有实例部分与静态部分这两个部分。 让我们稍微改写一下这个例子，看看它们之间的区别： 123456789101112131415161718192021222324252627class Greeter &#123; static standardGreeting = 'Hello, there' greeting: string constructor(message?: string) &#123; this.greeting = message &#125; greet() &#123; if (this.greeting) &#123; return 'Hello, ' + this.greeting &#125; else &#123; return Greeter.standardGreeting &#125; &#125;&#125;let greeter: Greetergreeter = new Greeter()console.log(greeter.greet())let greeterMaker: typeof Greeter = GreetergreeterMaker.standardGreeting = 'Hey there'let greeter2: Greeter = new greeterMaker()console.log(greeter2.greet()) 这个例子里， greeter1 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。 再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取 Greeter 类的类型，而不是实例的类型。或者更确切的说，”告诉我 Greeter 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker 上使用 new，创建 Greeter 的实例。 把类当做接口使用如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point &#123; x: number y: number&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125; 函数函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。 基本示例和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。 通过下面的例子可以迅速回想起这两种 JavaScript 中的函数： 123456789// 命名函数function add(x, y) &#123; return x + y&#125;// 匿名函数let myAdd = function(x, y) &#123; return x + y;&#125; 在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。 12345let z = 100function addToZ(x, y) &#123; return x + y + z&#125; 函数类型为函数定义类型让我们为上面那个函数添加类型： 1234567function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function(x: number, y: number): number &#123; return x + y&#125; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。 书写完整函数类型现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。 1234let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y&#125; 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写： 1234let myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number &#123; return x + y&#125; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void 而不能留空。 函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。 推断类型尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型： 12345678let myAdd = function(x: number, y: number): number &#123; return x + y&#125;let myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) &#123; return x + y&#125; 这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。 可选参数和默认参数TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + ' ' + lastName;&#125;let result1 = buildName('Bob') // Error, 参数过少let result2 = buildName('Bob', 'Adams', 'Sr.'); // Error, 参数过多let result3 = buildName('Bob', 'Adams'); // OK JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的： 12345678910function buildName(firstName: string, lastName?: string): string &#123; if (lastName) return firstName + ' ' + lastName else return firstName&#125;let result1 = buildName('Bob'); // 现在正常了let result2 = buildName('Bob', 'Adams', 'Sr.') // Error, 参数过多let result3 = buildName('Bob', 'Adams') // OK 可选参数必须跟在必须参数后面。 如果上例我们想让 firstName 是可选的，那么就必须调整它们的位置，把 firstName 放在后面。 在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把lastName 的默认值设置为 &quot;Smith&quot;。 12345678function buildName(firstName: string, lastName = 'Smith'): string &#123; return firstName + ' ' + lastName&#125;let result1 = buildName('Bob') // 返回 \"Bob Smith\"let result2 = buildName('Bob', undefined) // 正常, 同样 \"Bob Smith\"let result3 = buildName('Bob', 'Adams', 'Sr.') // 错误, 参数过多let result4 = buildName('Bob', 'Adams') // OK 与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写最后一个例子，让 firstName 是带默认值的参数： 12345678function buildName(firstName = 'Will', lastName: string): string &#123; return firstName + ' ' + lastName&#125;let result1 = buildName('Bob') // Error, 参数过少let result2 = buildName('Bob', 'Adams', \"Sr.\") // Error, 参数过多let result3 = buildName('Bob', 'Adams') // OK， 返回 \"Bob Adams\"let result4 = buildName(undefined, 'Adams') // OK， 返回 \"Will Adams\" 剩余参数必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。 在 TypeScript 里，你可以把所有参数收集到一个变量里： 12345function buildName(firstName: string, ...restOfName: string[]): string &#123; return firstName + ' ' + restOfName.join(' ')&#125;let employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie') 剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。 这个省略号也会在带有剩余参数的函数类型定义上使用到： 12345function buildName(firstName: string, ...restOfName: string[]): string &#123; return firstName + ' ' + restOfName.join(' ')&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName this学习如何在 JavaScript 里正确使用 this 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 this 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 this 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 Understanding JavaScript Function Invocation and “this”。 Yehuda 的文章详细的阐述了 this 的内部工作原理，因此我们这里只做简单介绍。 this 和箭头函数JavaScript里，this 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 下面看一个例子： 1234567891011121314151617let deck = &#123; suits: ['hearts', 'spades', 'clubs', 'diamonds'], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52) let pickedSuit = Math.floor(pickedCard / 13) return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125; &#125; &#125;&#125;let cardPicker = deck.createCardPicker()let pickedCard = cardPicker()console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit) 可以看到 createCardPicker 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 createCardPicker 返回的函数里的 this 被设置成了 global 而不是 deck 对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this 视为 global。 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的deck 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 this 值，而不是调用时的值： 123456789101112131415161718let deck = &#123; suits: ['hearts', 'spades', 'clubs', 'diamonds'], cards: Array(52), createCardPicker: function() &#123; // 注意：这里使用箭头函数 return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52) let pickedSuit = Math.floor(pickedCard / 13) return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125; &#125; &#125;&#125;let cardPicker = deck.createCardPicker()let pickedCard = cardPicker()console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit) this 参数在上述的例子中 this.suits[pickedSuit] 的类型为 any，这是因为 this 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this 参数。 this 参数是个假的参数，它出现在参数列表的最前面： 123function f(this: void) &#123; // 确保“this”在此独立函数中不可用&#125; 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： 123456789101112131415161718192021222324252627282930interface Card &#123; suit: string card: number&#125;interface Deck &#123; suits: string[] cards: number[] createCardPicker (this: Deck): () =&gt; Card&#125;let deck: Deck = &#123; suits: ['hearts', 'spades', 'clubs', 'diamonds'], cards: Array(52), // NOTE: 函数现在显式指定其被调用方必须是 deck 类型 createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52) let pickedSuit = Math.floor(pickedCard / 13) return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125; &#125; &#125;&#125;let cardPicker = deck.createCardPicker()let pickedCard = cardPicker()console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit) 现在 TypeScrip t知道 createCardPicker 期望在某个 Deck 对象上调用。也就是说 this 是 Deck 类型的，而非 any。 this 参数在回调函数里你可以也看到过在回调函数里的 this 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，this 将为 undefined。 稍做改动，你就可以通过 this 参数来避免错误。 首先，库函数的作者要指定 this 的类型： 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void&#125; this: void 意味着 addClickListener 期望传入的 onclick 方法不需要 this 1234567891011121314151617181920interface UIElement &#123; addClickListener (onclick: (this: void, e: Event) =&gt; void): void&#125;class Handler &#123; type: string onClickBad (this: Handler, e: Event) &#123; this.type = e.type &#125;&#125;let h = new Handler()let uiElement: UIElement = &#123; addClickListener () &#123; &#125;&#125;uiElement.addClickListener(h.onClickBad) // error! 指定了 this 类型后，你显式声明 onClickBad 必须在 Handler 的实例上调用。 然后 TypeScript 会检测到 addClickListener 要求函数带有 this: void。 改变 this 类型来修复这个错误： 12345678910111213141516class Handler &#123; type: string; onClickBad (this: void, e: Event) &#123; console.log('clicked!') &#125;&#125;let h = new Handler()let uiElement: UIElement = &#123; addClickListener () &#123; &#125;&#125;uiElement.addClickListener(h.onClickBad) 因为 onClickGood 指定了 this 类型为 void，因此传递 addClickListener 是合法的。 当然了，这也意味着不能使用 this.info。 如果你两者都想要，你不得不使用箭头函数了： 123456class Handler &#123; type: string onClickGood = (e: Event) =&gt; &#123; this.type = e.type &#125;&#125; 这是可行的因为箭头函数不会捕获 this，所以你总是可以把它们传给期望 this: void 的函数。 重载JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。 12345678910111213141516171819202122let suits = ['hearts', 'spades', 'clubs', 'diamonds']function pickCard(x): any &#123; if (Array.isArray(x)) &#123; let pickedCard = Math.floor(Math.random() * x.length) return pickedCard &#125; else if (typeof x === 'number') &#123; let pickedSuit = Math.floor(x / 13) return &#123; suit: suits[pickedSuit], card: x % 13 &#125; &#125;&#125;let myDeck = [ &#123; suit: 'diamonds', card: 2 &#125;, &#123; suit: 'spades', card: 10 &#125;, &#123; suit: 'hearts', card: 4 &#125;]let pickedCard1 = myDeck[pickCard(myDeck)];console.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)let pickedCard2 = pickCard(15)console.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit) pickCard 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard 函数。 12345678910111213141516171819202122232425let suits = ['hearts', 'spades', 'clubs', 'diamonds']function pickCard(x: &#123;suit: string; card: number &#125;[]): numberfunction pickCard(x: number): &#123;suit: string; card: number &#125;function pickCard(x): any &#123; if (Array.isArray(x)) &#123; let pickedCard = Math.floor(Math.random() * x.length) return pickedCard &#125; else if (typeof x === 'number') &#123; let pickedSuit = Math.floor(x / 13) return &#123; suit: suits[pickedSuit], card: x % 13 &#125; &#125;&#125;let myDeck = [ &#123; suit: 'diamonds', card: 2 &#125;, &#123; suit: 'spades', card: 10 &#125;, &#123; suit: 'hearts', card: 4 &#125;]let pickedCard1 = myDeck[pickCard(myDeck)];console.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)let pickedCard2 = pickCard(15)console.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit) 这样改变后，重载的 pickCard 函数在调用的时候会进行正确的类型检查。 为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。 注意，function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 pickCard 会产生错误。 泛型软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 基础示例下面来创建第一个使用泛型的例子：identity 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo 命令。 不用泛型的话，这个函数可能是下面这样： 123function identity(arg: number): number &#123; return arg&#125; 或者，我们使用 any 类型来定义函数： 123function identity(arg: any): any &#123; return arg&#125; 使用 any 类型会导致这个函数可以接收任何类型的 arg 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。 123function identity&lt;T&gt;(arg: T): T &#123; return arg&#125; 我们给 identity 添加了类型变量 T。 T 帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。 我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。 我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数： 1let output = identity&lt;string&gt;('myString') 这里我们明确的指定了 T 是 string 类型，并做为一个参数传给函数，使用了 &lt;&gt; 括起来而不是 ()。 第二种方法更普遍。利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定 T 的类型： 1let output = identity('myString') 注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看 myString 的值，然后把 T 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 T 的类型，在一些复杂的情况下，这是可能出现的。 使用泛型变量使用泛型创建像 identity 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。 看下之前 identity 例子： 123function identity&lt;T&gt;(arg: T): T &#123; return arg&#125; 如果我们想打印出 arg 的长度。 我们很可能会这样做： 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length) return arg&#125; 如果这么做，编译器会报错说我们使用了 arg 的 .length 属性，但是没有地方指明 arg 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length 属性的。 现在假设我们想操作 T 类型的数组而不直接是 T。由于我们操作的是数组，所以 .length 属性是应该存在的。我们可以像创建其它数组一样创建这个数组： 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length) return arg&#125; 你可以这样理解 loggingIdentity 的类型：泛型函数 loggingIdentity，接收类型参数 T 和参数 arg，它是个元素类型是 T 的数组，并返回元素类型是T 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 T 的的类型为 number。 这可以让我们把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。 泛型类型上一节，我们创建了 identity 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样： 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity 我们还可以使用带有调用签名的对象字面量来定义泛型函数： 12345function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity 这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口： 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn = identity 我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： Dictionary&lt;string&gt; 而不只是Dictionary）。这样接口里的其它成员也能知道这个参数的类型了。 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity 注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn 的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。 除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;()myGenericNumber.zeroValue = 0myGenericNumber.add = function(x, y) &#123; return x + y &#125; GenericNumber 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 number 类型。 也可以使用字符串或其它更复杂的类型。 1234567let stringNumeric = new GenericNumber&lt;string&gt;()stringNumeric.zeroValue = ''stringNumeric.add = function(x, y) &#123; return x + y&#125;console.log(stringNumeric.add(stringNumeric.zeroValue, 'test')) 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 泛型约束我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 loggingIdentity 例子中，我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length) return arg&#125; 相比于操作 any 所有类型，我们想要限制函数去处理任意带有 .length 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 T 的约束要求。 我们定义一个接口来描述约束条件，创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束： 12345678interface Lengthwise &#123; length: number&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length) // OK return arg&#125; 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型： 1loggingIdentity(3); // Error 我们需要传入符合约束类型的值，必须包含必须的属性： 1loggingIdentity(&#123;length: 10, value: 3&#125;) // OK 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj 上，因此我们需要在这两个类型之间使用约束。 12345678function getProperty&lt;T, K extends keyof T&gt; (obj: T, key: K ) &#123; return obj[key]&#125;let x = &#123;a: 1, b: 2, c: 3, d: 4&#125;getProperty(x, 'a') // okaygetProperty(x, 'm') // error 类型推断这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。 基础TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子： 1let x = 3 变量 x 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。 最佳通用类型有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如， 1let x = [0, 1, null] 为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如： 1234567891011class Animal &#123; numLegs: number&#125;class Bee extends Animal &#123;&#125;class Lion extends Animal &#123;&#125;let zoo = [new Bee(), new Lion()] 这里，我们想让 zoo 被推断为 Animal[] 类型，但是这个数组里没有对象是 Animal 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型： 1let zoo: Animal[] = [new Bee(), new Lion()] 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(Bee | Lion)[] 上下文类型有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如： 123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.clickTime) // Error&#125; 这个例子会得到一个类型错误，TypeScript 类型检查器使用 window.onmousedown 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent 参数的类型了，所以 mouseEvent 访问了一个不存在的属性，就报错了。 如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子： 123window.onmousedown = function(mouseEvent:any) &#123; console.log(mouseEvent.clickTime) // OK&#125; 这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。 上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如： 12345function createZoo(): Animal[] &#123; return [new Bee(), new Lion()]&#125;let zoo = createZoo() 这个例子里，最佳通用类型有 3 个候选者：Animal，Bee 和 Lion。 其中，Animal 会被做为最佳通用类型。 高级类型交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，Person &amp; Loggable 同时是 Person 和 Loggable。 就是说这个类型的对象同时拥有了这两种类型的成员。 我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子： 12345678910111213141516171819202122232425262728293031function extend&lt;T, U&gt; (first: T, second: U): T &amp; U &#123; let result = &#123;&#125; as T &amp; U for (let id in first) &#123; result[id] = first[id] as any &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; result[id] = second[id] as any &#125; &#125; return result&#125;class Person &#123; constructor (public name: string) &#123; &#125;&#125;interface Loggable &#123; log (): void&#125;class ConsoleLogger implements Loggable &#123; log () &#123; // ... &#125;&#125;var jim = extend(new Person('Jim'), new ConsoleLogger())var n = jim.namejim.log() 联合类型联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number 或 string 类型的参数。 例如下面的函数： 1234567891011function padLeft(value: string, padding: any) &#123; if (typeof padding === 'number') &#123; return Array(padding + 1).join(' ') + value &#125; if (typeof padding === 'string') &#123; return padding + value &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`)&#125;padLeft('Hello world', 4) // returns \" Hello world\" padLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错。 1let indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错 为了解决这个问题，我们可以使用 联合类型做为 padding 的参数： 12345function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft('Hello world', true) // 编译阶段报错 联合类型表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以 number | string 表示一个值可以是 number 或 string。 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 1234567891011121314151617interface Bird &#123; fly() layEggs()&#125;interface Fish &#123; swim() layEggs()&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet()pet.layEggs() // okaypet.swim() // error 这里的联合类型可能有点复杂：如果一个值的类型是 A | B，我们能够确定的是它包含了 A 和 B 中共有的成员。这个例子里，Fish 具有一个 swim 方法，我们不能确定一个 Bird | Fish 类型的变量是否有 swim方法。 如果变量在运行时是 Bird 类型，那么调用 pet.swim() 就出错了。 类型保护联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。 12345678let pet = getSmallPet()// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim()&#125; else if (pet.fly) &#123; pet.fly()&#125; 为了让这段代码工作，我们要使用类型断言： 1234567let pet = getSmallPet()if ((pet as Fish).swim) &#123; (pet as Fish).swim()&#125; else &#123; (pet as Bird).fly()&#125; 用户自定义的类型保护这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型的话就好了。 TypeScript 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (pet as Fish).swim !== undefined&#125; 在这个例子里，pet is Fish 就是类型谓词。谓词为 parameterName is Type 这种形式， parameterName 必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish 时，TypeScript 会将变量缩减为那个具体的类型。 123456if (isFish(pet)) &#123; pet.swim()&#125;else &#123; pet.fly()&#125; 注意 TypeScript 不仅知道在 if 分支里 pet 是 Fish 类型；它还清楚在 else 分支里，一定不是 Fish类型而是 Bird 类型。 typeof 类型保护现在我们回过头来看看怎么使用联合类型书写 padLeft 代码。我们可以像下面这样利用类型断言来写： 1234567891011121314151617function isNumber (x: any):x is string &#123; return typeof x === 'number'&#125;function isString (x: any): x is string &#123; return typeof x === 'string'&#125;function padLeft (value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(' ') + value &#125; if (isString(padding)) &#123; return padding + value &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`)&#125; 然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 typeof x === &#39;number&#39;抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。 123456789function padLeft (value: string, padding: string | number) &#123; if (typeof padding === 'number') &#123; return Array(padding + 1).join(' ') + value &#125; if (typeof padding === 'string') &#123; return padding + value &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`)&#125; 这些 typeof 类型保护只有两种形式能被识别：typeof v === &quot;typename&quot; 和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;，&quot;boolean&quot; 或 &quot;symbol&quot;。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。 instanceof 类型保护如果你已经阅读了 typeof 类型保护并且对 JavaScript 里的 instanceof 操作符熟悉的话，你可能已经猜到了这节要讲的内容。 instanceof 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造： 1234567891011121314151617181920212223242526272829303132class Bird &#123; fly () &#123; console.log('bird fly') &#125; layEggs () &#123; console.log('bird lay eggs') &#125;&#125;class Fish &#123; swim () &#123; console.log('fish swim') &#125; layEggs () &#123; console.log('fish lay eggs') &#125;&#125;function getRandomPet () &#123; return Math.random() &gt; 0.5 ? new Bird() : new Fish()&#125;let pet = getRandomPet()if (pet instanceof Bird) &#123; pet.fly()&#125;if (pet instanceof Fish) &#123; pet.swim()&#125; 可以为 null 的类型TypeScript 具有两种特殊的类型，null 和 undefined，它们分别具有值 null 和 undefined。我们在基础类型一节里已经做过简要说明。 默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。 null 与 undefined 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。null的发明者，Tony Hoare，称它为价值亿万美金的错误。 --strictNullChecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。 你可以使用联合类型明确的包含它们： 123456let s = 'foo's = null // 错误, 'null'不能赋值给'string'let sn: string | null = 'bar'sn = null // 可以sn = undefined // error, 'undefined'不能赋值给'string | null' 注意，按照 JavaScript 的语义，TypeScript 会把 null 和 undefined 区别对待。string | null，string | undefined 和 string | undefined | null 是不同的类型。 可选参数和可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0)&#125;f(1, 2)f(1)f(1, undefined)f(1, null) // error, 'null' 不能赋值给 'number | undefined' 可选属性也会有同样的处理： 12345678910class C &#123; a: number b?: number&#125;let c = new C()c.a = 12c.a = undefined // error, 'undefined' 不能赋值给 'number'c.b = 13c.b = undefined // okc.b = null // error, 'null' 不能赋值给 'number | undefined' 类型保护和类型断言由于可以为 null 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 null。幸运地是这与在 JavaScript 里写的代码一致： 1234567function f(sn: string | null): string &#123; if (sn === null) &#123; return 'default' &#125; else &#123; return sn &#125;&#125; 这里很明显地去除了 null，你也可以使用短路运算符： 123function f(sn: string | null): string &#123; return sn || 'default'&#125; 如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。语法是添加 ! 后缀： identifier! 从 identifier 的类型里去除了 null 和 undefined： 1234567891011121314151617function broken(name: string | null): string &#123; function postfix(epithet: string) &#123; return name.charAt(0) + '. the ' + epithet // error, 'name' 可能为 null &#125; name = name || 'Bob' return postfix('great')&#125;function fixed(name: string | null): string &#123; function postfix(epithet: string) &#123; return name!.charAt(0) + '. the ' + epithet // ok &#125; name = name || 'Bob' return postfix('great')&#125;broken(null) 本例使用了嵌套函数，因为编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 name 的类型。 字符串字面量类型字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。 1234567891011121314151617type Easing = 'ease-in' | 'ease-out' | 'ease-in-out'class UIElement &#123; animate (dx: number, dy: number, easing: Easing) &#123; if (easing === 'ease-in') &#123; // ... &#125; else if (easing === 'ease-out') &#123; &#125; else if (easing === 'ease-in-out') &#123; &#125; else &#123; // error! 不能传入 null 或者 undefined. &#125; &#125;&#125;let button = new UIElement()button.animate(0, 0, 'ease-in')button.animate(0, 0, 'uneasy') // error 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 1Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39; 总结那么到这里，我们的 TypeScript 常用语法学习就告一段落了，当然 TypeScript 还有其他的语法我们并没有讲，我们只是讲了 TypeScript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 TypeScript 开发项目中遇到了其他的 TypeScript 语法知识，你可以通过 TypeScript 的官网文档学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"初识 TypeScript","slug":"tech/typeScript/ts-init","date":"2020-02-05T04:24:11.047Z","updated":"2020-02-05T04:24:11.047Z","comments":true,"path":"2020/02/05/tech/typeScript/ts-init/","link":"","permalink":"http://yoursite.com/2020/02/05/tech/typeScript/ts-init/","excerpt":"","text":"初识 TypeScriptTypeScript 作为 JavaScript 语言的超集，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。 TypeScript 的特点TypeScript 主要有 3 大特点： 始于JavaScript，归于JavaScript TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。 强大的工具构建大型应用程序 类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。 类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。 先进的 JavaScript TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。 这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。 总结TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。都 2019 年了，如果你还没有开始学习 TypeScript，那么你可能要落后了哟，所以还等什么，快来和我一起学习并使用 TypeScript 吧，来感受一下它为我们带来的奇妙体验。 安装 TypeScript命令行运行如下命令，全局安装 TypeScript： 1npm install -g typescript 安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)： 1tsc -V 编写第一个 TypeScript 程序在编辑器，将下面的代码输入到 greeter.ts 文件里： 1234567function greeter (person) &#123; return 'Hello, ' + person&#125;let user = 'Yee'console.log(greeter(user)) 编译代码我们使用了 .ts 扩展名，但是这段代码仅仅是 JavaScript 而已。 在命令行上，运行 TypeScript 编译器： 1tsc greeter.ts 输出结果为一个 greeter.js 文件，它包含了和输入文件中相同的 JavsScript 代码。 在命令行上，通过 Node.js 运行这段代码： 1node greeter.js 控制台输出： 1Hello, Yee 类型注解接下来让我们看看 TypeScript 工具带来的高级功能。 给 person 函数的参数添加 : string 类型注解，如下： 1234567function greeter (person: string) &#123; return 'Hello, ' + person&#125;let user = 'Yee'console.log(greeter(user)) TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组： 1234567function greeter (person: string) &#123; return 'Hello, ' + person&#125;let user = [0, 1, 2]console.log(greeter(user)) 重新编译，你会看到产生了一个错误： 1error TS2345: Argument of type &#39;number[]&#39; is not assignable to parameter of type &#39;string&#39;. 类似地，尝试删除 greeter 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。 接口让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 firstName 和 lastName 字段的对象。 在 TypeScript 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。 123456789101112131415interface Person &#123; firstName: string lastName: string&#125;function greeter (person: Person) &#123; return 'Hello, ' + person.firstName + ' ' + person.lastName&#125;let user = &#123; firstName: 'Yee', lastName: 'Huang'&#125;console.log(greeter(user)) 类最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。 让我们创建一个 User 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。 还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。 123456789101112131415161718192021222324class User &#123; fullName: string firstName: string lastName: string constructor (firstName: string, lastName: string) &#123; this.firstName = firstName this.lastName = lastName this.fullName = firstName + ' ' + lastName &#125;&#125;interface Person &#123; firstName: string lastName: string&#125;function greeter (person: Person) &#123; return 'Hello, ' + person.firstName + ' ' + person.lastName&#125;let user = new User('Yee', 'Huang')console.log(greeter(user)) 重新运行 tsc greeter.ts，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 JavaScript 函数的实现。 总结到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"NPM 相关知识点","slug":"tech/npm-all-about","date":"2020-02-04T08:24:47.406Z","updated":"2020-02-04T08:24:47.406Z","comments":true,"path":"2020/02/04/tech/npm-all-about/","link":"","permalink":"http://yoursite.com/2020/02/04/tech/npm-all-about/","excerpt":"","text":"原文链接：you don’t know npm nodejs 社区乃至 Web 前端工程化领域发展到今天，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但是现实状况是，我们很多人对这个 nodejs 基础设施的使用和了解还停留在：会用 npm install 这里（一言不合就删除整个 node_modules 目录然后重新 install） 当然 npm 能成为现在世界上最大规模的包管理系统，很大程度上确实归功于它足够用户友好，你即使只会执行 install 也不必担心出大问题。但是 npm 的功能远不止于 install 这么简单。一下对 npm 的原理、特性、技巧以及最佳实践做一些归纳总结。 1. npm init我们都知道 package.json 文件是用来定义一个 package 的面熟文件，也知道 npm init 命令用来初始化一个简单的 package.json 文件，执行该命令后中断一次询问 name、version、description 等字段。 1.1 npm init 执行默认行为而如果想要免去一直按 enter，只需要在命令后追加 –yes 参数即可执行默认行为。 npm init --yes 1.2 自定义 npm init 行为npm init 命令的原理并不复杂，调用脚本，输出一个初始化的 package.json 文件。所有相应的，定制 npm init 命令的实现方式也不浮躁，在 Home 目录下创建一个 .npm-init.js 即可，该文件的 module.exports 即为 package.json 的配置内容，需要获取用户输入时，使用 prompt() 方法即可。 例如编写如下 ~/.npm-init.js 12345678910111213141516const desc = prompt('description?', 'A new package...');const bar = prompt('bar?', '');const count = prompt('count?', '100');module.exports = &#123; key: 'value', foo: &#123; bar: bar, count: count &#125;, // process.cwd() 获取当前被执行的 js 文件的工作目录 name: prompt('name?', process.cwd().split('/').pop()), version: prompt('version?', '0.1.0'), description: desc, main: 'index.js'&#125;; 此时在 ~/npm-all-about 目录下执行 npm init 将会生成这样的 package.json: 1234567891011&#123; \"key\": \"value\", \"foo\": &#123; \"bar\": \"\", \"count\": \"100\" &#125;, \"name\": \"npm-all-about\", \"version\": \"0.1.0\", \"description\": \"A new package...\", \"main\": \"index.js\"&#125; 因为 .npm-init.js 是一个常规的模块，所以意味着，除了生成 package.json，我们可以执行任何 node 脚本来完成一些任务。例如通过 fs 创建 README、.eslintrc 等项目必需文件，实现项目脚手架的作用。 2. 依赖包安装依赖管理是 npm 的核心功能，原理是执行 npm install 从 package.json 中的 dependencies、devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。 2.1 package 定义我们知道，要手动安装一个依赖包时，执行 npm install &lt;package&gt; 命令即可。这里的第三个参数 package 通常就是所需要安装的包名，默认配置下 npm 会从默认的源（Registry）中查找该包名对应的报地址，并下载安装。但除了可以简单地指定包名以外，package 还可以是一个执行有效包名的 http url/git url/ 文件夹路径。 阅读 npm 文档，我们会发现 package 的准确订阅，只要符合以下a)到g)其中之一条件，就是一个 package: id 说明 例子 a) 一个包含了程序和描述该程序的 package.json 文件的 文件夹 ./local-module/ b) 一个包含了(a)的 gzip 压缩文件 ./module.tar.gz c) 一个可以下载的(b)资源的 url(通常是 http(s) url) https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz d) 一个格式为 &lt;name&gt;@&lt;version&gt; 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件(c) webpack@4.1.0 e) 一个格式为 &lt;name&gt;@&lt;tag&gt; 的字符串，在 npm 源上该 &lt;tag&gt; 指向某个 &lt;version&gt; 得到 &lt;name&gt;@&lt;version&gt;，后者满足条件(d) webpack@latest f) 一个格式为 &lt;name&gt; 的字符串，默认添加 latest 标签所得到的 &lt;name&gt;@latest 满足条件(e) webpack g) 一个 git url，该 url 所指向的代码库满足条件(a) git@github.com:webpack/webpack.git 2.2 安装本地包/远程 git 仓库包上面表格的订阅意味着，我们在共享依赖包时，并不是非要将包发表到 npm 源上才可以提供给用着来安装。这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源进行改造，但依然需要把包共享出去的场景来说是非常实用的。 场景1: 本地模块引用 nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能遇到这样的代码： 1const config = require('../../../../config.js'); 除了看上去不直观以外，这样的路径引用也不利于代码的重构。这样的重复代码多了也就意味着是时候把这个模块分离除了供应用中其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块使用。 无需手动开吧文件或者创建软连接到 node_modules 目录，npm 有更优雅的解决方案。 方案： 创建 config 包：新增 config 文件夹；重命名 config.js 为 config/index.js 文件；创建 package.json 定义 config 包。 12345&#123; \"name\": \"config\", \"main\": \"index.js\", \"version\": \"0.1.0\"&#125; 在应用层 package.json 文件中新增依赖项，然后执行 npm install；或直接执行第3步。 12345&#123; \"dependencies\": &#123; \"config\": \"file:./config\" &#125;&#125; (等价于第2步) 直接在应用目录执行 npm install file:./config。 此时，查看 node_modules 目录我们会发现多了一个名为 config 的依赖包，指向上层 config/ 文件夹的软连接。这是因为 npm 识别 file: 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软连接到 node_modules 中，完成 “安装”过程。 相比手动软连接，我们既不需要关系 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 npm install 后直接使用。 场景2: 私有 git 共享 package 有些时候，我们一个团队内会有一些代码/公用库需要在团队内不同项目间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源上。 这种情况，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将 git url 保存到 dependencies 中。npm 会直接调用系统的 git 命令，从 git 仓库拉取包的内容到 node_modules 中。 npm 支持的 git url 格式: 1&lt;protocol&gt;:&#x2F;&#x2F;[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][&#x2F;]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;] git 路径后可以使用 # 指定特定的 git branch/commit/tag，也可以 #semver: 指定特定的 semver range。 semver（语义化版本）约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本\b号.小版本号.修订版本号. 例如： 1234git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm.git#v1.0.27git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm#semver:^5.0git+https:&#x2F;&#x2F;isaacs@github.com&#x2F;npm&#x2F;npm.gitgit:&#x2F;&#x2F;github.com&#x2F;npm&#x2F;npm.git#v1.0.27 场景3: 开源 package 问题修复 使用某个 npm 包时发现他有某个严重的 bug，但或许最初坐着已不再维护代码了，又或许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。 此时我们可以手动进入 node_modules 目录下修改相应的内容，也许修改了一行代码就修复了问题。但是这种做法非常不明智！ 首先 node_modules 本身不应该放进版本控制系统，对 node_modules 文件夹中内容的修改不会被记录进 git 提交记录了；其次，就算我们非要反模式，把 node_modules 放进版本控制中，你的修改内容也很容易在下次 team 中某个成员执行 npm install 或 npm update 时被覆盖，而这样的一次提交很可能包含了几十几百个包的更新，你自己所做的修改很容易就被淹没在庞大的 diff 文件列表中了，让版本控制变得非常不合理。 方案： 最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖更改为自己修复后版本的 git url 即可解决问题。（fork 代码库后，也便于向原作者体检 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。） 3. npm install 如何工作 – node_modules 目录结构npm install 执行完毕后，我们可以在 node_modules 中看到所有的依赖包。虽然使用者无需关注这个目录里的文件结构细节，只管在业务代码中引用依赖包即可，但了解 node_modules 的内容可以帮我们更好地理解 npm 如何工作，了解 npm2 到 npm5 有哪些变化和该井。 为简单起见，假设应用目录为 app，用两个流行的包 webpack、nconf 作为依赖包做实例说明。并且为了正常安装，使用了 npm2 时期的版本 webpack@1.15.0、nconf@0.8.5。 3.1 npm2npm2 在安装依赖包时，采用简单的递归安装方法。执行 npm install 后，npm2 依次递归安装 webpack、nconf 两个包到 node_modules 中。执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录。 123node_modules&#x2F;├── nconf&#x2F;└── webpack&#x2F; 进入更深一层 nconf 或者 webpack 目录，将看到这两个包各自的 node_modules 中，已经由 npm 递归安装好了自身的依赖包。包括 ./node_modules/webpack/node_modules/webpack-core，./node_modules/conf/node_modules/async 等等。而每一个包都有自己的依赖包，每个包自己的依赖都安装在了自己的 node_modules 中。依赖关系层层递进，构成一整个依赖树，这个依赖树与文件系统中的问价结构树刚好层层对应。 最方便的查看依赖树的方式是直接在 app 目录下执行 npm ls 命令。 12345678910111213141516171819app@0.1.0├─┬ nconf@0.8.5│ ├── async@1.5.2│ ├── ini@1.3.5│ ├── secure-keys@1.0.0│ └── yargs@3.32.0└─┬ webpack@1.15.0 ├── acorn@3.3.0 ├── async@1.5.2 ├── clone@1.0.3 ├── ... ├── optimist@0.6.1 ├── supports-color@3.2.3 ├── tapable@0.1.10 ├── uglify-js@2.7.5 ├── watchpack@0.2.9 └─┬ webpack-core@0.6.9 ├── source-list-map@0.1.8 └── source-map@0.4.4 这样的目录结构优点在于层级结构明显，便于进行傻瓜式的管理： 例如新增一个依赖包，可以立即在第一层 node_modules 中看到子目录。 在已知所需要包名和版本号时，甚至可以从别的文件夹手动拷贝需要的包到 node_modules 文件夹中，再手动修改 package.json 中的依赖配置。 要删除这个包，也可以简单地手动删除这个包的子目录，斌删除 package.json 文件中相对应的一行即可。 实际上，很多人在 npm2 时代也的确这样实践过，的确也都可以安装和删除成功，并不会导致什么差错。 但这样的文件结构也有很明显的问题： 对复杂的工程，node_module 内目录结构可能会太深，导致深层的文件路径过长而触发 windows 文件系统中，文件路径不能超过260个字符长度的限制。 部分被多个包所依赖的包，很可能在应用 node_modules 目录中的很多地方被重复安装。随着工程规模越来越多，依赖树越来越复杂，这样的包情况会越来越多，造成大量冗余。 ————在这个示例中,webpack 和 nconf 都依赖 async 这个包，所以在文件系统中，webpack 和 nconf 的 node_modules 子目录中都安装了相同的 async 包，并且是相同的版本。 1234567891011121314+-------------------------------------------+| app&#x2F; |+----------+------------------------+-------+ | | | |+----------v------+ +---------v-------+| | | || webpack@1.15.0 | | nconf@0.8.5 || | | |+--------+--------+ +--------+--------+ | | +-----v-----+ +-----v-----+ |async@1.5.2| |async@1.5.2| +-----------+ +-----------+ 3.2 npm3-扁平结构主要为了解决以上问题，npm3 的 node_modules 目录改成； 更加扁平的层级结构。文件系统中 webpack、nconf、async 的层级关系变成了平级关系，处于同一级目录中。 12345678910 +-------------------------------------------+ | app&#x2F; | +-+---------------------------------------+-+ | | | |+----------v------+ +-------------+ +---------v-------+| | | | | || webpack@1.15.0 | | async@1.5.2 | | nconf@0.8.5 || | | | | |+-----------------+ +-------------+ +-----------------+ 虽然这样一来 webpack/node_modules 和 nconf/node_modules 中都不再有 async 文件夹，但得益于 node 的模块加载机制，他们都可以在上一级 node_modules 目录中找到 async 库。所以 webpack 和 nconf 的代码库中 require(&#39;async&#39;) 语句的执行都不会有任何问题。 这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况，npm3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。 npm 文档提供了更直接的例子解释这种情况： 加入 package{dep} 写法代表包和包的依赖，那么 A{B, C}，B{C}，C{D} 的依赖结构在安装之后的 node_modules 是这样的结构： 1234A+-- B+-- C+-- D 这里之所以 D 也安装到了与 B C 同一级目录，是因为 npm 默认会在无冲突的前提下，尽可能地将包安装到较高的层级。 如果是 A{B, C}，B{C, D@1}，C{D@2} 的依赖关系，得到的安装后结构是： 12345A+-- B+-- C +-- D@2+-- D@1 这里是因为，对与 npm 来说，同名但不同版本的包是两个独立的包，而同层不能有两个同名子目录，所以其中的 D@2 放到了 C 的子目录而另一个 D@1 被放到了再上一层的目录。 很明显在 npm3 之后 npm 的依赖树结构不再与文件夹层级一一对应了。想要查看 app 的直接依赖项，需要通过 npm ls 命令指定 --depth 参数来查看： 1npm ls --depth 1 PS：与本地依赖包把不同，如果我们通过 npm install --global 全局安装依赖包到全局目录时，得到的目录依然是”传统的”目录结构。而如果使用 npm3 想得到”传统”形式的本地 node_modules 目录，使用 npm install --global-style 即可。 3.3 npm5-package-lock 文件npm5 发布与 2017 年，也是目前最新的 npm 版本，这一版本依然沿用 npm3 之后扁平化的依赖包安装方式，此外最大的变化时增加了 package-lock.json 文件。 package-lock.json 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件结构是一一对应的。 以依赖关系为：app{webpack} 的 ‘app’ 项目为例，其 package-lock 文件包含这样的片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; \"name\": \"app\", \"version\": \"0.1.0\", \"lockfileVersion\": 1, \"requires\": true, \"dependencies\": &#123; \"webpack\": &#123; \"version\": \"1.8.11\", \"resolved\": \"https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz\", \"integrity\": \"sha1-Yu0hnstBy/qcKuanu6laSYtgkcI=\", \"requires\": &#123; \"async\": \"0.9.2\", \"clone\": \"0.1.19\", \"enhanced-resolve\": \"0.8.6\", \"esprima\": \"1.2.5\", \"interpret\": \"0.5.2\", \"memory-fs\": \"0.2.0\", \"mkdirp\": \"0.5.1\", \"node-libs-browser\": \"0.4.3\", \"optimist\": \"0.6.1\", \"supports-color\": \"1.3.1\", \"tapable\": \"0.1.10\", \"uglify-js\": \"2.4.24\", \"watchpack\": \"0.2.9\", \"webpack-core\": \"0.6.9\" &#125; &#125;, \"webpack-core\": &#123; \"version\": \"0.6.9\", \"resolved\": \"https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz\", \"integrity\": \"sha1-/FcViMhVjad76e+23r3Fo7FyvcI=\", \"requires\": &#123; \"source-list-map\": \"0.1.8\", \"source-map\": \"0.4.4\" &#125;, \"dependencies\": &#123; \"source-map\": &#123; \"version\": \"0.4.4\", \"resolved\": \"https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz\", \"integrity\": \"sha1-66T12pwNyZneaAMti092FzZSA2s=\", \"requires\": &#123; \"amdefine\": \"1.0.1\" &#125; &#125; &#125; &#125; &#125;&#125; 看懂 package-lock 文件并不难，其结构是同样类型的几个字段嵌套起来的，只要是 version，resolved，integrity，requires，dependencies 这几个字段。 version，resolved，integrity 用来记录包的准确版本号、安装源、内容 hash，决定了要安装的包的准确”身份信息。 假设不看其他字段，只关注 dependencies: {}，可以发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次机构是完全对照的。 假设只关注 requires: {}，可以发现，除去最外层的 requires 属性为 true 以外，其它层的 requires 属性都对应着这个包的 package.json 里记录自己的所有依赖项。 因为这个文件记录了 node_modules 里所有包的结构、层级和版本号，甚至安装源，它也就事实上提供了”保存” node_modules 状态的能力。只要有这样一个 lock 文件，那不管在哪一台机器上执行 npm install 都会得到完全相同的 node_modules 结果。 这就是 package-lock 文件致力于优化的场景：在从前仅仅用 package.json 记录依赖，由于 semver range 机制，一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 npm install，所得到的的 node_modules 结果很可能和一个月前 A 得到的结果存在许多差异，虽然 semver 有机制的限制，同一份 package.json 不会生成大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。 其实，相同作用的文件在 npm5 之前就有，成为 npm shrinkwrap 文件，二者作用完全相同，不同的是后者需要手动生成，而 npm5 默认会在执行 npm install 后就生成 package-lock 文件，并建议提交到 gi/svn 代码库中。 package-lock.json 文件在最初 npm5.0 默认引入时引起了相当大的争议。在 npm5.0 中，如果已有 package-lock 文件存在，若手动在 package.json 文件中新增一条依赖，再执行 npm install，新增的依赖并不会被安装到 node_modules 中，package-lock 也不会做相应的更新。这样的表现与使用者的自然期望表现不符。在 npm5.1 的首个 Release 版本中这个问题得以修复。所以这个事情告诉我吗，要升级，不要使用 npm5.0 版本。 ————但依然有反对的声音认为 package-lock 太复杂，对此 npm 也提供了禁用配置： 1npm config set package-lock false 4. 依赖包版本管理依赖包安装完并不意味着就万事大吉了，版本的维护和更新也很重要。这一章介绍依赖包升级管理相关知识。 4.1 semvernpm 依赖管理的一个重要特性是采用了语义化版本规范(semver)，作为依赖版本管理方案。 semver 约定一个包的版本号必须包含 3 个数字，格式必须为 MAJOR.MINOR.PATCH，意为 主版本号.小版本号.修订版本号。 MAJOR 对应大的版本号迭代，做了不兼容旧版本的修改时要更新 MAJOR 版本号 MINOR 对应小版本迭代，发生兼容旧版本 API 的修改或者更能更新时，更新 MINOR 版本号 PATCH 对应修订版本号，一般针对修复 BUG 的版本号 对应包作者（发布者），npm 要求在 publish 之前，必须更新版本号。npm 提供了 npm version 工具，执行 npm version major|minor|patch 可以简单地将版本号中响应的数字 +1。 如果包是一个 git 仓库，npm version 还会自动创建一条注释为更新后版本号的 git commit 和名为该版本号的 tag。 对于包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 https://semver.npmjs.com 可方便地计算所输入的表达式的匹配范围。常规的规则示例如下表： range 含义 示例 ^2.2.1 指定的 MAJOR 版本号下，所有更新的版本 匹配 2.2.3，2.3.0；不匹配 1.0.3，3.0.1 ~2.2.1 指定 MAJOR.MINOR 版本号下，所有更新的版本 匹配 2.2.3，2.2.9；不匹配 2.3.0，2.3.5 &gt;=2.1 版本号大于或等于 2.1.0 匹配 2.1.2，3.1； &lt;=2.2 版本号小于或等于 2.2 匹配 1.0.0，2.2.1，2.2.11 1.0.0 - 2.0.0 版本号从 1.0.0(包含) 到 2.0.0(包含) 匹配 1.0.0，1.3.4，2.0.0 任意两条规则，通过空格连接起来，表示”与”逻辑，即两条规则的交集： 如 &gt;=2.3.1 &lt;=2.8.0 可以解读为：&gt;=2.3.1 且 &lt;=2.8.0。 匹配 2.3.1，2.4.5，2.8.0 不匹配 1.0.0，2.3.0，2.8.1，3.0.0 任意两条规则，通过 || 连接起来，表示”或”逻辑，即两条规则的并集： 如 ^2 &gt;=2.3.1 || ^3 &gt;3.2 匹配 2.3.1，2.8.1，3.3.1 不匹配 1.0.0，2.2.0，3.1.0，4.0.0 PS：处理这几种，还有如下更直观的表示版本号范围的写法： * 或 x 匹配徐偶有主版本 1 或 1.x 匹配主版本为 1 的所有版本 1.2 或 1.2.x 匹配版本号为 1.2 开头的所有版本 PPS：在常规仅包含数字的版本号之外，semver 还允许在 MAJOR.MONOR.PATCH 后追加 - 后跟点号分隔的标签，作为预发布版本标签 - Prerelese Tags，通常被视为不稳定、不建议生产环境使用的版本。例如： 1.0.0-alpha 1.0.0-beta.1 1.0.0-rc.3 上表中我们最常见的是 ^1.8.11 这种格式的 range，因为我们使用 npm install &lt;package&gt; 安装依赖包时，npm 默认安装当前最新版本，例如 1.8.11，然后在所安装的版本号前加 ^ 号，将 ^1.8.11 写入 package.json 依赖配置，意味着可以匹配 1.8.11 以上，2.0.0 以下所有的版本。 4.2 依赖版本升级在安装完一个依赖包之后又新版本发布了，如何使用 npm 进行版本升级呢？答案很简单：npm install 或 npm update 即可。但在不同 npm 版本，不同的 package.json，package-lock.json 文件，安装升级的表现也不同。 还是以 webpack 为例，做如下前提假设: 工程项目 app 依赖 webpack 项目最初始化时，安装了当时最新的包 webpack@1.8.0，并且 package.json 中依赖配置为：&quot;webpack&quot;: &quot;^1.8.0&quot; 当前（2018年3月）webpack 最新版本为 4.2.0，webpack 1.x 的最新子版本为 1.15.0 如果我们使用的是 npm3，并且项目不包含 package-lock.json，那么根据 node_modules 是否为空，执行 install/update 结果如下（node 6.13.1, npm 3.10.10 环境下测试）： id package.json(BEFORE) node_modules(BEFORE) command(npm 3) package.json(AFTER) node_modules(AFTER) a) webpack: ^1.8.0 webpack@1.8.0 install webpack: ^1.8.0 webpack@1.8.0 b) webpack: ^1.8.0 空 install webpack: ^1.8.0 webpack@1.15.0 c) webpack: ^1.8.0 webpack@1.8.0 update webpack: ^1.8.0 webpack@1.15.0 d) webpack: ^1.8.0 空 update webpack: ^1.8.0 webpack@1.15.0 根据上表可以对 npm3 做出以下结论： 如果本地 node_modules 已安装，再次执行 install 不会更新包版本，执行 update 才会更新；而如果本地 node_modules 为空时，执行 install/update 都会直接安装更新包； npm update 总会把包更新到符合 package.json 中指定的 semver 的最新版本——本例中符合 ^1.8.0 的最新版本为 1.15.90 一旦给定 package.json，无论后面执行 npm install 还是 update，package.json 中的 webpack 版本一直保持开始的 ^1.8.0 不变 这里不合理的地方在于，如果最开始团队中第一个人安装了 webpack@1.8.0，而新加入项目的成员，checkout 工程代码后，执行 npm install 会安装得到不太一样的 1.15.0 版本。虽然 semver 约定了小版本号应当向下兼容（相同大版本号下的小版本号兼容），但万一有不熟悉不遵守此约定的包发布者，发布了不兼容的包，此时就可能出现因依赖环境不同导致的 bug。 如果我们使用的是 npm5，并且项目包含 package-lock.json 文件，那么根据 node_modules 是否为空，执行 install/update 结果如下（node 9.8.0, npm 5.7.1 环境下测试）： id package.json(BEFORE) node_modules(BEFORE) package-lock(BEFORE) command(npm 3) package.json(AFTER) node_modules(AFTER) a) webpack: ^1.8.0 webpack@1.8.0 @1.8.0 install webpack: ^1.8.0 webpack@1.8.0 b) webpack: ^1.8.0 空 @1.8.0 install webpack: ^1.8.0 webpack@1.8.0 c) webpack: ^1.8.0 webpack@1.8.0 @1.8.0 update webpack: ^1.15.0 webpack@1.15.0 d) webpack: ^1.8.0 空 @1.8.0 update webpack: ^1.8.0 webpack@1.15.0 e) webpack: ^1.15.0 webpack@1.8.0(旧) @1.15.0 update webpack: ^1.15.0 webpack@1.15.0 f) webpack: ^1.15.0 webpack@1.8.0(旧) @1.15.0 update webpack: ^1.15.0 webpack@1.15.0 与 npm3 相比，在安装和更新依赖版本上主要的区别为： 无论何时执行 install，npm 都会优先按照 package-lock 中指定的版本来安装 webpack，避免了 npm3 表中情况(b)的出现 无论何时执行 install/update，package-lock 文件总会跟着 node_modules 更新（因此可以视 package-lock 文件为 node_modules 的 JSON 表述） 已安装 node_modules 后若执行 npm update，package.json 中版本号也会随之更改为 ^1.15.0 由此可见，npm5.1 使得 package.json 和 package-lock.json 中所保存的版本号更加统一，解决了 npm 之前的各种问题。只要准寻好的实践习惯，团队成员可以很方便地维护一套应用代码和 node_modules 依赖都一致的环境。 4.3 最佳实践 使用 npm: &gt;=5.1 版本，保持 package-lock.json 文件默认开启配置 初始化：第一作者初始化项目时使用 npm install &lt;package&gt; 安装依赖包，默认保存 ^X.Y.Z 依赖 range 到 package.json 中；提交 package.json，pacakge-lock.json，不提交 node_modules 目录。 初始化：项目成员首次 checkout/clone 项目代码后，执行一次 npm install 安装依赖包 不要手动修改 package-lock.json 文件 升级依赖包： 升级小版本：本地执行 npm update 升级到新的小版本 升级大版本：本地执行 npm install &lt;package-name&gt;@&lt;version&gt; 升级到新的大版本 也可以手动修改 package.json 中版本号为要升级的版本（大于现有版本号）并指定所需的 semver，然后执行 npm install 本地验证升级后新版本无问题后，提交新的 package.json，package-lock.json 文件 降级依赖包： 正确：npm install &lt;package-name&gt;@&lt;version&gt; 验证无问题后，提交新的 package.json，package-lock.json文件 错误：手动修改 package.json 中的版本号为更低的版本 semver，这样修改并不会生效，因为再次执行 npm install 依然会安装 package-lock.json 中锁定的版本 删除依赖包： 方案1：npm uninstall &lt;package&gt; 并提交 package.json，package-lock.json 文件 方案2： 把要卸载的包从 package.json 中 dependencies 字段删除，然后执行 npm intall 并提交 package.json，package-lock.json 文件 任何时候有人提交了 package.json，package-lock.json 更新后，团队其他成员应该在拉取最新代码后执行 npm install 安装更新后的依赖包 5. npm scripts5.1 基本使用npm scripts 是 npm 另一个很重要的特性。通过 package.json 中 scripts 字段定义一个搅拌，例如： 12345&#123; \"scripts\": &#123; \"echo\": \"echo hello world\" &#125;&#125; 我们就可以通过 npm run echo 命令来执行这段脚本，像在 shell 中执行命令 echo hello world 一样，看到终端输出 hello world npm scripts 提供了一个简单的接口来调用工程相关的脚本。关于更详细的信息，可以参考阮一峰老师的文章npm scripts 使用指南 总结阮一峰老师文章内容： npm run 命令执行时，会把 ./node_modules/.bin/ 目录添加到执行环境的 PATH 变量中，因此如果某个命令行包没有全局安装，而只安装在了当前项目的 node_modules 中，通过 npm run 一样可以调用该命令 执行 npm 脚本时要传入参数，需要在命令后加 -- 标明，如 npm run test -- --grep=&quot;pattern&quot; 可以将 --grep=&quot;pattern&quot; 参数传递给 test 命令 npm 提供了 pre 和 post 两个钩子机制，可以定义某个脚本执行前后的所要执行的脚本 运行时变量：在 npm run 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 process.env 对象访问获得： npm_lifecycle_event ——正在运行的脚本名称 npm_package_&lt;key&gt; ——获取当前包 package.json 中某个字段的配置值：如 npm_package_name 获取报名 npm_package_&lt;key&gt;_&lt;sub-key&gt; —— package.json 中嵌套字段属性：如 npm_package_dependencies_webpack 可以获取到 package.json 中的 dependencies.webpack 字段的值，及 webpack 的版本号 5.2 node_modules/.bin 目录上面所说的 node_module/.bin 目录，保存了依赖目录中所安装的可供调用的命令行包 何谓命令行包？例如 webpack 就属于一个命令行包。如果我们在安装 webpack 时添加 --global 参数，就可以在终端直接输入 webpack 进行调用。但如果不加 --global 参数，我们会在 node_moldues/.bin 目录里看到名为 webpack 的文件，如果在终端直接输入 ./node_modules/.bin/webpack 命令，一样可以执行。 这是因为 webpack 在 package.json 文件中定义了 bin 字段为： 12345&#123; \"bin\": &#123; \"webpack\": \"./bin/webpack.js\" &#125;&#125; bin 字段的配置格式为：&lt;command&gt;: &lt;file&gt;，即命令名: 可执行文件。npm 执行 install 时，会分析每个依赖包的 package.json 中 bin 字段，并将其包含的条目安装到 ./node_modules/.bin 目录中，文件名为 &lt;command&gt;。而如果是全局模式安装，则会在 npm 全局安装路径的 bin 目录下创建指向 &lt;file&gt; 名为 &lt;command&gt; 的软连接。因此，,.node_modules/.bin/webpack 文件在通过命令行调用时，实际上就是执行 node ./node_modules/.bin/webppack.js 命令 正如上一节所说，npm run 命令在执行时会把 ./node_modules/.bin 加入到 PATH 中，使得我们可以直接调用所有提供了命令行调用接口的依赖包。所以最佳的实践是： 将项目依赖的命令行工具安装到项目依赖文件夹中，然后通过 npm scripts 调用，而非全局安装 举例而言，webpack 作为前端最常用的构建工具，虽然我们都习惯了全局安装并直接使用命令行调用，但不同的项目依赖的 webpack 版本可能不同，响应的 webpack.config.js 配置文件也可能只兼容了特定版本的 webpack，如果我们仅仅全局安装了罪行的 webpack4.x，并使用 webpack 命令调用，在一个依赖 webpack3.x 的工程中就会无法成功执行构建 但如果这类工具总是本地安装，我们要调用一个命令，要手动添加 ./node_modules/.bin 这个很长的前缀，未免就太麻烦了，于是 npm 从 5.2 版本开始自带了一个新的工具：npx 5.3 npxnpx 的使用很简单，执行 npx &lt;command&gt; 即可，这里的 &lt;command&gt; 默认就是 ./node_modules 目录中安装的可执行脚本名。例如上面本地安装后的 webpack 包，我们可以直接使用 npx webpack 执行即可 处理这种最简单的场景，npm cli 团队开发者 Kat Marchan 还在这篇文章中介绍了其他几种 npx 的用法：Introducing npx: an npm package runner，国内也有位开发者 robin.law 将原文翻译为中文：npx是什么，为什么需要npx? 总结： 场景A：一键执行远程 npm 源的二进制包 除了在 package 中执行 ./node_modules/.bin 中已经安装的命令，还可以直接指定未安装的二进制包名执行。例如我们在一个没有 package.json 也没有 node_modules 的目录下，执行： 1npx cowsay hello npx 将会从 npm 源下载 cowsay 这个包（但不安装）并执行： 12345678 _______ &lt; hello &gt; ------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\&#x2F;\\ ||----w | || || 这种用途非常适合的场景： 在本地简单测试或调试 npm 源上这些二进制包的功能 调用 create-react-app 或 yeoman 这类往往每个项目只需要使用一次的脚手架工具 场景B：一建执行 GitHub Gist 在 [2.1 package 定义] 这一节中，npm install &lt;package&gt; 可以使包含了有效 package.json 的 git url 而 GitHub Gist 也是 git 仓库的一种，集合 npx 就可以方便地将简单的脚本共享给其他人，用于该链接的人无需将脚本安装到本地工作目录也可以执行。将 package.json 和需要执行的二进制脚本上传至 Gist，再运行 npx &lt;gist url&gt; 就可以方便地执行该 Gist 定义的命令 原文作者 Kat Marchan 提供了 示例，执行： 1npx https:&#x2F;&#x2F;gist.github.com&#x2F;zkat&#x2F;4bc19503fe9e9309e2bfaa2c58074d32 可以得到一个来自 GitHub Gist 的 hello world 问候 场景C：使用不同版本的 node 执行命令 将 npx 与 Aria Stewart 创建的 node 包(https://www.npmjs.com/package/node) 结合，可以实现在一行命令中使用指定版本的 node 执行命令 例如先后执行： 12npx node@4 -e &quot;console.log(process.version)&quot;npx node@6 -e &quot;console.log(process.version)&quot; 将分别输出 v4.8.7 和 v6.13.0 往常这种工作是由 nvm 这类 node 版本管理工具来做的，但 npx node@4 这种方式免去了 nvm 手动切换配置的步骤，更加简洁简单 6. npm 配置6.1 npm confignpm cli 提供了 npm config 命令进行 npm 相关配置，通过 npm config ls -l 可查看 npm 的所有配置，包括默认配置。npm 文档页为每个配置项提供了详细的说明 https://docs.npmjs.com/misc/config 修改配置的命令为：npm config set &lt;ket&gt; &lt;value&gt;，我们使用相关的常见重要配置： proxy，https-procy ——指定 npm 使用的代理 registry ——指定 npm 下载安装时的源，默认为 https://registry.npmjs.org/，可以指定私有的 Registry 源 package-lock ——指定是否默认生成 package-lock 文件，建议保持默认 true save —— true/false 指定是否在 npm install 后保存依赖包为 dependencies，npm5 起默认为 true 删除指定的配置项命令为：npm config delete &lt;key&gt; 6.2 npmrc 文件除了使用 CLI 提供的 npm config 命令显示更改 npm 配置，还可以通过 npmrc 文件直接修改配置 这样的 npmrc 文件优先级由高到低包括： 工程内配置文件：/path/to/my/project/.npmrc 用户级配置文件：!/.npmrc 全局配置文件：$PREFIX/etc/npmrc（即 npm config get globalconfig 输出的路径） npm 内置配置文件：path/to/npm/npmrc 通过这个机制，我们可以方便地在工程根目录创建一个 .pnmrc 文件来共享需要在团队间共享的 npm 运行相关配置。比如如果我们在公司内网环境下需要通过代理才可以访问 registry.npmjs.org 源，或需要访问内网的 registry，就可以在工作项目下新增 .npmrc 文件并提交代码 123proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;https-proxy &#x3D; http:&#x2F;&#x2F;proxy.example.com&#x2F;registry &#x3D; http:&#x2F;&#x2F;registry.example.com&#x2F; 因为项目级 .pnmrc 文件的作用域只作用在本项目下，所以在非本目录下，这些配置并不生效。对于使用笔记本工作的开发者，可以很好地隔离公司的工作项目、在家学习研究项目两种不同的环境 将这个功能已 ~/.npm-init.js 配置相结合，可以将特定配置的 .npmrc 跟 .gitignore，README 之类的文件一起做到 npm init 脚手架中，进一步减少手动配置。 6.3 node 版本约束虽然一个项目的团队都共享了相同的diamante，但每个人的开发及其可能安装了不同的 node 版本，此外服务器端的版本也可能和本地开发机器不一致 这又是一个可能带来不一致性的隐私——但也可以通过声明式约束+脚本限制来解决 声明：通过 package.json 的 engines 属性声明应用运行所需的版本运行时要求。例如项目中使用了 async，awit 特性，查阅兼容性表格得知最低支持版本为 7.6.0，因此指定 engines 配置为： 12345&#123; \"engines\": &#123; \"node\": \"&gt;=7.6.0\" &#125;&#125; 强约束(可选)：在 npm 中以上字段内容仅作为建议字段使用，若要在私有项目中添加强约束，需要自己写脚本钩子，读取并解析 engines 字段的 semver rang ，然后与运行时环境做对比校验，做适当提醒 7. 小结 npm 最佳实践 使用 npm-init 初始化新项目 统一项目配置：需要团队共享的 npm config 配置项，固化到 .npmrc 文件中 统一运行环境，统一 package.json，package-lock.json 文件 合理使多样化的源安装依赖包：npm install &lt;git url&gt;|&lt;local file&gt; 使用 npm: &gt;=5.2 版本 使用 npm scripts 与 npx(npm: &gt;=5.2) 脚本管理应用相关脚本 8. 更多资料参考 npm team 成员 Ashley Williams 在 2016 年 Node.js Live 的 talk：You Don’t Know npm，当时还没有 npm5 YouTube 视频连接：Node.js Live (Paris) - Ashley Williams, You Don’t Know npm 演讲用的 sliders：the ag_deck 这篇 2015 年的文章介绍了如何使用本地模块打包 node_modules 依赖：Build modular application with npm local modules 一篇很好的介绍 package-lock.json 的文章：Everything you wanted to know about package-lock.json 阮一峰 npm scripts 使用指南 Kat Marchan 介绍 npx: 原文：Introducing npx: an npm package runner 中文：npx是什么，为什么需要npx? 文档 npm 官方文档，无中文翻译 package.json 文件 npm config 配置 npm semver 计算器 node_modules 目录扁平化 yarn 中文文档，虽然是 npm 竞争者但兼容 package.json 和 node_modules 目录，因此这两部分可以作参考 package.json - 中文 依赖与版本 - 中文 延伸阅读 sam boyer 《所以你想开发一个包管理系统》，从五官特定语言的角度，介绍一个包管理系统的方方面面：So you want to write a package manager","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"常用 Git 命令","slug":"tech/frequently-git-command","date":"2020-02-02T08:16:19.376Z","updated":"2020-02-02T08:16:19.376Z","comments":true,"path":"2020/02/02/tech/frequently-git-command/","link":"","permalink":"http://yoursite.com/2020/02/02/tech/frequently-git-command/","excerpt":"","text":"原文链接：www.ruanyifeng.com Git 基本的工作流程如下： 几个专用名词： Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库 一、新建代码库12345678# 在当前目录新建一个 Git 代码库$ git init# 新建一个目录，将其初始化为 Git 代码库$ git init [project-name]# 下载一个项目和他的整个代码历史$ git clone [url] 二、配置Git 的设置文件为 .gitconfig，他可以在用户目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件1234567891011121314151617# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...#停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到残酷去$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的commit，替代上一次的提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做一次 commit，并包括指定文件的新变化$ git commit --amend ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定的 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch -trach [branch] [remote-branch]# 在现有分支与指定的远程分支之间，建立追踪关系$ git branch --set-upstream [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并到当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete$ git branch -dr 六、标签1234567891011121314151617181920# 列出所有 tag$ git tag# 在当前分支新建一个 tag$ git tag [tag]# 在指定 commit 上新建一个 tag$ git tag [tag] [commit]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142# 查看有变更的文件$ git status# 查看当前分支的版本历史$ git log# 查看 commit 历史，以及每次 commit 发生变更的问价$ git log --stat# 查看某个文件的版本历史，包括问价改名$ git log --follow [file]$ git whatchanged [file]# 查看指定文件相关的每一次 diff$ git log -p [file]# 查看指定文件什么时间被什么人修改过$ git blame [file]# 查看咋黁去和工作区的差异$ git diff# 查看暂存区和上一个 commit 的差异$ git diff --cached []# 查看工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 查看两次提交之间的差异$ git diff [first-branch] ... [second-branch]# 查看某次提交的元数据和内容变化$ git show [commit]# 查看某次提交发生变化的文件$ git show --name-onle [commit]# 查看某次提交时，某个文件的内容$ git show [commit]:[file-name]# 查看当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库所有的变动$ git fetch [remote]# 查看所有远程仓库$ git remote -v# 查看某个远程仓库的信息git remote show [remote]# 新增一个新的远程仓库，并与其命名$ git remote add [short-name] [url]# 拉取远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --forece# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个 commit 的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个 commit 的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次 commit 保持一致git reser --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定的 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 十、其他1234567891011121314# 生成一个可供发布的压缩包$ git archive# 备份当前工作区的内容$ git stash# 从 Cit 栈中读取最近一次保存的内容，恢复工作区相关的内容$ git stash pop# 查看 Git 栈内所有备份$ git stash list# 清空 Git 栈$ git stash clear","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-01T10:16:28.451Z","updated":"2020-02-01T10:16:28.451Z","comments":true,"path":"2020/02/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]}